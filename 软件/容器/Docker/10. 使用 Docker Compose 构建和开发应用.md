# 使用 Docker Compose 构建和开发应用

在本节课程中，我们将深入探讨如何使用 **Docker Compose** 来构建应用镜像并在开发环境中进行调试。相比之前的课程，本节课程更加实践，我们将主要通过命令行操作，并且修改 Compose 文件以满足开发需求。

## 1. 课程大纲

- 介绍如何配置 Docker Compose 文件以支持构建镜像。
- 讲解如何使用 Docker Compose 构建镜像并在开发过程中动态更新代码，而无需重新构建或停止容器。
- 通过一个具体的案例展示 Compose 如何帮助开发者快速进行代码修改和测试。

## 2. 在开发场景中使用 Docker Compose 构建镜像

在 Docker Compose 中，我们使用 **Dockerfile** 来构建镜像，就像使用 `docker build` 命令一样。为了在 Compose 中构建镜像，我们需要在服务配置中添加 `build` 关键字。下面我们简要回顾如何使用该关键字。

### **Build Key 配置**

- **短格式**：只需指定 Dockerfile 所在的上下文路径。
- **长格式**：可以使用嵌套映射来指定 `context`（上下文路径）和 `dockerfile`（Dockerfile 的名称）。`args` 是可选的，允许在构建时传递构建参数。

例如：

```yaml
services:
  app:
    build:
      context: .
      dockerfile: dev.dockerfile
    image: my_app_image:latest
```

这里，`context` 指定了当前目录，而 `dockerfile` 显式指定了使用 `dev.dockerfile` 构建镜像。

### **构建命令**

- `docker-compose up`：如果服务没有镜像，会自动构建镜像。
- `docker-compose build`：强制重新构建镜像，使用此命令可以避免缓存，确保所有层都重新构建。

此外，`--no-cache` 选项可阻止使用缓存，而 `--pull` 选项会强制拉取最新的基础镜像。

## 3. 案例演示：使用 Compose 构建和开发 Node.js 应用

接下来，我们通过一个具体的开发场景来演示如何使用 Compose 构建镜像并进行开发调试。在这个案例中，我们将使用 **Node.js** 和 **MongoDB**，并通过 **Dockerfile** 配置来实现代码的即时反馈。

### **Dockerfile 配置**

以下是我们的 Dockerfile（`dev.dockerfile`）内容：

```dockerfile
FROM node:14

WORKDIR /src/app

COPY package.json /src/app
RUN npm install

COPY . /src/app

EXPOSE 3000
CMD ["nodemon", "/src/app/bin/www"]
```

- 我们首先设置工作目录 `/src/app`。
- 将 `package.json` 文件复制并安装依赖。
- 使用 `nodemon` 来自动检测代码变化，并在代码变动时重启服务器。

### **dev.docker-compose.yml 配置**

在 Compose 文件中，我们定义了两个服务：`app` 和 `app-db`。`app` 是 Node.js 应用，`app-db` 是 MongoDB 数据库。以下是我们的 Compose 文件配置：

```yaml
version: "3.0"

services:
  app:
    build:
      context: .
      dockerfile: dev.dockerfile
    volumes:
      - ./src:/src/app
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=app-db
    restart: always

  app-db:
    image: mongo:latest
    volumes:
      - db_data:/data/db
    restart: always

volumes:
  db_data:
```

- `volumes` 配置将本地开发代码挂载到容器中，这样就能实时反映代码的更改。
- `ports` 配置将容器的端口 `3000` 映射到宿主机的端口 `3000`，供外部访问。
- `depends_on` 确保 `app` 服务依赖于 `app-db` 服务。

### **启动服务**

使用以下命令启动服务并构建镜像：

```bash
docker-compose -f dev.docker-compose.yml up -d
```

这条命令会：

1. 拉取并构建镜像。
2. 启动容器并将代码映射到容器内，允许动态修改代码并立即生效。

### **验证应用**

我们通过浏览器访问 `http://localhost:3000` 来验证应用是否成功运行。我们可以添加消息并刷新页面，确保数据持久化存储到 MongoDB。

### **代码更新与即时反馈**

接下来，我们修改了页面中的文本（例如，在视图中添加了冒号）并保存更改。由于我们使用了 `nodemon`，它会自动检测到代码更改并重启服务器，开发者无需手动重启容器。

我们还可以修改服务器端 JavaScript 文件，观察到浏览器中会即时反映出更改，无需重启容器或执行任何构建命令。

## 4. 处理 Docker Compose 容器的生命周期

### **停止并删除容器**

要停止并删除容器，可以使用以下命令：

```bash
docker-compose down
```

这将停止并删除所有容器，但会保留卷。为了删除所有数据和镜像，可以使用：

```bash
docker-compose down --rmi all --volumes --remove-orphans
```

### **重新启动服务**

如果我们希望重新启动服务而不丢失数据，只需运行：

```bash
docker-compose up -d
```

### **持久化数据**

在本例中，MongoDB 数据库没有使用持久化卷，因此每次运行 `down` 后，数据会丢失。如果需要持久化数据，只需为数据库服务添加 `volumes` 配置。

## 5. 总结

在本节课程中，我们学习了如何在 Docker Compose 中构建镜像并在开发过程中动态更新代码。通过使用 `nodemon` 和挂载本地代码，我们可以实时查看代码更改而无需重新构建或停止容器。Compose 提供了一个简单的方式来创建隔离的开发环境，减少了开发和生产环境之间的差距。接下来，我们将在下一节课程中探讨如何使用 Docker Compose 在不同环境中共享配置。
