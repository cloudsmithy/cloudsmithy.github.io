---
abbrlink: '0'
---
### 在 Docker 中理解容器和镜像

在本节课中，我们将深入理解如何使用 Docker 命令运行容器，并探讨 Docker 镜像和容器之间的关系。我们将从一个简单的示例开始，逐步解释背后的工作原理。

#### 运行命令

首先，我运行了一个类似于“hello-world”的容器命令，但我们这次运行的是一个 Ubuntu 镜像容器。命令如下：

```bash
sudo docker run -it ubuntu /bin/bash
```

这条命令在 Docker 中创建并运行了一个基于 Ubuntu 镜像的容器，并启动了一个 bash 终端。接下来，我们将拆解这条命令，理解每个部分的作用。

#### 解析命令

1. **docker run**：这是启动一个容器并运行命令的基础命令。
2. **-it**：这两个标志组合起来是让容器以交互模式运行。`-i`表示交互式（interactive），`-t`创建一个伪终端，使得容器的终端行为像一个标准的终端。
3. **ubuntu**：这是 Docker 镜像的名称。在运行此命令时，Docker 会查找本地是否已有该镜像。如果没有，它会自动从 Docker Hub 下载。
4. **/bin/bash**：这是容器启动后运行的命令。在这种情况下，我们运行的是 bash shell。

#### Docker Hub 和镜像下载

Docker Hub 是一个公共的镜像仓库，提供了许多常用的容器镜像。命令中的`ubuntu`就是从 Docker Hub 下载的官方镜像。如果在本地没有找到镜像，Docker 会自动从 Hub 上下载。命令输出如下：

```
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
```

这表示 Docker 在本地找不到`ubuntu:latest`镜像，于是从 Docker Hub 拉取了该镜像。

镜像会被存储在 Docker 的本地存储目录 `/var/lib/docker` 中。下次运行相同命令时，Docker 会检查本地镜像是否已经更新。如果没有更新，Docker 会直接使用本地版本，无需再次下载。

#### 容器的交互式终端

成功下载镜像后，我们进入了 Ubuntu 容器内的 bash 终端，命令行提示符会从 `vagrant@localhost`（宿主机）切换到 `root@` 开头的容器内部终端。

这时，容器就像一个独立的环境，你可以在其中执行命令。当你退出容器终端时，容器也会停止运行。

#### 总结

- **Docker Hub** 是一个容器镜像的注册仓库，包含了许多可以直接使用的镜像。
- **docker run** 命令会根据镜像来启动容器，并执行指定的命令。如果镜像本地没有，Docker 会从 Hub 上下载。
- 使用 **-it** 标志，可以提供一个交互式终端会话来和容器进行交互。
- 一般来说，当容器中的进程退出时，容器也会停止。

### Docker 镜像与容器的区别

在本节课程中，我们将深入探讨 Docker 镜像与容器之间的区别，并通过实际操作演示如何理解这两者的关系。

#### Docker 镜像和容器的基本区别

Docker 镜像和容器之间的区别可以类比为**可执行文件**与**运行中的应用程序**之间的关系。每个运行中的应用程序都是它自己的实例，并且独立于其他实例。运行中的应用程序与可执行文件是分开的，应用程序的变化不会影响可执行文件。同理，Docker 中的镜像是容器的模板，定义了容器的创建方式，而容器则是镜像的一个运行实例。

镜像本质上是一个模板，包含了容器运行所需的一切，而容器则是镜像的实例。每次我们运行容器时，实际上都是在镜像的基础上创建了一个实例。

#### Docker 镜像的结构

Docker 镜像是由多个层（Layer）组成的，每一层表示对文件系统的变化。层次结构使得镜像更为高效，因为不同的层只是对比文件系统的差异，而不是存储重复的文件。

镜像的底层通常是一个最基本的“基础镜像”，例如 Ubuntu 镜像就是基于一个空白的基础镜像（“scratch”）开始的，之后会有多个层添加文件和执行命令。每个层次的更改都会合并到上一层，使得每个镜像都能避免冗余数据。

#### 实践演示：镜像与容器的操作

1. **查看本地镜像**

   使用 `docker images` 命令查看本地镜像。例如，我们之前使用的 `hello-world` 和 `ubuntu` 镜像：

   ```bash
   docker images
   ```

   你会看到镜像名称、标签、ID 以及镜像大小等信息。

2. **查看容器**

   使用 `docker ps` 命令查看正在运行的容器。由于我们还没有运行任何容器，它会显示为空。如果使用 `docker ps -a`，会列出所有曾经运行过的容器。

3. **查看 Docker 目录结构**

   镜像和容器实际存储在 `/var/lib/docker` 目录中。进入该目录可以查看镜像和容器文件的存储位置。每个镜像的文件通常都以 SHA256 哈希命名。

   ```bash
   ls /var/lib/docker
   ```

   这里存储了所有的 Docker 对象，包括镜像和容器。

4. **容器内部查看文件**

   创建一个基于 `ubuntu` 镜像的容器，并进入该容器内部创建文件：

   ```bash
   sudo docker run -it ubuntu /bin/bash
   mkdir /home/myfolder
   echo "This only exists in this container" > /home/myfolder/container.txt
   ```

   通过此操作，我们在容器的 `/home/myfolder` 路径下创建了一个文本文件。

5. **容器的隔离性**

   停止当前容器并启动一个新容器：

   ```bash
   sudo docker ps -a
   sudo docker start <container_name>
   sudo docker attach <container_name>
   ```

   新的容器并不会带有之前容器创建的文件，因为每个容器是相互独立的，容器在创建时就是镜像的一个新的实例。

#### 总结

- **Docker 镜像** 是用来创建容器的模板，包含了容器运行所需的一切配置和依赖。
- **Docker 容器** 是镜像的一个运行实例，它代表了运行中的应用程序。
- 镜像是由多个层组成的，每一层代表对文件系统的变化，容器则是镜像的实例化。
- 每个容器在创建时都是独立的，不会共享其他容器的文件或配置。
