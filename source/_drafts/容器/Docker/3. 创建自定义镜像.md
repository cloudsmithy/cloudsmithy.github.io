---
abbrlink: '0'
---
### 如何使用 Dockerfile 创建自定义镜像

在本节课程中，我们将学习如何使用 **Dockerfile** 创建自定义镜像。Dockerfile 是一个文本文件，包含了你创建镜像所需的所有命令。通过它，你可以指定镜像的起始点，并对镜像做出修改，从而生成一个符合需求的自定义镜像。

#### 创建一个基本的 Dockerfile

我们将从创建一个简单的 Dockerfile 开始。在此示例中，我们的目标是创建一个轻量级容器，该容器仅包含运行我们自己编写的二进制文件所需的部分内容。

首先，让我们清理掉之前创建的所有容器，可以使用 `docker container prune` 命令来删除所有停止的容器。请注意，这将删除所有停止的容器，因此在执行此操作时请小心。

接下来，我们查看当前的镜像，使用 `docker images` 命令列出所有镜像。此时我们会看到 `hello-world` 和 `ubuntu` 镜像。

我们接下来要创建一个新的镜像，这个镜像将运行一个我们自己编写的二进制文件。二进制文件是一个简单的 **Hello World** 应用，使用 Go 编写。如果你想在自己的系统上运行此应用，你需要先安装并配置 Go 编译器，然后编译代码。

#### Dockerfile 结构

一个 **Dockerfile** 文件实际上没有文件扩展名，仅使用 `Dockerfile` 作为文件名。以下是我们将用于演示的 Dockerfile 内容：

```Dockerfile
FROM scratch
COPY hello /hello
CMD ["/hello"]
```

- `FROM scratch`：指定镜像的基础，这里我们使用了 `scratch` 镜像。`scratch` 是一个最小的基础镜像，用于构建最轻量的镜像。
- `COPY hello /hello`：将本地的 `hello` 文件复制到镜像的根目录 `/hello`。
- `CMD ["/hello"]`：指定容器启动时默认执行的命令，这里是运行 `/hello` 二进制文件。

#### 构建镜像

1. **进入终端**，并确保我们在包含 Dockerfile 和二进制文件 `hello` 的目录中。然后运行以下命令来构建镜像：

   ```bash
   docker build -t greeting .
   ```

   - `-t greeting`：指定镜像的标签（名称）。
   - `.`：表示当前目录。

   这条命令将会读取当前目录中的 Dockerfile，依次执行文件中的命令并构建镜像。

2. **查看镜像**：构建完成后，我们可以再次使用 `docker images` 命令来查看新创建的镜像。

#### 运行容器

当镜像创建好后，我们可以使用 `docker run` 命令来运行该镜像，创建并启动容器：

```bash
docker run greeting
```

此命令会启动一个基于 `greeting` 镜像的容器，并执行 `/hello` 命令。你应该看到 "Hello World" 的输出，表示容器内的二进制文件成功执行。

#### 清理和优化

1. **删除镜像**：如果你想删除镜像，可以使用以下命令：

   ```bash
   docker rmi <image_id>
   ```

2. **使用 `-t` 指定镜像标签**：在构建镜像时，可以通过 `-t` 参数为镜像指定一个名称和标签。默认标签为 `latest`，但你可以根据需要指定其他标签。例如：

   ```bash
   docker build -t myimage:v1 .
   ```

#### 总结

- Docker 镜像是一个可执行的模板，通过它可以创建容器。
- **Dockerfile** 是用于创建镜像的配置文件，它定义了镜像的基础、文件复制和容器启动时执行的命令。
- 在使用 **scratch** 基础镜像时，能够创建一个轻量级的容器，只包含应用运行所需的最小部分。
- Docker 的 **build** 命令用于构建镜像，**run** 命令用于运行镜像并启动容器。

### 使用 Docker Commit 创建自定义镜像

在本节课中，我们将展示如何使用 `docker commit` 命令将已修改的容器转化为镜像。虽然我们之前使用了 Dockerfile 来创建镜像，但 `docker commit` 也是一个有效的方法，尤其是在你已经有一个容器并希望对其进行修改时。

#### Docker Commit 命令简介

`docker commit` 命令允许你将一个正在运行的容器的当前状态保存为一个新的镜像。这样，你可以基于现有的容器做一些更改，随后将这些更改保存为一个新的镜像。虽然 `docker commit` 是一种便捷的方法，但更推荐使用 Dockerfile，因为它使得创建镜像的过程更加规范化，可以追溯并用于自动化。

#### 示例：从 Ubuntu 容器创建新镜像

1. **启动 Ubuntu 容器**：
   我们从 Ubuntu 镜像启动一个容器，并进入容器的 bash 环境。

   ```bash
   sudo docker run -it ubuntu /bin/bash
   ```

   进入容器后，我们可以确认当前是否安装了 Python：

   ```bash
   which python
   ```

   由于我们刚刚启动的是一个基本的 Ubuntu 容器，因此默认情况下 Python 是没有安装的。

2. **安装 Python**：
   使用 `apt` 命令安装 Python：

   ```bash
   apt-get update
   apt-get install python
   ```

   安装完成后，验证 Python 是否正确安装：

   ```bash
   python --version
   ```

3. **提交容器为镜像**：
   安装 Python 后，我们退出容器，并使用 `docker commit` 命令将其转化为一个新的镜像。我们为镜像命名为 `ubuntu_python`：

   ```bash
   docker commit <container_id> ubuntu_python
   ```

   这里的 `<container_id>` 是容器的 ID，你可以使用 `docker ps -a` 命令查看并获取容器 ID。

4. **运行新的镜像**：
   如果我们直接基于新创建的镜像启动容器，默认情况下它会执行 Ubuntu 镜像的默认命令，即 bash。此时我们并不需要进入 bash，想要执行 Python 程序，我们需要更改默认命令。

   **删除旧容器和镜像**：
   我们可以删除刚刚创建的容器和镜像：

   ```bash
   docker rm <container_id>
   docker rmi ubuntu_python
   ```

   **修改镜像的默认命令**：
   使用 `--change` 标志更改容器的默认命令，将其设置为运行 Python 并执行简单的代码：

   ```bash
   docker commit --change='CMD ["python", "-c", "print('Hello from Python!')"]' <container_id> ubuntu_python
   ```

5. **运行新镜像并验证**：
   运行新创建的镜像并验证其输出：

   ```bash
   docker run ubuntu_python
   ```

   你应该能看到 Python 输出：

   ```bash
   Hello from Python!
   ```

#### 总结

- `docker commit` 允许你基于现有容器的状态创建一个新的镜像。
- 你可以使用 `--change` 标志来修改镜像的默认命令或其他指令。
- 使用 `docker commit` 的一个缺点是，它不如 Dockerfile 那样便于自动化和版本控制，因此推荐在可行的情况下使用 Dockerfile。

`CMD` 和 `ENTRYPOINT` 是 Dockerfile 中定义容器启动行为的两种指令。它们都用于指定容器启动时运行的命令，但它们的使用场景和行为有些不同。下面是它们的区别：

### 1. **CMD**

- **功能**：`CMD` 用于为启动的容器提供默认的命令和参数。如果运行容器时没有指定命令或参数，`CMD` 中的命令将会被执行。
- **使用场景**：`CMD` 主要用于设置容器的默认行为，但允许用户在启动容器时覆盖该命令。
- **语法**：

  - **CMD \["executable", "param1", "param2"]**（推荐）
  - **CMD \["param1", "param2"]** （适用于 `ENTRYPOINT` 指令已经指定了可执行文件的情况）
  - **CMD \["executable param1 param2"]**（不推荐，不符合 JSON 语法的规范）

- **覆盖**：`CMD` 可以被 `docker run` 命令中指定的参数覆盖。例如，使用 `docker run <image> <command>` 时，`<command>` 会替代 Dockerfile 中的 `CMD`。

### 2. **ENTRYPOINT**

- **功能**：`ENTRYPOINT` 用于定义容器的主命令，即使在 `docker run` 时传递不同的命令和参数，`ENTRYPOINT` 中定义的命令始终会执行。它确保容器启动时一定会执行该命令。
- **使用场景**：`ENTRYPOINT` 适合用来设置容器的固定入口点，比如启动一个特定的服务或程序。用户可以通过 `CMD` 或 `docker run` 传递额外的参数给 `ENTRYPOINT`。
- **语法**：

  - **ENTRYPOINT \["executable", "param1", "param2"]**（推荐）
  - **ENTRYPOINT \["executable param1 param2"]**（不推荐）

- **覆盖**：`ENTRYPOINT` 的命令不能被 `docker run` 中指定的命令覆盖，但可以通过 `docker run` 传递参数来修改命令的行为。

### 3. **组合使用 CMD 和 ENTRYPOINT**

通常情况下，`ENTRYPOINT` 和 `CMD` 会一起使用，它们的行为可以相互补充。`ENTRYPOINT` 用于定义容器的主要命令，而 `CMD` 用于传递给该命令的默认参数。`CMD` 可以被 `docker run` 中指定的参数覆盖，但 `ENTRYPOINT` 定义的命令是不可更改的。

- **例子 1**：`ENTRYPOINT` 定义主命令，`CMD` 提供默认参数：

  ```Dockerfile
  ENTRYPOINT ["python"]
  CMD ["app.py"]
  ```

  这样，当容器启动时，默认执行 `python app.py`。但是用户可以通过 `docker run <image> <another_script.py>` 来覆盖 `CMD` 中的参数，启动不同的 Python 脚本。

- **例子 2**：只使用 `ENTRYPOINT`：

  ```Dockerfile
  ENTRYPOINT ["python", "app.py"]
  ```

  这里，`CMD` 被省略了，容器每次启动时都将执行 `python app.py`，且无法通过 `docker run` 覆盖。

- **例子 3**：只使用 `CMD`：

  ```Dockerfile
  CMD ["python", "app.py"]
  ```

  这里，`CMD` 提供了容器启动时的默认命令，但如果运行 `docker run <image> <other_command>`，`CMD` 就会被覆盖，执行新的命令。

### 总结：

- **CMD**：用于提供容器的默认命令，用户可以通过 `docker run` 覆盖它。
- **ENTRYPOINT**：定义容器的主命令，不能通过 `docker run` 覆盖，但可以通过传递参数来修改行为。

通常情况下，推荐组合使用 `ENTRYPOINT` 和 `CMD`，以便在提供灵活性和默认行为之间找到平衡。
