---
abbrlink: '0'
---
### Kubernetes 多容器 Pod：实现 3 层应用

在 Kubernetes 中，**多容器 Pod** 是一种将多个紧密相关的容器组合在一起的方式，容器在同一个 Pod 内共享相同的网络和存储资源。这种方式适用于需要紧密协作的服务，能够在同一个 Pod 中进行资源共享和通信。

在本节课中，我们将创建一个 3 层应用，包含 4 个容器，并通过 Kubernetes 来管理它们。我们将介绍如何在多容器 Pod 中使用 **Namespace** 和 **Pod 日志**，同时学习如何让不同层次的服务相互协作。

---

## 应用架构

我们要实现的应用是一个简单的计数器系统，包含 **4 个容器**，分布在 **3 个层级**：

1. **应用层**：包含一个 Node.js 服务器容器，它接收一个 POST 请求用于递增计数器，并通过 GET 请求获取当前计数值。
2. **数据层**：使用 **Redis** 存储计数器的值。
3. **支持层**：包含两个容器：**Poller** 容器（不断发送 GET 请求到服务器，打印计数器值）和 **Counter** 容器（随机发送 POST 请求到服务器，递增计数器）。

---

## 使用 Namespace 隔离资源

Kubernetes 的 **Namespace** 功能帮助我们隔离不同的资源，可以用于不同用户、环境或应用的资源管理。在本课程中，我们为该应用创建一个名为 `microservices` 的 Namespace。

### 创建 Namespace

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: microservices
  labels:
    app: counter-microservice
```

使用以下命令创建该 Namespace：

```bash
kubectl create -f microservices-namespace.yaml
```

创建后，你可以在任何资源的 Manifest 文件中指定该 Namespace。

---

## 创建多容器 Pod

接下来，我们将创建一个多容器 Pod，将应用的 4 个容器放入同一个 Pod 中。这些容器分别是 Redis、Server、Counter 和 Poller。

### Pod Manifest 文件

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
  namespace: microservices
spec:
  containers:
    - name: redis
      image: redis:latest
      ports:
        - containerPort: 6379
    - name: server
      image: node:latest
      env:
        - name: REDIS_URL
          value: "localhost:6379"
      ports:
        - containerPort: 8080
    - name: counter
      image: counter-app:latest
      env:
        - name: API_URL
          value: "http://localhost:8080"
    - name: poller
      image: poller-app:latest
      env:
        - name: API_URL
          value: "http://localhost:8080"
```

### 创建 Pod

使用以下命令创建 Pod：

```bash
kubectl create -f app-pod.yaml -n microservices
```

### 查看 Pod 状态

使用以下命令查看 Pod 状态：

```bash
kubectl get pods -n microservices
```

你将看到 Pod 中的所有容器状态。

### 查看 Pod 详细信息

使用 `kubectl describe` 获取详细信息：

```bash
kubectl describe pod app -n microservices
```

这将显示更多的事件和每个容器的状态，帮助你进行调试。

---

## 查看容器日志

Kubernetes 通过 **kubectl logs** 命令提供容器日志。日志包括容器标准输出（stdout）和标准错误（stderr）的内容。

### 获取特定容器的日志

例如，要查看 `counter` 容器的最近 10 行日志，可以使用以下命令：

```bash
kubectl logs -n microservices app counter --tail 10
```

### 实时查看日志

使用 `-f` 选项实时查看日志输出：

```bash
kubectl logs -n microservices app poller -f
```

这会实时显示 `poller` 容器的日志，帮助你观察计数器的变化过程。

---

## 资源请求与限制

在 Kubernetes 中，你可以为 Pod 和容器设置 **资源请求** 和 **资源限制**，确保容器不会消耗过多的资源。资源请求是 Pod 启动时所需的最低资源，而资源限制是 Pod 最大可以使用的资源。

### 设置资源请求和限制

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
  namespace: microservices
spec:
  containers:
    - name: redis
      image: redis:latest
      resources:
        requests:
          memory: "64Mi"
          cpu: "250m"
        limits:
          memory: "128Mi"
          cpu: "500m"
    - name: server
      image: node:latest
      resources:
        requests:
          memory: "128Mi"
          cpu: "500m"
        limits:
          memory: "256Mi"
          cpu: "1"
```

### 更新 Pod 的资源

如果你已经创建了 Pod，但需要更新资源请求和限制，你需要删除 Pod 并重新创建：

```bash
kubectl delete pod app -n microservices
kubectl create -f app-pod.yaml -n microservices
```

---

## 小结

在本节课中，我们学习了如何创建和管理 Kubernetes 中的 **多容器 Pod**：

- **Namespace** 用于隔离不同资源，使得管理更加清晰；
- **多容器 Pod** 使得紧密协作的容器能够共享同一个网络和存储；
- 我们还了解了如何查看容器日志，并通过 **kubectl logs** 命令帮助调试应用；
- **资源请求和限制** 确保容器运行在合理的资源范围内。

在下一节课中，我们将使用 **服务（Service）** 来将我们的多容器 Pod 拆分成多个独立的服务，并实现应用的可扩展性。
