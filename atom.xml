<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>镜湖</title>
  
  
  <link href="https://airag.click/atom.xml" rel="self"/>
  
  <link href="https://airag.click/"/>
  <updated>2025-07-20T12:05:44.892Z</updated>
  <id>https://airag.click/</id>
  
  <author>
    <name>Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>懒猫微服买硬件送服务，刚学的计算机知识顺便接了个单</title>
    <link href="https://airag.click/posts/cb1ae078/"/>
    <id>https://airag.click/posts/cb1ae078/</id>
    <published>2025-07-18T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事先声明，懒猫微服不提供接单服务，但是可以通过贡献攻略和移植应用赚取激励。</p></blockquote><p>挺有意思的一个事，头几天刚刚找过懒猫微服的技术帮我配置 cloudflare 相关操作，顺便学习了一下基本使用，把自己在 AWS 的 Route53 上购买的域名迁移过去了，然后代理到了博客，AWS EC2 服务器，甚至家里的机器。</p><p>偶然间在微信群看到这样一个需求，这不就是前两天懒猫微服的技术人员手把手教我做的。cloudflare 有很多操作，之前周围的人还有使用 cloudflare 反向代理到家里的 NAS，然后 obsidian 实时同步笔记连回家的。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720131125114.png" alt="image-20250720131125114"></p><p>于是我给了他三个方案：</p><ol><li>最省心的：cloudflare 只做域名解析，应用无缝迁移到 Linux 服务器上。</li><li>全托管的：cloudflare 做域名解析，然后利用 cloudflare 的 Worker 部署后端</li><li>最日常的：使用 cloudflare tunnel 反向代理到家里电脑。</li></ol><p>客户选择了方案 3，然后接下来就是配置 cloudflare tunnel，甚至不用再配置 A 记录。</p><h2 id="🌐-Cloudflare-Tunnel-能干什么？"><a href="#🌐-Cloudflare-Tunnel-能干什么？" class="headerlink" title="🌐 Cloudflare Tunnel 能干什么？"></a>🌐 Cloudflare Tunnel 能干什么？</h2><ul><li>把本地 Web 服务（如网站、应用、API、NAS）通过 Cloudflare 安全暴露到公网</li><li><strong>无需公网 IP</strong>，不管你是在家庭宽带、NAT、内网还是 IPv6-only 网络都能跑</li><li>通过 Cloudflare 的全球 CDN 加速和防护（DDoS 保护、TLS、WAF）</li><li>支持访问控制（如 Zero Trust）</li><li>支持反向代理多服务（如 <code>/app1</code>, <code>/app2</code>）或多个子域名绑定</li></ul><p>首先登录到<a href="https://dash.cloudflare.com/%E9%A6%96%E9%A1%B5%E3%80%82%E7%82%B9%E5%87%BBZero-Trust%E3%80%82">https://dash.cloudflare.com/首页。点击Zero-Trust。</a></p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720132333168.png" alt="image-20250720132333168"></p><p>然后选择 网络 - Tunnels ，然后新建隧道来内网穿透。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720144304637.png" alt="image-20250720144304637"></p><p>选择创建隧道，这个哥们是 Windows 的环境，所以隧道类型使用 Cloudflared。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720144329817.png" alt="image-20250720144329817"></p><p>然后选择新建隧道，然后输入隧道名称。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720144350889.png" alt="image-20250720144350889"></p><p>这个时候选择安装 cloudflared 引擎，需要安装一个 agent，基本是全平台都有，甚至还有 Docker 版本的。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720144633620.png" alt="image-20250720144633620"></p><p>然后把 test 子域代理本地的 localhost:8000。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720145038577.png" alt="image-20250720145038577"></p><p>然后通过域名访问就可以了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250720145308297.png" alt="image-20250720145308297"></p><p>这哥们还有一个额外的要求，要开启启动天  Cloudflared ，然后 GPT 了一下</p><p>直接启动已安装的  Cloudflared  服务</p><p>运行 Start-Service cloudflared 启动服务</p><p>使用 Get-Service cloudflared 查看服务状态</p><p>设为开机自启</p><p>运行 Set-Service cloudflared -StartupType Automatic 将</p><p>Cloudflared 设置为自动启动</p><blockquote><p>结语</p><p>买 NAS 学的是网络技术，虽然可能是别人眼中的野路子。但是多一分趣味嘛。切身感受到技术的意义。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;事先声明，懒猫微服不提供接单服务，但是可以通过贡献攻略和移植应用赚取激励。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挺有意思的一个事，头几天刚刚找过懒猫微服的技术帮我配置 cloudflare 相关操作，顺便学习了一下基本使用，把自己在 AWS 的 Route53 上购买的域名迁移过去了，然后代理到了博客，AWS EC2 服务器，甚至家里的机器。&lt;/p&gt;
&lt;p&gt;偶然间在微信群看到这样一个需求，这不就是前两天懒猫微服的技术人员手把手教我做的。cloudflare 有很多操作，之前周围的人还有使用 cloudflare 反向代理到家里的 NAS，然后 obsidian 实时同步笔记连回家的。&lt;/p&gt;</summary>
    
    
    
    <category term="Cloudflared" scheme="https://airag.click/categories/Cloudflared/"/>
    
    
    <category term="Cloudflared" scheme="https://airag.click/tags/Cloudflared/"/>
    
  </entry>
  
  <entry>
    <title>GIT小书</title>
    <link href="https://airag.click/posts/fa9f211a/"/>
    <id>https://airag.click/posts/fa9f211a/</id>
    <published>2025-07-17T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.893Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一章：不明觉厉的-Git"><a href="#第一章：不明觉厉的-Git" class="headerlink" title="第一章：不明觉厉的 Git"></a><strong>第一章：不明觉厉的 Git</strong></h4><p>小李刚从大学毕业，加入了一家快速发展的初创公司，成为了公司的前端开发工程师。这是他人生中的第一份正式工作，他兴奋又忐忑。虽然他在学校里学过一些编程技术，但真正的项目经验还很薄弱。第一天，老板就把他分配到了一个正在开发的 Web 项目中，需要用 Git 进行版本管理。</p><p>“小李，这是你需要参与的项目，我们已经把代码推到 GitHub 上了，记得拉取下来工作。”老板简短的几句话让小李有点懵。</p><p>“GitHub？拉取？我听说过 Git，但从来没用过。”小李在心里嘀咕着。他记得在学校的课堂上，老师提到过 Git 作为一种版本控制工具，可以帮助开发团队协作，但具体怎么使用，还是个谜。</p><span id="more"></span><p>“小李，别担心，我们的团队里有很多 Git 使用经验丰富的人，你可以请教他们。”老板似乎察觉到他的一丝不安，轻轻拍了拍他的肩膀。“首先，你得把代码克隆到本地。”</p><p>“克隆？那是什么？”小李心中更是一阵迷茫。</p><p>他的同事小王看出了他的困惑，走过来笑着解释：“Git 是一种分布式的版本控制系统，‘克隆’是从远程仓库复制一份代码到你本地电脑上的操作。你只需要使用 <code>git clone</code> 命令，把我们的仓库拉下来就行了。”</p><p>小李点点头，拿起电脑，打开命令行，准备开始他的 Git 之旅。</p><h4 id="第二章：第一次克隆"><a href="#第二章：第一次克隆" class="headerlink" title="第二章：第一次克隆"></a><strong>第二章：第一次克隆</strong></h4><p>小李根据小王的提示，打开了 GitHub，找到了公司项目的仓库链接。接着，他按照小王的指示，输入了以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/company/project-repo.git</span><br></pre></td></tr></table></figure><p>他按下回车键，屏幕上出现了下载的进度条，Git 开始从远程仓库将项目文件拉取到本地。当下载完成后，他看到自己的本地目录下多了一个与仓库同名的文件夹，这时，他才恍若大悟，原来 Git 仓库就像是一个储藏库，而 <code>git clone</code> 命令就是让这个储藏库的内容变成了他自己本地的副本。</p><p>“小王，这样我就能开始写代码了吗？”小李兴奋地问。</p><p>“是的！不过在你修改代码之前，你需要查看一下当前的状态。” 小王笑了笑，接着说：“输入 <code>git status</code> 命令，它会告诉你当前文件夹里的文件是否已被 Git 跟踪，是否有变更。”</p><p>小李按照提示输入了 <code>git status</code>，屏幕上显示出一长串信息，告诉他哪些文件被修改了，哪些文件没有被 Git 跟踪。</p><p>“原来 Git 会这么细致地记录每个文件的变化啊！太厉害了。” 小李感慨道。</p><h4 id="第三章：第一次提交"><a href="#第三章：第一次提交" class="headerlink" title="第三章：第一次提交"></a><strong>第三章：第一次提交</strong></h4><p>经过短暂的适应，小李开始修改代码。他添加了一些新的功能，并修复了一个小 bug。这时，他想把自己做的更改提交到 Git。</p><p>“小王，接下来该怎么办？”小李再次求助于小王。</p><p>“你需要先使用 <code>git add</code> 把修改的文件放到暂存区，然后再用 <code>git commit</code> 提交到本地仓库。” 小王耐心地解释道。</p><p>小李按照步骤执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add index.html</span><br><span class="line">git commit -m &quot;修复首页 bug，添加登录功能&quot;</span><br></pre></td></tr></table></figure><p>“提交完成了！” 小李兴奋地说道。</p><p>小王接着补充道：“记住，提交信息要简洁明了，别人可以通过这些信息快速了解你修改的内容。”</p><p>小李点点头，觉得这比学校的作业提交要简单多了。每一次修改都能被记录下来，每一次提交都可以清晰地说明自己做了什么。</p><h4 id="第四章：第一次推送"><a href="#第四章：第一次推送" class="headerlink" title="第四章：第一次推送"></a><strong>第四章：第一次推送</strong></h4><p>小李第一次提交到本地仓库后，心里有了些许成就感。接着，他又向小王询问：“如果我想把本地的修改推送到远程仓库，应该怎么做？”</p><p>“你需要用 <code>git push</code> 命令来推送你的提交到远程仓库。” 小王笑着回答，“不过，在推送之前，你需要先从远程仓库拉取最新的代码，避免和其他人的修改发生冲突。”</p><p>“哦，明白了。”小李迅速输入了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>当他成功将本地修改推送到远程仓库时，屏幕上出现了“push successful”的提示。他心中不禁涌现出一股自豪感：“原来，Git 还真是方便，和团队合作时，每个人都能在同一个项目上协同工作！”</p><h4 id="第五章：第一次遇到冲突"><a href="#第五章：第一次遇到冲突" class="headerlink" title="第五章：第一次遇到冲突"></a><strong>第五章：第一次遇到冲突</strong></h4><p>几天后，团队里另外一位开发者小张修改了同一个文件，并且推送到了远程仓库。小李接着更新了代码库，准备继续开发时，突然遇到了一个问题。</p><p>“Git 说我无法推送，提示我当前分支落后于远程分支。”小李看着终端输出的错误信息，感到有些困惑。</p><p>小王走过来看了一眼，解释道：“这是因为你在推送之前没有拉取最新的远程代码，Git 检测到远程仓库有你没有更新的提交，因此推送失败。”</p><p>“那该怎么办？”小李焦急地问。</p><p>“我们需要先拉取远程的更新，解决可能的冲突，再进行推送。”小王平静地说道。</p><p>于是，小李输入了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>Git 检测到有冲突文件后，小李被要求手动解决冲突。经过一番调试，他成功解决了冲突，并将自己的更改再次推送到远程仓库。</p><p>“解决冲突是 Git 使用中的一项重要技能，虽然有点麻烦，但熟悉了之后就能游刃有余。” 小王笑着提醒他。</p><h4 id="第六章：Git，成了朋友"><a href="#第六章：Git，成了朋友" class="headerlink" title="第六章：Git，成了朋友"></a><strong>第六章：Git，成了朋友</strong></h4><p>这一天，小李结束了一天的工作。他站在公司楼下，深吸一口气，觉得整个世界变得更加清晰。Git，这个曾经陌生又让他感到害怕的工具，现在已经变成了他开发工作中不可或缺的伙伴。</p><p>“小王，谢谢你教我这么多。” 小李感激地说。</p><p>“不用谢，我们都是一个团队。” 小王微笑着回答。</p><p>随着日子的推移，小李对 Git 的理解越来越深入。每当遇到问题时，他不再感到焦虑，而是学会了从容应对。在这条开发道路上，Git 已经成为了他忠实的伙伴，帮助他高效管理版本，协同开发。</p><h4 id="第七章：第一次的-Git-Rebase"><a href="#第七章：第一次的-Git-Rebase" class="headerlink" title="第七章：第一次的 Git Rebase"></a><strong>第七章：第一次的 Git Rebase</strong></h4><p>随着项目的不断发展，小李逐渐熟悉了 Git 的基本操作，代码管理变得越来越得心应手。然而，随着开发人员数量的增加，项目中的提交历史开始显得越来越凌乱，尤其是一些多次合并的提交记录，看上去非常混乱。</p><p>有一天，小李在查看 Git 提交历史时，发现每次合并分支的提交记录都让历史显得很复杂：“这样下去，历史会越来越乱，别人查找问题的时候会很麻烦。”</p><p>小李向小王请教，是否有办法将这些杂乱的提交历史整理得更加简洁。</p><p>“你可以使用 <code>git rebase</code> 来整理提交历史，” 小王解释道，“<code>git rebase</code> 可以把你的提交历史进行重新排列，将一些不必要的合并提交压缩成更简洁的历史记录。”</p><p>小李兴奋地想试一试。于是，他在 Git 上执行了 <code>git rebase -i</code> 命令，进入了交互式 rebase 模式。这个命令让他可以查看最近的几个提交记录，并选择哪些提交需要保留，哪些提交需要合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~5</span><br></pre></td></tr></table></figure><p>Git 打开了一个编辑器，列出了最近的 5 次提交记录。小李看到，之前的一些功能开发提交被频繁地合并，而这些合并的记录并没有特别的意义。他决定将这些不重要的提交进行合并。</p><p>通过将不必要的提交标记为 <code>squash</code>（合并），小李简洁地将历史整理得更加简洁，并减少了重复的合并提交。整理完成后，他使用 <code>git push</code> 推送了这些更改。</p><p>当他看到远程仓库的提交历史变得清晰简洁时，心中充满了成就感。原来，Git 不仅是一个强大的版本控制工具，它也能帮助开发者将代码历史整理得井井有条。</p><h4 id="第八章：团队合作中的-Git-Stash"><a href="#第八章：团队合作中的-Git-Stash" class="headerlink" title="第八章：团队合作中的 Git Stash"></a><strong>第八章：团队合作中的 Git Stash</strong></h4><p>团队开发中，小李和其他同事经常需要在不同的任务之间切换。一天，小李在开发一个新功能时，突然接到紧急任务，要求他修复一个线上 bug。他立即决定中止当前工作，切换到 bug 修复任务。</p><p>“小王，怎么才能保证我现在的工作不会丢失呢？”小李问道。</p><p>“你可以使用 <code>git stash</code> 命令，把当前未完成的工作保存起来，等你修复完 bug 后再恢复。” 小王笑着答道。</p><p>“这可以让我暂时保存当前的工作进展？”小李眼前一亮。</p><p>于是，小李按照小王的建议，输入了以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>Git 将他当前工作区的更改暂时保存了起来，并恢复了工作目录的干净状态。小李随后切换到了修复 bug 的任务，并快速解决了问题。</p><p>几小时后，他回到原先的任务时，使用 <code>git stash apply</code> 恢复了之前未完成的工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>小李惊讶地发现，所有的更改和修改都完好无损地恢复了过来。通过 <code>git stash</code>，他不仅没有丢失任何代码，而且能够在不提交的情况下，顺利切换任务。</p><p>这让他深刻体会到，Git 是多么强大的工具，在团队协作和多任务处理中，它能够帮助开发者高效管理代码和进度。</p><h4 id="第九章：深入-Git-Bisect-查找-Bug"><a href="#第九章：深入-Git-Bisect-查找-Bug" class="headerlink" title="第九章：深入 Git Bisect 查找 Bug"></a><strong>第九章：深入 Git Bisect 查找 Bug</strong></h4><p>项目中的一个新功能上线后，客户突然反馈了一个 bug，导致页面无法正确显示数据。小李接到任务后，立即开始调查这个问题。但问题是，线上代码已经迭代了好几个版本，谁也不清楚到底是哪一次提交引入了问题。</p><p>“小王，如何才能定位到具体是哪个提交引入了 bug 呢？”小李问道。</p><p>“你可以使用 <code>git bisect</code> 来进行二分查找。”小王回答道，“<code>git bisect</code> 可以帮助你快速找到 bug 引发的提交。它会将历史提交分成两部分，每次告诉你一个范围，你只需要标记 bug 是否存在，Git 会逐步缩小范围，直到找到问题的根源。”</p><p>小李恍然大悟。于是，他开始使用 <code>git bisect</code> 查找 bug 的根源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good v1.0</span><br></pre></td></tr></table></figure><p><code>git bisect</code> 会从最近的提交开始，将所有的提交历史分成两部分，并让小李检查每一部分是否存在 bug。每次，他都根据测试结果输入“good”或“bad”，Git 会根据他的反馈继续缩小范围。</p><p>最终，Git 在经过几轮查找后，成功定位到某个特定的提交，这个提交引入了 bug。小李修复了 bug 后，通过 <code>git bisect reset</code> 重置了 bisect 状态，返回到正常的开发流程。</p><p>“原来 Git 不仅可以帮助我们管理版本，还能高效地找出问题的根源。” 小李感叹道。</p><h4 id="第十章：Git-冲突中的成长"><a href="#第十章：Git-冲突中的成长" class="headerlink" title="第十章：Git 冲突中的成长"></a><strong>第十章：Git 冲突中的成长</strong></h4><p>随着团队中成员越来越多，开发中出现的合并冲突也越来越频繁。虽然小李已经掌握了一些 Git 的基本操作，但每当遇到合并冲突时，他还是感到有些紧张和不知所措。</p><p>一天，他在合并一个分支时，遇到了一个棘手的冲突，Git 无法自动合并他和其他同事的更改。</p><p>“小王，怎么解决合并冲突呢？”小李有些焦虑。</p><p>小王笑了笑，走过来耐心地解释道：“Git 会标记出冲突的地方，你需要打开冲突文件，手动选择保留哪部分代码。解决完冲突后，再执行 <code>git add</code> 和 <code>git commit</code>。”</p><p>小李按照指示，打开了冲突文件，看到了被 Git 标记出来的冲突部分。经过仔细的分析，他决定保留自己的修改，并删除了无关的部分。</p><p>解决冲突后，小李使用了以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;解决合并冲突&quot;</span><br></pre></td></tr></table></figure><p>“解决了！这次我终于顺利地解决了冲突。”小李长舒一口气。</p><p>“别担心，冲突在团队开发中很常见，解决起来也是一种成长。”小王鼓励他说。</p><p>从这次经历后，小李对 Git 的理解更加深刻，他开始不再畏惧合并冲突，反而在解决冲突的过程中积累了更多的经验。</p><h4 id="第十一章：Git-的复合技能——远程协作中的“Push”与“Pull”"><a href="#第十一章：Git-的复合技能——远程协作中的“Push”与“Pull”" class="headerlink" title="第十一章：Git 的复合技能——远程协作中的“Push”与“Pull”"></a><strong>第十一章：Git 的复合技能——远程协作中的“Push”与“Pull”</strong></h4><p>时间过得飞快，随着项目的逐步推进，小李越来越熟悉了 Git 的使用。一次，团队的新需求要求他和小张一起共同开发一个新功能。项目中由于要对数据接口进行修改，涉及到的代码文件较多，这也意味着双方必须频繁地同步代码，避免重复工作。</p><p>“小李，你负责前端页面的改动，我负责后端接口的修改。我们需要保持代码同步，你把你的修改推送到 Git 仓库，我拉取下来进行合并。” 小张提醒道。</p><p>“好的，小张，我会尽量减少冲突的。” 小李点点头，心里想着如何避免两个开发者在代码中的修改冲突。</p><p>小李根据约定，开始在本地开发工作并修改了部分前端代码。当修改完毕后，他通过 <code>git add</code> 和 <code>git commit</code> 提交了自己的修改。接着，他输入了 <code>git push</code> 命令，将本地的更改推送到了远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-frontend</span><br></pre></td></tr></table></figure><p>随着“push successful”的提示，修改成功上传到了远程仓库。小李心里松了一口气，开始等着小张拉取他的代码进行合并。</p><p>然而，小张这边也在进行着自己的开发工作，修改了后端接口，并且同样进行了提交。当小张准备将修改推送到仓库时，却遇到了困难。“小李，我拉取了你的代码，但是推送时遇到了错误，说我本地分支落后于远程分支。”</p><p>“哦，那是因为我在你推送之前就已经提交了我的修改。你需要先拉取我的更改，再进行推送。” 小李知道问题所在，告诉了小张解决方案。</p><p>小张理解地点点头，输入了 <code>git pull</code> 来拉取最新的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin feature-frontend</span><br></pre></td></tr></table></figure><p>Git 自动将小张的修改和小李的修改进行了合并，并解决了没有冲突的部分。小张再一次执行 <code>git push</code>，这次成功了。</p><p>“解决了！感谢你，小李。” 小张松了口气，“这就是协作开发的魅力，不同的代码能在 Git 中无缝连接。”</p><p>小李微笑着点头，虽然有时遇到一些小麻烦，但通过 Git，这一切变得简单而高效。在远程协作中，<code>git push</code> 和 <code>git pull</code> 成为他日常开发的两大法宝，每次与团队成员一起开发时，他都能高效同步、解决冲突，确保项目的顺利推进。</p><h4 id="第十二章：Git-中的-“Tag”-之旅"><a href="#第十二章：Git-中的-“Tag”-之旅" class="headerlink" title="第十二章：Git 中的 “Tag” 之旅"></a><strong>第十二章：Git 中的 “Tag” 之旅</strong></h4><p>随着项目的不断进展，小李和团队的开发进度也越来越顺利。为了标记项目中的一些关键版本，项目经理提出了一个新的要求：“我们需要为每个阶段的发布版本创建一个 <code>tag</code>，便于后续的版本管理。”</p><p>“<code>tag</code>，我之前只听说过，但是不太明白具体怎么用。” 小李略显困惑。</p><p>“没问题！” 项目经理一边解释一边操作，“<code>tag</code> 就是给某个特定的提交添加一个标签。它通常用来标记版本号，例如 v1.0、v1.1 等。你可以通过 <code>git tag</code> 命令为某个提交打标签。”</p><p>小李立刻打开了终端，输入了如下命令，为当前版本打上了标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>他通过 <code>git tag</code> 命令查看了所有的标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>“<code>tag</code> 是不可变的，它就像是一个时间戳，标记了某个关键时刻的版本。” 项目经理接着说，“如果以后想要回到某个版本，可以通过 <code>git checkout</code> 切换到这个标签。”</p><p>小李按照提示，通过 <code>git checkout</code> 轻松地切换到标记为 <code>v1.0</code> 的版本，查看了之前提交的代码，并发现 <code>tag</code> 真的非常方便，帮助他回溯项目的重要节点。</p><p>每当开发到一个新阶段或发布一个新版本时，小李都习惯性地为当前版本添加一个 <code>tag</code>，以便将来能够快速回顾项目的重要里程碑。</p><h4 id="第十三章：Git-在-“临时”-工作中的灵活运用"><a href="#第十三章：Git-在-“临时”-工作中的灵活运用" class="headerlink" title="第十三章：Git 在 “临时” 工作中的灵活运用"></a><strong>第十三章：Git 在 “临时” 工作中的灵活运用</strong></h4><p>有一天，小李接到一个紧急任务，需要修复生产环境中的一个 bug。由于 bug 可能影响整个系统的稳定性，他必须马上开始处理，但又不想打乱当前正在开发的其他功能。</p><p>“小王，我在本地修改的功能还没有完成，怎么办才能保证现在的修改不会丢失？” 小李有些焦急。</p><p>小王走过来，笑着告诉小李：“你可以用 <code>git stash</code> 把当前修改暂时存起来，等你解决完 bug 再恢复。这样就能保证你现在的工作不会丢失。”</p><p>小李恍然大悟：“哦，原来可以这么灵活处理！”</p><p>于是，他输入了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>Git 会暂时保存小李当前的修改，并将工作目录恢复到干净状态。他迅速切换到修复 bug 的任务中，解决了线上问题。当任务完成后，他输入 <code>git stash apply</code> 恢复了之前未完成的功能开发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>“小王，你看，修改恢复了！不管处理什么任务，Git 总能让我保持高效！”小李激动地说。</p><p>小王笑着点点头：“是的，Git 不仅帮助我们管理版本，还能在繁忙的开发过程中高效地切换任务。Git 的 <code>stash</code> 让你随时可以保存当前进度，恢复工作，不会有任何遗漏。”</p><h4 id="第十四章：Git-Revert——从失败中学习"><a href="#第十四章：Git-Revert——从失败中学习" class="headerlink" title="第十四章：Git Revert——从失败中学习"></a><strong>第十四章：Git Revert——从失败中学习</strong></h4><p>有一次，小李在开发过程中进行了一个重大的功能更新，然而在提交后，他很快发现这个功能并没有按预期工作，甚至还引发了其他问题。为了修复这个问题，他需要撤回这次提交。</p><p>“小王，我不小心提交了一个有问题的功能，这个提交需要撤回，怎么操作？” 小李有些焦急地问道。</p><p>小王没有惊讶，而是轻松地告诉小李：“你可以使用 <code>git revert</code> 来撤回指定的提交，它会创建一个新的提交来撤销之前的更改，而不会影响历史。”</p><p>小李跟着小王的步骤输入了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><p>Git 创建了一个新的提交，撤销了原先的修改。当他查看提交历史时，发现撤销操作被正确记录了，而原来的错误提交没有影响到后续的工作。</p><p>“原来，撤销错误提交也能这么优雅地操作。” 小李松了口气。</p><p>“Git 的 <code>revert</code> 命令让你可以安全地撤回更改，并在代码历史中留下清晰的记录。” 小王总结道。</p><h4 id="第十五章：Git-中的-“Fork”-和-“Pull-Request”"><a href="#第十五章：Git-中的-“Fork”-和-“Pull-Request”" class="headerlink" title="第十五章：Git 中的 “Fork” 和 “Pull Request”"></a><strong>第十五章：Git 中的 “Fork” 和 “Pull Request”</strong></h4><p>随着项目越来越庞大，团队成员的增多，开发方式也发生了变化。为了更好地管理开发流程，项目经理决定采用 GitHub 的 <code>Fork</code> 和 <code>Pull Request</code> 工作流，以便团队成员能在自己的分支上开发功能，并通过 <code>Pull Request</code> 将修改提交到主仓库。</p><p>“小李，今天我给你分配了一个任务，你需要在 GitHub 上对项目进行一些优化。你可以直接 Fork 这个仓库，然后在自己的仓库中开发。”项目经理说道。</p><p>“好的，<code>Fork</code> 是什么意思？”小李有些疑惑。</p><p>“<code>Fork</code> 就是将原始仓库的完整副本复制到你的 GitHub 账户下，之后你就可以在自己的副本上进行开发了。开发完成后，提交一个 <code>Pull Request</code>，把你的修改合并到主仓库里。” 项目经理耐心解释道。</p><p>“明白了！那我就去 Fork 一下。” 小李立刻在 GitHub 上点击了仓库页面的 <code>Fork</code> 按钮，将仓库复制到了自己的 GitHub 账户中。</p><p>接着，小李通过 <code>git clone</code> 克隆了自己的仓库到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/your-username/project-repo.git</span><br></pre></td></tr></table></figure><p>然后，他在自己的仓库中开始进行代码的修改。修改完成后，他通过 <code>git push</code> 将自己的更改推送到了自己的 GitHub 仓库，并创建了一个 <code>Pull Request</code> 请求将更改合并到主仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-optimization</span><br></pre></td></tr></table></figure><p>小李完成了 <code>Pull Request</code> 后，项目经理和其他团队成员开始查看并审查他的代码。经过几轮讨论和修改，最终小李的优化功能被成功合并到主仓库。</p><p>通过这种工作流，小李意识到，<code>Fork</code> 和 <code>Pull Request</code> 提供了一种高效的协作模式，开发者可以在独立的仓库中进行开发，不会影响主仓库的稳定性，同时也能保持代码的清晰和有序。</p><h4 id="第十六章：Git-的持久化——“GitHub-Actions”-帮我自动化部署"><a href="#第十六章：Git-的持久化——“GitHub-Actions”-帮我自动化部署" class="headerlink" title="第十六章：Git 的持久化——“GitHub Actions” 帮我自动化部署"></a><strong>第十六章：Git 的持久化——“GitHub Actions” 帮我自动化部署</strong></h4><p>随着项目的需求变得越来越复杂，小李和团队开始考虑如何将代码部署过程自动化。为了减少人工操作，提高效率，小李提议使用 GitHub 的 CI&#x2F;CD 功能——GitHub Actions。</p><p>“小王，我们可以用 GitHub Actions 来实现自动化部署吗？” 小李询问道。</p><p>“当然可以！GitHub Actions 是 GitHub 提供的 CI&#x2F;CD 服务，能够在你每次推送代码时自动触发一系列动作，比如编译、测试、部署等。” 小王一边讲解，一边打开了 GitHub 仓库的设置页面。</p><p>小李兴奋地学习着如何配置 GitHub Actions。他创建了一个新的 <code>.yml</code> 配置文件，定义了自动化的流程。每次有新的代码推送到主分支时，GitHub Actions 会自动执行一系列操作，首先进行单元测试，然后编译代码，最后自动将更新部署到生产环境。</p><p>小李的配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI/CD</span> <span class="string">Pipeline</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;14&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">tests</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">production</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>这个配置文件定义了当代码推送到 <code>main</code> 分支时，GitHub Actions 会自动进行代码的检查、依赖安装、测试和部署过程。小李将这个文件推送到 GitHub 仓库中后，团队中的每个成员都能在代码推送后享受到自动化部署的便利。</p><p>不久之后，当小李提交代码并推送到 GitHub 上时，他看到 GitHub Actions 自动触发了部署流程，并成功将代码部署到生产环境。每次提交后，他不再需要手动执行部署操作，GitHub Actions 自动为他完成了这一切。</p><p>“真是太棒了！这下我们可以更专注于开发，不用再浪费时间在部署上了。” 小李高兴地对小王说。</p><p>小王点头道：“是的，自动化部署让我们可以更快速、更高效地推送代码，也减少了人为错误。”</p><h4 id="第十七章：Git-Submodule——为项目添加依赖库"><a href="#第十七章：Git-Submodule——为项目添加依赖库" class="headerlink" title="第十七章：Git Submodule——为项目添加依赖库"></a><strong>第十七章：Git Submodule——为项目添加依赖库</strong></h4><p>随着项目的扩展，团队决定将一些通用的库或模块独立出来，作为子模块来进行管理。这些子模块将在多个项目中复用，减少了重复代码的编写。</p><p>“小李，我需要你帮助把我们当前的公共库添加为 Git 子模块，这样其他项目也可以引用这个库。” 项目经理安排了一个新任务。</p><p>“好的，<code>git submodule</code> 是怎么操作的？” 小李询问。</p><p>“<code>git submodule</code> 是 Git 提供的一个工具，它允许你将一个 Git 仓库嵌套在另一个 Git 仓库中。你可以在主项目中添加其他的 Git 仓库作为子模块，通过子模块来管理依赖。” 项目经理解释道。</p><p>小李按照项目经理的要求，输入了以下命令，将公共库添加为子模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/example/public-library.git libs/public-library</span><br></pre></td></tr></table></figure><p>通过这个命令，Git 将公共库克隆到主项目中的 <code>libs/public-library</code> 目录，并将其添加为子模块。小李继续执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>这样，子模块的所有内容都成功同步到本地。当其他团队成员需要使用这个公共库时，他们只需要在主仓库中执行相同的 <code>git submodule</code> 命令来同步子模块。</p><p>“小李，感谢你的帮助！以后其他项目也能通过这个子模块共享公共库了，极大减少了重复开发的时间。” 项目经理赞扬道。</p><p>小李点点头，意识到 Git 的 <code>submodule</code> 功能极大地提升了团队的开发效率，让依赖库的管理变得更简单、更灵活。</p><h4 id="第十八章：Git-的高效工具——“Git-Cherry-pick”"><a href="#第十八章：Git-的高效工具——“Git-Cherry-pick”" class="headerlink" title="第十八章：Git 的高效工具——“Git Cherry-pick”"></a><strong>第十八章：Git 的高效工具——“Git Cherry-pick”</strong></h4><p>小李在团队开发的过程中，逐渐接触到了更多的 Git 高级操作。随着项目逐渐向前推进，他发现有时需要从一个分支中挑选特定的提交，而不是直接合并整个分支。比如，有时他只想把某个特定的功能或者修复应用到当前工作中，而不希望将整个分支的其他修改都合并过来。</p><p>“小王，有没有什么方法能让我只选取某个提交而不是合并整个分支？”小李问道。</p><p>“当然有，”小王笑着说道，“Git 有一个非常有用的命令，叫做 <code>git cherry-pick</code>，它可以让你从另一个分支上挑选特定的提交，并将该提交应用到当前分支。”</p><p>小李顿时豁然开朗：“那如果我想把某个功能从 <code>feature</code> 分支中拿到当前的 <code>main</code> 分支上，该怎么操作？”</p><p>“你只需要找到那个提交的哈希值，然后用 <code>git cherry-pick</code> 命令把它应用到你的当前分支。”小王答道。</p><p>于是，小李开始操作：</p><ol><li><p><strong>首先，他通过 <code>git log</code> 查找 <code>feature</code> 分支中的那个提交的哈希值</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log feature</span><br></pre></td></tr></table></figure></li><li><p><strong>然后，他切换到 <code>main</code> 分支</strong>，准备将提交引入当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure></li><li><p><strong>接着，使用 <code>git cherry-pick</code> 来选择并应用那个提交</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure></li></ol><p>当命令执行后，Git 自动将那个提交的更改应用到了 <code>main</code> 分支上，而不需要合并整个 <code>feature</code> 分支。小李检查了代码，确认应用成功后，顺利地将新功能整合到当前分支。</p><p>“小王，真是太棒了！这个命令太实用了，以后再也不用为合并多余的代码而烦恼了！”小李高兴地说道。</p><p>小王点头笑道：“对，<code>git cherry-pick</code> 就是为了解决这个问题，它让你可以选择性地引入更改，避免不必要的合并。”</p><p>小李开始在日常开发中频繁使用 <code>git cherry-pick</code>，每当他需要从其他分支挑选特定提交时，这个命令都成为了他的得力助手。</p><h4 id="第十九章：Git-与团队协作中的高效沟通"><a href="#第十九章：Git-与团队协作中的高效沟通" class="headerlink" title="第十九章：Git 与团队协作中的高效沟通"></a><strong>第十九章：Git 与团队协作中的高效沟通</strong></h4><p>在一次代码审查的过程中，小李和团队成员遇到了一些小小的矛盾。由于对某个功能实现的理解不同，大家对如何修改代码意见不合。虽然问题本身并不大，但由于缺乏清晰的沟通，导致开发的进展有些停滞。</p><p>“小李，你能给我们解释一下你这次修改的思路吗？”项目经理耐心地询问。</p><p>小李站在桌前，深吸一口气，决定用更清晰的方式来表达自己的想法。他打开了 Git 提交记录，逐一展示了自己的修改和思路。</p><p>“我在这里用 <code>git commit --amend</code> 修改了之前的提交，因为在初始提交时，我没有充分考虑到性能问题。通过这次修改，我优化了这一部分。”小李一边说，一边展示了代码改动的细节。</p><p>项目经理点点头：“明白了，这样修改的确能够提升性能。但是，我们最好在团队中进行一些小范围的讨论，再决定如何优化。”</p><p>小李决定更加注重团队的沟通，他理解到 Git 提交的详细记录和清晰的提交信息可以极大地帮助团队成员理解每个开发者的修改意图。在随后的开发过程中，他在每次提交时，都更加注重编写简洁且易懂的提交信息。</p><p>“小李，你这次提交信息写得很好，大家都能清楚知道你的修改意图。”项目经理称赞道。</p><p>这次经验让小李意识到，Git 不仅是一个版本控制工具，它还成为了团队成员之间沟通的桥梁。通过清晰的提交记录和及时的 <code>Pull Request</code>，每个开发者都能了解其他人的工作，从而更好地进行协作。</p><h4 id="第二十章：Git-Tag-的应用——版本管理的好帮手"><a href="#第二十章：Git-Tag-的应用——版本管理的好帮手" class="headerlink" title="第二十章：Git Tag 的应用——版本管理的好帮手"></a><strong>第二十章：Git Tag 的应用——版本管理的好帮手</strong></h4><p>随着项目开发的深入，版本发布的节奏也逐渐加快。小李开始频繁接触到版本管理的任务。每当团队开发出一个新功能并完成测试时，他们就会创建一个版本发布，并用 Git 的 <code>tag</code> 来标记发布的版本。</p><p>“小李，接下来我们需要为即将发布的版本打上标签。” 项目经理走过来，指着屏幕说道，“你可以使用 <code>git tag</code> 来为我们当前的版本创建一个标签，并标记一个明确的版本号。”</p><p>“我明白了，标签就像是一个历史的快照，可以帮助我们标记每一个发布版本。” 小李回答道。</p><p>于是，小李在完成最后的代码修改后，为当前的提交打上了一个标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>然后，他通过 <code>git push</code> 推送了标签到远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure><p>项目经理看到远程仓库成功更新了标签后，表示满意：“很好，<code>tag</code> 可以让我们轻松标记每次发布的版本，方便后续的维护和版本回溯。”</p><p>小李意识到，Git 的 <code>tag</code> 功能不仅能够帮助团队在版本发布时更加清晰地管理项目，还能在遇到回滚或版本回退时快速恢复到特定的版本。随着团队开发的推进，<code>tag</code> 成为了团队工作中不可缺少的工具之一。</p><h4 id="第二十一章：Git-工作流中的“Branch”与“Merge”"><a href="#第二十一章：Git-工作流中的“Branch”与“Merge”" class="headerlink" title="第二十一章：Git 工作流中的“Branch”与“Merge”"></a><strong>第二十一章：Git 工作流中的“Branch”与“Merge”</strong></h4><p>随着小李逐渐掌握了 Git 的基础和高级操作，团队中的工作流程也开始更加成熟。在一次团队会议上，项目经理提议引入一种新的 Git 工作流，以便更高效地管理开发和部署过程。</p><p>“小李，团队正在采用 Git 的 <code>feature branch</code> 工作流，我们建议每个开发者在开发新功能时，都创建一个新的分支，开发完成后再合并回主分支。”项目经理说道。</p><p>“这样可以避免多人同时修改同一代码文件时产生冲突吗？”小李问道。</p><p>“没错，”项目经理解释道，“通过使用 <code>feature branch</code>，每个开发者都可以在独立的分支上进行开发，确保主分支保持稳定。只有在开发完成后，才能通过 <code>git merge</code> 或者 <code>git pull request</code> 合并回主分支。”</p><p>小李听后对这种工作流产生了浓厚兴趣。他立刻实践了这个流程。在开发新功能时，他从 <code>main</code> 分支创建了一个新的分支，并在分支上进行修改。当功能开发完成后，他执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge feature-new-feature</span><br></pre></td></tr></table></figure><p>通过这种方式，小李能够确保每个功能都能在独立的环境中开发，不会影响其他团队成员的工作。而且，<code>git merge</code> 能够帮助他将所有更改平滑地合并到主分支，确保代码的稳定性。</p><h4 id="Git，开发者的最佳伙伴"><a href="#Git，开发者的最佳伙伴" class="headerlink" title="Git，开发者的最佳伙伴**"></a>Git，开发者的最佳伙伴**</h4><p>随着时间的推移，小李不断地在实践中熟练掌握 Git 的各种技巧和工作流，他不仅能够高效地管理代码和版本，还能帮助团队提高开发效率。Git 成为了他工作中不可或缺的伙伴，见证了他从初学者到专业开发者的成长。</p><p>每当遇到问题或新的挑战时，小李总能依赖 Git 解决问题。他逐渐明白，Git 不仅仅是一个工具，它更像是一位教练，帮助开发者从错误中学习，从实践中进步。</p><p>未来的路还很长，而 Git 将继续陪伴小李，助力他在开发的世界中越走越远。在这个信息化飞速发展的时代，Git 让团队协作变得更加高效，代码管理变得更加清晰，开发者的每一步成长，都将在 Git 的世界中留下深深的印记。</p><h4 id="第二十二章：Git-进阶——掌握-git-reset-和-git-reflog"><a href="#第二十二章：Git-进阶——掌握-git-reset-和-git-reflog" class="headerlink" title="第二十二章：Git 进阶——掌握 git reset 和 git reflog"></a><strong>第二十二章：Git 进阶——掌握 <code>git reset</code> 和 <code>git reflog</code></strong></h4><p>随着开发项目的不断发展，小李逐渐遇到了一些复杂的情况。有时候，他在提交后发现代码存在问题，或者做了不必要的操作，想要撤回。对于这种情况，<code>git reset</code> 命令成为了他解决问题的利器。</p><p>一天，小李正在开发一个新功能，突然意识到自己在提交时选择了错误的文件进行修改，造成了不必要的代码变动。他想要撤回这次提交，怎么做呢？</p><p>“小王，我不小心提交了错误的代码，能不能撤回？” 小李焦急地问道。</p><p>小王走过来，微笑着解释道：“你可以使用 <code>git reset</code> 来撤回最近的提交。<code>git reset</code> 允许你恢复到某个特定的提交状态，你可以选择是保留本地修改，还是完全丢弃。”</p><p>“那如何使用呢？”小李问道。</p><p>“你可以通过 <code>git reset --soft HEAD~1</code> 撤销最近一次提交，但保留你的工作区更改；或者使用 <code>git reset --hard HEAD~1</code> 完全撤销提交，并且丢弃所有更改。” 小王继续说道。</p><p>小李决定使用 <code>git reset --soft</code> 来撤回错误的提交并保留工作目录中的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>执行完命令后，Git 将最近一次提交撤销，并把修改恢复到暂存区。这时，小李可以继续修改代码并重新提交。</p><p>“小王，真是太方便了！<code>git reset</code> 让我能够灵活控制我的代码，避免了不必要的错误提交。”</p><p>“是的，<code>git reset</code> 是一个非常强大的命令，但要小心使用，尤其是 <code>--hard</code> 参数，使用不当可能会丢失数据。” 小王提醒道。</p><p>不仅如此，小李还学会了使用 <code>git reflog</code> 查看历史操作的记录。当他不小心做错操作时，<code>git reflog</code> 成为了解决问题的救命稻草。</p><p>“<code>git reflog</code> 是一个很有用的工具，它记录了你所有的 HEAD 操作历史，即便你执行了 <code>git reset</code> 或者其他改变了历史的操作，它也能帮你找回丢失的记录。” 小王向小李展示了 <code>git reflog</code> 的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>小李通过 <code>git reflog</code> 快速找到了丢失的提交，并通过 <code>git reset</code> 恢复了之前的状态。这让他更加有信心在复杂的开发任务中使用 Git 来管理版本和操作历史。</p><h4 id="第二十三章：Git-在代码审查中的优势"><a href="#第二十三章：Git-在代码审查中的优势" class="headerlink" title="第二十三章：Git 在代码审查中的优势"></a><strong>第二十三章：Git 在代码审查中的优势</strong></h4><p>随着项目的逐渐深入，团队的代码审查变得尤为重要。小李不再是唯一负责提交和修改代码的人，团队中的每个成员都在贡献自己的力量。而 Git 在代码审查中的作用，也变得愈发突出。</p><p>“小李，今天我们来做代码审查，你的这段代码有一些地方需要调整。” 项目经理提醒道。</p><p>“好的，项目经理，能不能给我一些反馈？”小李走到项目经理的办公桌旁。</p><p>项目经理通过 Git 提交记录查看了小李的代码，指出了其中的一些问题。通过 <code>git diff</code> 命令，他能清楚地看到小李在提交时修改了哪些部分。</p><p>“小李，你在提交时改变了这个函数的实现逻辑。我们能不能保留原有逻辑并优化一下性能？”项目经理问道。</p><p>小李立刻打开终端，执行 <code>git diff</code> 查看具体的代码差异，确认了项目经理的建议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~1</span><br></pre></td></tr></table></figure><p>“确实是这样。谢谢你指出这个问题，我会按照建议进行修改。”小李认真地说道。</p><p>通过 <code>git diff</code>，小李能够迅速查看每次提交所带来的代码差异，确保每次修改都能符合团队的要求。而且，Git 也让代码审查变得更加高效，团队成员可以轻松查看每个提交的改动内容，避免了沟通上的误解。</p><p>项目经理总结道：“Git 在团队协作中的优势非常明显，代码审查时，我们能直接通过提交记录看到每个开发者的修改，而且能随时回溯历史，查看每个修改的细节。”</p><p>小李深刻认识到，Git 提供的强大工具不仅能帮助他高效管理代码，还能在团队合作中提升代码审查的效率，确保每个成员的代码质量。</p><h4 id="第二十四章：Git-和持续集成（CI）结合"><a href="#第二十四章：Git-和持续集成（CI）结合" class="headerlink" title="第二十四章：Git 和持续集成（CI）结合"></a><strong>第二十四章：Git 和持续集成（CI）结合</strong></h4><p>随着项目的规模不断扩大，团队决定引入持续集成（CI）工具，以便更好地自动化测试和部署流程。小李负责配置 Git 和 CI 工具的集成，让团队的代码自动化构建、测试和部署。</p><p>“小李，我们要使用 Jenkins 来进行自动化构建和测试，能帮我把 Git 和 Jenkins 集成起来吗？”项目经理问道。</p><p>“没问题，项目经理，我来配置。” 小李点头答应。</p><p>首先，他在 GitHub 仓库中配置了 Webhook，当代码推送到 GitHub 仓库时，Webhook 会自动触发 Jenkins 构建任务。接着，小李在 Jenkins 中配置了一个构建任务，并在构建脚本中加入了自动拉取 Git 仓库代码的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/your-username/project-repo.git</span><br></pre></td></tr></table></figure><p>此外，Jenkins 还配置了自动化测试步骤，每当代码推送到 Git 仓库时，Jenkins 会自动拉取代码，执行单元测试，确保没有新的 bug 被引入。</p><p>通过这种方式，小李实现了 Git 与 Jenkins 的无缝集成，让每次代码推送后都能自动触发构建和测试流程，极大提高了开发效率。</p><p>“小李，你的配置太棒了！现在我们每次推送代码后，Jenkins 会自动进行构建和测试，这样就能第一时间发现问题，避免了手动操作的麻烦。”项目经理感慨道。</p><p>小李也深刻感受到，Git 不仅是团队协作的工具，还能与 CI 工具结合，提升整个开发流程的自动化和高效性。</p><h4 id="第二十五章：Git-的深层次运用——多仓库管理"><a href="#第二十五章：Git-的深层次运用——多仓库管理" class="headerlink" title="第二十五章：Git 的深层次运用——多仓库管理"></a><strong>第二十五章：Git 的深层次运用——多仓库管理</strong></h4><p>随着小李在项目中不断积累经验，他开始接触到更加复杂的 Git 使用场景。例如，团队中的多个子项目之间需要进行协调开发，这就需要管理多个仓库。为了有效管理这些子项目，小李学习了如何使用 Git 管理多个仓库的代码。</p><p>“小李，我们有多个子项目需要同步更新，能不能管理多个 Git 仓库？”项目经理问道。</p><p>小李思索了一下，答道：“我们可以使用 Git 的 <code>submodule</code> 功能来管理这些子项目，或者通过 <code>git remote</code> 将多个远程仓库关联到一个本地仓库。”</p><p>他通过 <code>git remote</code> 添加了其他项目的远程仓库，使得多个仓库能够通过一个 Git 仓库进行管理。这种方法让小李能够方便地同步多个子项目的代码，并确保所有仓库的代码始终保持一致。</p><p>“小李，这种管理方式非常有效，能让我们轻松地同步多个仓库的代码。”项目经理满意地说道。</p><h4 id="第二十六章：Git-在应对大规模项目中的应用"><a href="#第二十六章：Git-在应对大规模项目中的应用" class="headerlink" title="第二十六章：Git 在应对大规模项目中的应用"></a><strong>第二十六章：Git 在应对大规模项目中的应用</strong></h4><p>随着团队逐渐发展，项目的规模也在不断扩大，甚至开始涉及多个跨团队的合作。小李渐渐意识到，在这样的大规模项目中，Git 不再是一个单纯的版本控制工具，而是整个开发流程的核心之一。为了解决不同团队成员之间的协作问题，团队决定采用 Git 作为核心工具来协调各项工作。</p><p>“小李，我们的项目越来越复杂，多个团队的协作需求也越来越高，如何更好地协调和管理多个模块之间的关系呢？” 项目经理问道。</p><p>“我建议我们将每个模块或子系统作为独立的 Git 仓库，采用 Git 的 Submodule 或者 Subtree 功能来管理不同模块之间的依赖。” 小李回答道，“这样可以让每个团队独立工作，同时通过 Git 的功能保持各个模块之间的同步。”</p><p>“Submodule 和 Subtree？能不能再详细说一下？” 项目经理有些疑惑。</p><p>“好的，” 小李微笑着解释，“<code>git submodule</code> 用于将一个 Git 仓库嵌套到另一个仓库中，适合在一个大的项目中引用一些公共的库或者子项目。它能够让我们独立管理每个模块，并通过主仓库来同步这些模块。<code>git subtree</code> 则是一个更强大的工具，允许我们将一个项目的子目录作为另一个仓库的历史部分来管理，方便合并和共享代码。”</p><p>项目经理点点头，表示理解：“那我们可以先尝试使用 <code>git submodule</code>，看看能不能有效管理各个子模块。”</p><p>于是，小李开始在主项目中引入了 Git 子模块，将各个子模块独立管理，每个团队都可以独立开发自己的部分，通过 Git Submodule 来同步。每当有更新时，团队成员只需使用 <code>git submodule update</code> 命令来同步各自的子模块。</p><p>“小李，这样的做法确实很有效。每个团队都可以专注于自己负责的模块，且能通过 Git 保证模块间的同步。” 项目经理满意地说道。</p><p>随着项目的不断发展，团队的协作也变得更加高效。Git Submodule 成为了管理大规模项目中多个模块之间关系的关键工具，使得每个团队能够更加高效地独立开发，避免了冲突和重复工作。</p><h4 id="第二十七章：Git-和-DevOps-的融合"><a href="#第二十七章：Git-和-DevOps-的融合" class="headerlink" title="第二十七章：Git 和 DevOps 的融合"></a><strong>第二十七章：Git 和 DevOps 的融合</strong></h4><p>随着团队在多个项目中的逐渐积累，团队的开发模式也逐渐从传统的开发方式向 DevOps 转型。持续集成（CI）、持续交付（CD）和自动化测试成为了团队开发的核心需求，而 Git 作为版本控制工具在 DevOps 中的作用变得尤为重要。</p><p>“小李，接下来我们要将开发流程进行 DevOps 化，我们需要一个自动化的 CI&#x2F;CD 流程来提高开发效率。” 项目经理指示道，“你能帮忙把 Git 与我们的 CI 工具结合起来吗？”</p><p>“没问题，我来配置。” 小李迅速答应道。</p><p>小李首先配置了 Git 与 Jenkins 的集成。每当团队成员向 Git 仓库推送代码时，Jenkins 会自动检测到提交，触发自动化构建流程，执行单元测试，确保每次提交的代码都能够通过测试。接着，他配置了持续交付流程，每当通过测试后，Jenkins 会将代码自动部署到开发环境进行进一步的验证。</p><p>为了进一步优化流程，小李还在 GitHub 上配置了 Webhooks，将每次 Git 提交推送事件通知给 Jenkins，确保流程的自动化和即时性。</p><p>“通过这种方式，我们的代码每次提交后都会自动构建和测试，减少了手动操作的时间和错误。” 小李解释道，“这种 DevOps 思维方式不仅提升了开发效率，也保证了代码的质量。”</p><p>项目经理看着自动化部署流程的顺利运行，表示满意：“非常好，Git 与 DevOps 结合，自动化构建和测试提高了我们的交付效率，减少了人工操作的错误。”</p><h4 id="第二十八章：Git-在开源项目中的协作模式"><a href="#第二十八章：Git-在开源项目中的协作模式" class="headerlink" title="第二十八章：Git 在开源项目中的协作模式"></a><strong>第二十八章：Git 在开源项目中的协作模式</strong></h4><p>随着小李在公司中积累的经验越来越丰富，他开始参加一些开源项目的开发。开源项目通常有很多开发者参与，其中涉及到不同的工作流和版本管理方式。在参与开源项目时，Git 的使用成为了开发中的一个重要部分，尤其是如何高效地与其他开发者协作。</p><p>“小李，最近我在 GitHub 上看到一个非常有意思的开源项目，我们也可以参与其中贡献代码。” 小王激动地说。</p><p>“开源项目？那我们要如何参与其中呢？”小李问道。</p><p>“我们可以通过 Fork 该项目，并在我们的个人 GitHub 仓库中进行开发。当我们完成自己的功能后，通过 <code>Pull Request</code> 向原项目提交我们的更改。” 小王解释道。</p><p>小李立刻开始了解开源项目的工作流程。首先，他在 GitHub 上 Fork 了项目，然后将其克隆到本地。接着，他在本地进行了修改，并在完成之后推送到个人仓库。</p><p>然后，他创建了一个 <code>Pull Request</code>，请求将自己的更改合并到原项目中。通过这种方式，原项目的维护者可以查看他的修改并决定是否接受他的更改。</p><p>“小李，<code>Fork</code> 和 <code>Pull Request</code> 真是开源项目的核心工作流。它能让我们独立开发，并通过 PR 与原项目进行贡献。”小王感慨道。</p><p>通过参与开源项目，小李不仅进一步提升了自己的开发技能，还学会了如何在全球范围内与其他开发者协作。Git 的强大功能使得开源项目的开发变得有序而高效，团队成员之间能够通过清晰的提交记录和 PR 进行有效沟通，确保了代码质量和开发进度。</p><h4 id="第二十九章：Git-与-Agile-开发的结合"><a href="#第二十九章：Git-与-Agile-开发的结合" class="headerlink" title="第二十九章：Git 与 Agile 开发的结合"></a><strong>第二十九章：Git 与 Agile 开发的结合</strong></h4><p>随着团队的进一步发展，团队决定采用敏捷开发（Agile）方法来提高开发效率和灵活性。敏捷开发要求团队快速响应需求变化，并在较短的时间内交付高质量的代码。而 Git 成为了实现这一目标的关键工具之一。</p><p>“小李，我们决定引入敏捷开发，采用迭代的方式进行功能开发。每个 Sprint 结束后，我们需要提交一个可交付的版本。” 项目经理说道，“你认为我们如何利用 Git 来支持敏捷开发？”</p><p>“我认为，Git 能够非常好地支持敏捷开发。” 小李答道，“通过创建 <code>feature</code> 分支，我们能够快速开发出独立的功能。在每个 Sprint 结束时，我们可以通过 <code>git merge</code> 或者 <code>git pull request</code> 将功能合并到主分支，从而保证代码的稳定性。”</p><p>“那我们如何处理版本发布呢？” 项目经理问道。</p><p>“Git 的 <code>tag</code> 功能非常适合版本管理。在每次功能开发完成后，我们可以通过 <code>git tag</code> 打上版本标签，标记每个发布的里程碑。” 小李解释道。</p><p>通过使用 Git 支持敏捷开发，团队能够更快速地进行功能开发和迭代交付，同时保持代码的清晰和可维护性。每次迭代结束后，Git 的分支管理和版本标签都确保了每个功能都能够按时交付，且不会影响其他功能的开发。</p><p>项目经理表示赞赏：“Git 的分支管理和 <code>tag</code> 功能完美支持了我们敏捷开发的需求，让我们能够更加高效地进行迭代和发布。”</p><h4 id="Git-——-开发者的长久伙伴"><a href="#Git-——-开发者的长久伙伴" class="headerlink" title="Git —— 开发者的长久伙伴**"></a>Git —— 开发者的长久伙伴**</h4><p>随着时间的推移，小李不仅在公司中积累了丰富的 Git 使用经验，也在开源项目和敏捷开发中不断提升自己。Git 成为了他日常开发工作中不可或缺的工具，帮助他在团队中与其他成员高效协作，推动项目顺利进行。</p><p>Git 不再只是一个简单的版本控制工具，它已经深入到整个开发流程中，成为小李的长久伙伴。无论是日常的功能开发，还是复杂的多团队协作，Git 都能够帮助开发者高效管理代码，提升开发效率。</p><p>未来的道路依然充满挑战，但小李相信，只要有 Git 作为工具，他将能够不断突破自己，迎接更大的成功。在这个快速发展的技术时代，Git 将继续陪伴小李，在他编程的旅程中不断迈向新的高度。</p><h4 id="第三十章：Git-在大规模团队中的管理实践"><a href="#第三十章：Git-在大规模团队中的管理实践" class="headerlink" title="第三十章：Git 在大规模团队中的管理实践"></a><strong>第三十章：Git 在大规模团队中的管理实践</strong></h4><p>随着公司项目的规模日益壮大，团队成员也越来越多。小李和其他团队成员发现，Git 在大规模团队中的协作变得更加复杂。在一个多团队、跨部门的项目中，如何有效地管理和合并不同的代码变得尤为重要。</p><p>“小李，团队的规模扩大后，我们发现管理多个开发分支变得越来越困难，很多人都在不同的分支上并行开发，合并冲突也变得更频繁了。你觉得我们怎么做才能更高效地管理代码？” 项目经理问道。</p><p>小李开始思考，发现随着团队规模的扩大，代码管理面临的挑战确实在增加。他想到了一些改进方法：“我们可以采用 Git Flow 工作流来更好地管理分支。Git Flow 是一个标准化的分支管理模式，它通过规定各个分支的功能来减少冲突，确保每个分支的职责明确。”</p><p>“Git Flow？听起来很有用。你能详细解释一下吗？” 项目经理有些好奇。</p><p>小李耐心地讲解道：“Git Flow 是由 Vincent Driessen 提出的分支模型，它定义了几个主要的分支角色：</p><ol><li><strong>master</strong>：主分支，保存着所有已经发布过的代码，始终保持稳定。</li><li><strong>develop</strong>：开发分支，所有新的功能都在这个分支上开发，只有当功能开发完成并经过测试后，才会合并到 <code>master</code> 分支。</li><li><strong>feature</strong>：特性分支，用来开发独立的功能模块。每个功能都会在一个单独的 <code>feature</code> 分支上开发，开发完成后合并回 <code>develop</code> 分支。</li><li><strong>release</strong>：发布分支，主要用于准备新版本的发布。当 <code>develop</code> 分支上的功能基本完成时，我们会创建一个 <code>release</code> 分支来进行最终测试和 bug 修复。</li><li><strong>hotfix</strong>：修复分支，快速修复主分支上的紧急 bug，修复完成后合并到 <code>master</code> 和 <code>develop</code>。</li></ol><p>这种工作流的优势在于，每个团队成员可以在自己的特性分支上独立开发，减少冲突。而且，<code>release</code> 和 <code>hotfix</code> 分支帮助我们在发布和修复过程中保持主分支的稳定。”</p><p>项目经理听后点点头：“这个工作流确实很有意义，它能够帮助我们更有条理地管理代码，避免过多的冲突和合并问题。”</p><p>小李随后帮助团队将 Git Flow 工作流应用到团队项目中，确保每个开发人员按照规范创建分支、提交代码，并使用 <code>git merge</code> 或 <code>git pull request</code> 合并分支。通过这种方法，团队成员之间的协作变得更加高效，而 Git Flow 也为团队提供了清晰的分支管理结构。</p><h4 id="第三十一章：Git-在多平台开发中的角色"><a href="#第三十一章：Git-在多平台开发中的角色" class="headerlink" title="第三十一章：Git 在多平台开发中的角色"></a><strong>第三十一章：Git 在多平台开发中的角色</strong></h4><p>随着团队的技术栈不断扩展，项目开始涉及多个平台的开发需求：前端使用 React，后端使用 Node.js 和 Express，移动端使用 React Native，甚至还有一些用于数据处理的 Python 脚本。每个平台的代码和环境不同，但如何确保这些平台的代码都能同步更新、管理起来却不产生冲突，成为了小李的一个新挑战。</p><p>“小李，考虑到我们开发的多个平台，如何更好地管理这些不同代码的依赖呢？” 项目经理询问道。</p><p>小李回忆起自己在过去的项目中遇到过类似的需求，顿时有了主意：“我们可以利用 Git 子模块（<code>git submodule</code>）来管理跨平台的代码库。通过将每个平台的代码作为独立的 Git 仓库，使用主仓库来统一管理这些代码，就能有效地将不同的代码库集中在一个地方，方便我们管理。”</p><p>“你是说，不同的代码库可以独立管理，然后通过主仓库来同步吗？” 项目经理问。</p><p>“是的，<code>git submodule</code> 允许我们将其他 Git 仓库嵌套在主仓库中，作为子模块来管理。每个子模块有自己的版本号，主仓库负责对子模块进行版本控制和更新。当我们需要更新子模块的代码时，只需在主仓库中同步子模块即可。” 小李解释道。</p><p>他接着为项目配置了 Git 子模块，每个平台的代码库都作为一个子模块被添加进主仓库中，使用 <code>git submodule</code> 命令来同步更新各平台的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/example/frontend-repo.git frontend</span><br><span class="line">git submodule add https://github.com/example/backend-repo.git backend</span><br><span class="line">git submodule add https://github.com/example/mobile-repo.git mobile</span><br></pre></td></tr></table></figure><p>每当更新子模块的代码时，团队成员只需要在主仓库中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --recursive --remote</span><br></pre></td></tr></table></figure><p>通过这种方式，团队能够有效管理不同平台的代码，并确保每个平台的版本都能保持同步，减少了版本冲突的发生。</p><p>“通过子模块管理多个平台的代码，团队成员可以独立开发，不同平台之间不会相互干扰。” 项目经理表示赞赏。</p><h4 id="第三十二章：Git-与-Code-Review-流程"><a href="#第三十二章：Git-与-Code-Review-流程" class="headerlink" title="第三十二章：Git 与 Code Review 流程"></a><strong>第三十二章：Git 与 Code Review 流程</strong></h4><p>随着项目的不断发展，代码质量和团队合作变得尤为重要。小李意识到，除了版本控制和代码同步，如何高效地进行代码审查（Code Review）也是团队合作中的一个关键环节。</p><p>“小李，最近我们在团队中遇到了一些代码质量问题。为了提高代码质量，我们决定加强代码审查流程。” 项目经理说。</p><p>“我明白，代码审查能帮助团队发现问题并保持一致的编码风格。我觉得 Git 可以在这方面发挥很大作用。” 小李答道。</p><p>小李向项目经理提议，通过 Git 提交记录和 GitHub 的 Pull Request 功能，团队成员可以高效地进行代码审查。每次提交新的功能或修改时，开发者都通过 <code>git push</code> 将代码推送到远程仓库，并创建一个 Pull Request，请求团队成员进行审查。</p><p>在代码审查过程中，团队成员可以在 GitHub 上查看具体的改动（<code>git diff</code>），留下评论，提出修改意见。每次修改完毕，开发者会更新 Pull Request，直到所有问题得到解决。最终，项目经理或负责人会合并代码并批准最终的提交。</p><p>“小李，这个流程非常有帮助，Git 的 Pull Request 功能能让我们更高效地进行代码审查，确保每个功能都经过了充分的讨论和审核。” 项目经理说道。</p><p>通过 Git 提供的强大功能，团队能够在代码审查中更好地协作，不仅提升了代码质量，还加强了团队之间的沟通。</p><h4 id="第三十三章：Git-在自动化和脚本化中的应用"><a href="#第三十三章：Git-在自动化和脚本化中的应用" class="headerlink" title="第三十三章：Git 在自动化和脚本化中的应用"></a><strong>第三十三章：Git 在自动化和脚本化中的应用</strong></h4><p>随着团队项目越来越复杂，小李开始接触到一个新的需求——自动化。项目中有很多重复性、繁琐的操作，比如同步子模块、打标签、发布新版本等。小李发现，手动执行这些操作既耗时又容易出错，因此他决定通过编写脚本来自动化这些任务。</p><p>“小李，我们希望能简化每次发布的过程，能不能帮忙写个自动化脚本，避免每次都要手动执行 Git 命令？” 项目经理提出了一个需求。</p><p>小李非常兴奋，因为他一直对自动化非常感兴趣。他思考了一下，决定用 Bash 脚本来实现这一功能。脚本的目标是每次新版本发布时，自动更新子模块、切换到主分支、打标签，并将代码推送到远程仓库。</p><p>他编写了如下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 更新所有子模块</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到主分支</span></span><br><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 拉取最新的代码</span></span><br><span class="line">git pull origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 打上新的版本标签</span></span><br><span class="line">VERSION=$(<span class="built_in">date</span> +<span class="string">&quot;%Y%m%d%H%M%S&quot;</span>)</span><br><span class="line">git tag -a <span class="string">&quot;v<span class="variable">$VERSION</span>&quot;</span> -m <span class="string">&quot;Release version <span class="variable">$VERSION</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 推送主分支和标签到远程</span></span><br><span class="line">git push origin main</span><br><span class="line">git push origin <span class="string">&quot;v<span class="variable">$VERSION</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Release <span class="variable">$VERSION</span> successfully created and pushed!&quot;</span></span><br></pre></td></tr></table></figure><p>这个脚本首先更新了所有子模块，确保每个模块都是最新的。然后，它会切换到 <code>main</code> 分支，拉取远程仓库的最新代码，接着生成一个基于当前时间戳的版本号，并使用 <code>git tag</code> 打上标签。最后，脚本会将 <code>main</code> 分支和新标签都推送到远程仓库。</p><p>“小李，这个自动化脚本简直太棒了！以后发布新版本时，直接执行这个脚本就行了，避免了手动操作的错误。” 项目经理大加赞赏。</p><p>小李也对这个自动化过程非常满意。通过自动化脚本，他不仅减少了繁琐的操作，还降低了人为错误的风险。这次经历让小李更加深刻地认识到，Git 不仅是版本控制工具，它也能够与自动化流程紧密结合，提升整个开发流程的效率。</p><h4 id="第三十四章：Git-与团队沟通的桥梁"><a href="#第三十四章：Git-与团队沟通的桥梁" class="headerlink" title="第三十四章：Git 与团队沟通的桥梁"></a><strong>第三十四章：Git 与团队沟通的桥梁</strong></h4><p>随着团队规模和项目复杂度的增加，沟通变得尤为重要。团队成员之间不仅要讨论功能需求，还需要清楚地了解其他成员的工作进展。小李发现，Git 提供的提交记录、分支管理、合并过程和 Pull Request，实际上都为团队沟通提供了强有力的支持。</p><p>一天，小李在查看项目的 Git 提交记录时，注意到某些提交信息比较模糊，无法准确反映开发的进度和内容。他认为，这是团队在使用 Git 时未能充分利用其沟通能力。</p><p>“小王，你觉得 Git 提交信息的重要性有多大？”小李向同事请教。</p><p>“其实提交信息是团队沟通的一个重要桥梁，它可以帮助我们了解每个功能的开发进度和思路。如果提交信息不清晰，团队成员很难理解开发者的意图。” 小王认真回答道。</p><p>“那我们能不能有一个规范，确保每个人在提交时都写清楚相关信息？”小李提议。</p><p>小王点点头：“是的，我们可以制定一些提交信息规范，比如每次提交时都写清楚这次提交的目的、所修复的 bug、改进的功能等。这样可以帮助团队成员快速理解代码的变动，提升沟通效率。”</p><p>于是，小李和团队一起讨论并制定了一份 Git 提交信息规范，要求每次提交时都必须包括以下内容：</p><ol><li><strong>简短的标题</strong>：描述这次提交的主要目的（如“修复登录功能”、“优化数据处理逻辑”）。</li><li><strong>详细的描述</strong>：具体说明这次提交修改了什么，为什么要修改，以及如何修改的。</li><li><strong>关联的 issue 或 bug</strong>：如果是修复 bug 或实现某个需求，提交信息中需要提及关联的 issue 或 bug 编号。</li></ol><p>从那以后，团队的 Git 提交记录变得更加清晰和规范，每个人在查看提交记录时都能迅速理解变更内容。Git 不再只是一个简单的工具，它成为了团队沟通的桥梁，帮助开发者更好地协作。</p><h4 id="第三十五章：Git-与远程协作的无缝结合"><a href="#第三十五章：Git-与远程协作的无缝结合" class="headerlink" title="第三十五章：Git 与远程协作的无缝结合"></a><strong>第三十五章：Git 与远程协作的无缝结合</strong></h4><p>在小李所在的公司，随着项目的扩展，团队成员开始分布在不同的地方，甚至有了远程工作模式。如何保持远程团队的协作效率，成了一个关键问题。小李深知，Git 的强大远程协作能力将在这里发挥巨大的作用。</p><p>“小李，考虑到我们团队已经是远程工作，我们需要有一个标准化的流程来管理远程仓库和分支，确保每个人都能高效协作。”项目经理提出了新的挑战。</p><p>“我们可以利用 GitHub、GitLab 或 Bitbucket 等平台的功能来实现这一点，配合 <code>git fetch</code>、<code>git pull</code>、<code>git push</code>，保证每个人的工作始终与远程仓库同步。” 小李回答道，“我们可以设置清晰的分支管理规则，例如每个功能使用独立的 <code>feature</code> 分支，合并时使用 Pull Request，并且严格要求审查代码。”</p><p>“那这样的话，团队成员都可以在自己的分支上独立工作，最后通过 Pull Request 来进行合并和代码审查，对吗？” 项目经理进一步确认。</p><p>“是的，完全正确。每个人都可以在自己的分支上工作，提交并推送到远程仓库后，其他成员可以随时拉取更新。通过 Pull Request 和代码审查，我们可以确保代码质量，避免直接推送到 <code>main</code> 分支。” 小李解释道。</p><p>为了更好地管理远程协作，小李还建议团队使用 GitHub 的团队管理功能，将每个项目的成员分成不同的权限组，确保项目代码的安全性。</p><p>通过这些措施，团队的远程协作变得越来越顺畅，开发进度也大大加快。Git 成为他们跨时区、跨地域协作的桥梁，保证了远程工作模式下的高效沟通与协作。</p><h4 id="第三十六章：Git-与知识管理的结合"><a href="#第三十六章：Git-与知识管理的结合" class="headerlink" title="第三十六章：Git 与知识管理的结合"></a><strong>第三十六章：Git 与知识管理的结合</strong></h4><p>在一次团队会议上，项目经理提到：“我们团队已经积累了大量的知识和技术文档，如何能够更好地管理这些知识，让每个新加入的成员都能快速了解项目和技术栈？”</p><p>小李听后立即想到了 Git 的优势：“我们可以将这些文档和知识管理工作与 Git 结合起来，创建一个专门的 Git 仓库，来管理项目的技术文档、架构设计以及解决方案等。”</p><p>项目经理表示认可：“这样一来，新成员可以通过 Git 仓库查看我们的文档，也能通过 Git 提交的历史记录了解每个问题的解决过程。”</p><p>小李和团队决定创建一个专门的 Git 仓库，专门用来存储项目文档、设计文档、代码规范和技术文章等。在这个仓库中，所有文档都将与代码一样进行版本控制，每个文档的更新和修改都会记录在 Git 提交历史中，方便后续查看和追溯。</p><p>通过这种方式，团队的知识管理变得更加高效，每个成员都可以随时查看、更新和修改文档，而 Git 则确保了文档的版本控制和更新记录。</p><h4 id="第三十七章：Git-在复杂环境中的应用——跨平台开发与持续集成"><a href="#第三十七章：Git-在复杂环境中的应用——跨平台开发与持续集成" class="headerlink" title="第三十七章：Git 在复杂环境中的应用——跨平台开发与持续集成"></a><strong>第三十七章：Git 在复杂环境中的应用——跨平台开发与持续集成</strong></h4><p>随着项目变得越来越复杂，小李发现开发环境的多样化带来了新的挑战。在一个典型的跨平台开发环境中，团队同时在开发前端、后端、移动应用、甚至机器学习模型等多个部分，而每个部分都有不同的技术栈和依赖。</p><p>“小李，我们的项目现在涉及多个平台，前端是 React，后端是 Node.js，移动端是 React Native，机器学习模型是用 Python 实现的。如何在这些平台之间保持一致，并且高效协作呢？” 项目经理问。</p><p>“这个问题确实不小，”小李思考了一下，“不过我想到了一种方式。我们可以利用 Git 和 Docker 来帮助管理这些平台的环境，确保每个开发者的环境一致。同时，我们可以通过 CI 工具进行自动化测试和构建，确保每个平台的代码都能顺利运行。”</p><p>他继续讲解：“首先，我们可以为每个平台创建独立的 Git 子模块，分别管理每个平台的代码库。然后，我们可以通过 Docker 为每个平台创建独立的开发环境，确保每个开发者都能在本地轻松搭建相同的开发环境。”</p><p>项目经理表示理解并表示认可：“这个思路不错，Git 的子模块能帮助我们管理各个项目，而 Docker 则能保证每个开发者的环境一致。接下来，你可以为我们实现这一方案吗？”</p><p>小李开始实施方案。他为每个平台创建了独立的 Git 子模块，将不同平台的代码库分开管理，确保每个平台的代码能独立开发且相互不干扰。接着，他为每个平台编写了 Dockerfile 文件，确保每个开发者都能通过 Docker 快速搭建一致的开发环境。</p><p>例如，前端的开发环境通过 Docker 配置了 Node.js 和相关的构建工具，而后端则使用了 Express 和数据库连接，机器学习的环境则配置了 Python 和 TensorFlow。通过 Docker 容器，开发者只需要拉取相应的容器镜像，就可以快速搭建起完全一致的开发环境。</p><p>“小李，这个方案非常棒！通过 Docker，我们能够在不同平台之间确保开发环境的一致性，Git 子模块则让我们能更好地管理不同平台的代码。” 项目经理感慨道。</p><p>小李也对这一方案非常满意。通过 Git 和 Docker 的结合，团队能够有效地管理和协作多个平台的开发，避免了环境不一致的问题。同时，自动化测试和持续集成的引入也让开发进度更加高效。</p><h4 id="第三十八章：Git-在数据库版本控制中的重要性"><a href="#第三十八章：Git-在数据库版本控制中的重要性" class="headerlink" title="第三十八章：Git 在数据库版本控制中的重要性"></a><strong>第三十八章：Git 在数据库版本控制中的重要性</strong></h4><p>随着项目的功能越来越丰富，数据库的管理也变得尤为重要。数据库结构、存储过程和数据迁移等方面的变动需要进行详细的记录和管理。小李发现，传统的数据库管理方式往往不够透明，难以追溯数据库的变动历史。于是，他提出了一个新方案：使用 Git 来管理数据库的版本控制。</p><p>“小李，我看到你最近在研究数据库版本控制的方案。你能给我们讲讲怎么将 Git 应用到数据库管理中吗？” 项目经理问。</p><p>“我想到了一个方法，就是通过将数据库的结构和迁移脚本也放入 Git 仓库中，和应用代码一起管理。” 小李回答道。</p><p>他接着解释：“我们可以把每次数据库的变动（例如表结构变更、索引创建、存储过程更新等）写成迁移脚本，并将这些脚本放入 Git 仓库中进行版本控制。每当需要修改数据库结构时，开发者只需编写迁移脚本，并将其提交到 Git 仓库。然后，通过自动化工具或者手动方式运行这些迁移脚本，数据库就能与应用代码同步更新。”</p><p>项目经理觉得这个方案非常有价值，毕竟数据库的变更往往难以管理，Git 的引入能够帮助团队更好地追踪和管理这些变动。</p><p>“小李，你可以为我们建立一个数据库迁移管理流程吗？” 项目经理问道。</p><p>小李开始构建这个方案。他创建了一个新的 Git 仓库，用于存储所有数据库的迁移脚本。每次数据库结构有变化时，开发者会编写相应的迁移脚本，提交到 Git 仓库中。迁移脚本的命名规则也被统一，以便于后续的管理和回滚。</p><p>当需要更新数据库时，开发者会使用一个数据库迁移工具（例如 Flyway 或 Liquibase）来自动应用这些脚本，确保数据库与应用代码保持一致。如果数据库出现问题，可以通过 Git 历史记录查看之前的变更，并回滚到某个历史版本。</p><p>“小李，你的这个方案太好了！数据库变更再也不需要手动记录和更新了，所有的变动都可以通过 Git 来追溯。” 项目经理激动地说道。</p><p>通过将数据库版本控制与 Git 集成，团队不仅提高了管理效率，还增加了开发过程中的透明度和可追溯性。</p><h4 id="第三十九章：Git-与团队文化的融合"><a href="#第三十九章：Git-与团队文化的融合" class="headerlink" title="第三十九章：Git 与团队文化的融合"></a><strong>第三十九章：Git 与团队文化的融合</strong></h4><p>随着项目逐渐走向成熟，小李逐渐意识到，Git 不仅仅是一个技术工具，它也在潜移默化地影响着团队的文化。在团队的协作中，Git 强调了透明度、代码的可追溯性和团队成员之间的高效沟通。</p><p>“小李，最近我注意到，团队成员在协作时越来越注重代码的清晰度和规范性，大家的合作也越来越顺畅。” 项目经理感慨道，“你觉得这与 Git 的使用有关系吗？”</p><p>小李点点头：“有很大关系。Git 强调了每个人对代码的责任和透明度。每次提交都可以清晰地查看修改内容，团队成员通过 <code>git diff</code> 和 <code>git log</code> 能够清楚地看到彼此的工作。这不仅提升了代码质量，也促进了团队成员之间的有效沟通。”</p><p>项目经理继续说：“我还发现，团队成员越来越注重提交信息的规范，大家在写提交信息时，会写得很清晰，标明修复的 bug、优化的功能以及其他细节。这种良好的习惯促进了团队的协作和项目的高效推进。”</p><p>小李微笑着回答：“是的，Git 的提交信息规范性确实对团队合作有很大影响。当每个开发者都知道自己提交的每一行代码都需要经过审查并且能被追溯时，大家会更自觉地保证代码的质量和清晰度。Git 让我们在开发过程中养成了良好的编码习惯，也提升了团队协作的效率。”</p><p>项目经理点头赞同：“Git 作为我们的核心工具，不仅帮助我们管理版本、协作开发，还帮助我们树立了良好的团队文化。我们现在的开发过程更加高效，团队也更加和谐。”</p><h4 id="第四十章：Git-与-DevSecOps-的结合"><a href="#第四十章：Git-与-DevSecOps-的结合" class="headerlink" title="第四十章：Git 与 DevSecOps 的结合"></a><strong>第四十章：Git 与 DevSecOps 的结合</strong></h4><p>随着公司项目和团队规模的扩大，小李逐渐意识到，除了版本控制和协作，Git 在保障代码安全性方面也能发挥重要作用。在项目中，团队开始引入 DevSecOps（开发、运维和安全一体化）的概念，确保代码在整个开发周期中都能遵循最佳的安全实践。</p><p>“小李，我们最近决定加强项目的安全性，将安全控制纳入到开发流程中，你觉得 Git 在这个过程中能扮演什么角色？” 项目经理问道。</p><p>小李思索了一下，回答道：“Git 在 DevSecOps 中的作用主要体现在两个方面。一方面，它能够帮助我们确保代码的安全性，通过代码审查和历史提交记录，让我们清晰地了解代码变动，确保没有恶意或不安全的代码被引入；另一方面，Git 还能够与安全工具集成，通过 CI&#x2F;CD 管道自动化地检测漏洞，保证每次代码提交都经过安全审查。”</p><p>“能举个例子吗？” 项目经理感兴趣地问道。</p><p>小李接着解释道：“举个例子，我们可以在 Git 提交时，集成一些静态代码分析工具，例如 SonarQube 或 Checkmarx，这些工具会扫描每次提交的代码，检测潜在的漏洞或安全隐患。如果发现问题，Git 会阻止代码的合并，直到问题被修复。通过这种方式，我们能够确保每个提交都符合安全标准。”</p><p>项目经理点头称赞：“这个思路很好，Git 不仅能管理版本，还能与安全工具紧密结合，自动化检查代码中的安全问题。这将大大提高我们的安全性，避免漏洞进入生产环境。”</p><p>小李开始为团队配置了与 Git 集成的安全工具。他设置了 SonarQube，确保每次代码提交时，都会自动进行静态代码分析，并通过 Git 的 hook 阻止潜在的漏洞进入主分支。通过这种方式，团队确保每次提交的代码都能符合安全标准，而不需要人工介入。</p><h4 id="第四十一章：Git-在微服务架构中的管理"><a href="#第四十一章：Git-在微服务架构中的管理" class="headerlink" title="第四十一章：Git 在微服务架构中的管理"></a><strong>第四十一章：Git 在微服务架构中的管理</strong></h4><p>随着项目架构的复杂性增加，团队决定将项目的开发模式转向微服务架构。微服务架构将应用拆分成多个独立的服务，每个服务都负责一个特定的功能模块，能够独立部署、独立开发，并且通过 API 进行互联。</p><p>“小李，随着我们逐渐采用微服务架构，如何高效地管理每个微服务的代码和依赖呢？” 项目经理问道。</p><p>“我们可以使用 Git 来管理每个微服务的代码库，确保每个微服务都能独立开发和部署。” 小李回答道，“每个微服务都可以作为一个独立的 Git 仓库来管理，这样能够保证服务之间的独立性，并且可以通过 Git 的 Submodule 或者 Subtree 来管理微服务之间的依赖。”</p><p>“小李，那微服务间如何进行版本控制和依赖管理呢？” 项目经理继续问。</p><p>“我们可以在每个微服务的 Git 仓库中使用标签（<code>tag</code>）来标记每个版本，确保我们可以回溯历史版本。” 小李进一步解释道，“此外，通过在 Git 仓库中配置 CI&#x2F;CD 流程，每个微服务都能独立构建、测试和部署，确保每个服务的更新不会影响其他服务的运行。”</p><p>项目经理表示赞同：“这样的话，每个微服务就能独立管理，同时保持与其他服务的同步，减少了系统的耦合性。”</p><p>小李帮助团队将 Git 应用于微服务架构的管理中，为每个微服务创建了独立的 Git 仓库，并通过 Git 子模块来管理服务之间的依赖。通过这种方式，每个微服务的代码都能独立更新和发布，而 Git 确保了服务之间的同步和版本控制。</p><h4 id="第四十二章：Git-与团队协作工具的集成"><a href="#第四十二章：Git-与团队协作工具的集成" class="headerlink" title="第四十二章：Git 与团队协作工具的集成"></a><strong>第四十二章：Git 与团队协作工具的集成</strong></h4><p>随着团队逐渐壮大，协作工具的使用也变得越来越重要。小李发现，除了 Git，本地的代码管理，团队还需要借助 Slack、Jira、Trello 等工具进行任务管理、沟通和协作。为了提高工作效率，如何将 Git 与这些工具集成，成为了小李的新挑战。</p><p>“小李，我们希望在每次代码提交时，能够自动通知团队成员并更新任务进度，你觉得 Git 能和这些工具集成吗？” 项目经理问道。</p><p>“完全可以，” 小李答道，“我们可以利用 Git 提供的 webhook 功能，将 Git 与 Slack、Jira 等工具集成。当我们提交代码时，可以自动通过 webhook 发送消息到 Slack，通知团队成员代码的更新；同时，我们也可以自动更新 Jira 上的任务状态，让团队成员更清晰地知道当前任务的进度。”</p><p>项目经理听后非常赞同：“这能大大提高我们的沟通效率，让每个团队成员都能第一时间知道任务进展。”</p><p>小李立即开始为团队配置 Git 与 Slack 和 Jira 的集成。他设置了 GitHub 的 webhook，在每次提交时，自动发送消息到团队的 Slack 频道，告知大家新的功能开发进度或 bug 修复的状态。同时，他也将 Jira 与 GitHub 集成，每次提交代码时，相关的任务会自动更新状态，确保任务进展清晰可见。</p><p>“小李，太棒了！通过这种集成，我们的沟通效率大大提高，团队成员能够第一时间看到任务的进展和代码更新。” 项目经理感慨道。</p><h4 id="第四十三章：Git-的未来——AI-与自动化的结合"><a href="#第四十三章：Git-的未来——AI-与自动化的结合" class="headerlink" title="第四十三章：Git 的未来——AI 与自动化的结合"></a><strong>第四十三章：Git 的未来——AI 与自动化的结合</strong></h4><p>随着技术的不断进步，小李看到 Git 的发展趋势将不仅仅停留在传统的版本控制和协作管理上。人工智能（AI）和自动化工具的结合，将使 Git 变得更加智能化，能够自动分析代码质量，提供代码优化建议，甚至自动修复常见的代码问题。</p><p>“小李，你认为 Git 在未来的发展会是怎样的？” 项目经理问道。</p><p>“我认为，未来 Git 会与 AI 更紧密地结合，自动化和智能化的特性将进一步增强。” 小李回答道，“例如，Git 将能够通过 AI 自动分析代码的质量、风格和结构，自动生成优化建议，并通过机器学习模型来预测代码的潜在问题。未来的 Git 可能不仅仅是一个代码管理工具，它也可以作为开发中的智能助手，帮助开发者更高效地编写和管理代码。”</p><p>项目经理笑了笑：“这个思路非常前瞻，的确，AI 与 Git 的结合将为开发者带来更多的便利。也许在不久的将来，Git 就不再是一个仅仅执行命令的工具，而是一个智能的合作伙伴，主动为开发者提供帮助。”</p><p>小李对未来的 Git 充满期待。他相信，随着 AI 和自动化技术的发展，Git 将继续进化，成为开发者不可或缺的智能伙伴，不仅帮助管理版本和代码，更会成为整个开发过程中的决策支持系统。</p><h4 id="第四十四章：Git-与版本控制系统的进化"><a href="#第四十四章：Git-与版本控制系统的进化" class="headerlink" title="第四十四章：Git 与版本控制系统的进化"></a><strong>第四十四章：Git 与版本控制系统的进化</strong></h4><p>随着技术的不断发展和项目需求的不断增加，小李渐渐意识到，Git 的功能已远远超出了传统的版本控制工具的范畴。越来越多的团队开始探索如何利用 Git 在更高层次的工作流和管理中发挥作用。小李对 Git 的深度掌握也逐渐使他开始考虑，未来是否有可能会出现新的版本控制系统，或者 Git 会如何进化以适应未来的需求。</p><p>“小李，你觉得 Git 在未来会如何发展？是否会有其他版本控制工具取代 Git 的地位？” 项目经理在一次会议中向小李提出了这个问题。</p><p>小李思索了一下，回答道：“我认为 Git 目前仍然是最强大的版本控制系统，它已经深深扎根于开发者的工作流中。不过，随着大数据、分布式计算和人工智能的快速发展，Git 可能会在未来进行一些技术性进化，特别是在性能优化、协作和自动化方面。可能我们会看到更多与 Git 集成的工具，或是智能化的 Git 提示系统，甚至 Git 会在管理大规模分布式系统中变得更加高效。”</p><p>他继续说道：“目前的 Git 是为开发者和小型团队设计的，但随着大型开源项目和企业级开发的需求增加，Git 在性能和复杂工作流方面仍然存在一定的局限性。未来可能会出现一种更加适应大规模并行开发、全球分布式协作和高度自动化的版本控制系统。”</p><p>项目经理点头表示认可：“你说得对，随着开发需求的多样化，Git 也必须不断进化，才能保持其在开发中的核心地位。”</p><p>小李也意识到，尽管 Git 强大且灵活，但未来开发模式的变化无疑将推动版本控制系统的发展。基于人工智能和机器学习的自动化工具，可能会为 Git 提供更加智能的版本分析和优化建议，同时帮助开发者快速发现潜在问题，甚至自动修复常见的代码错误。未来的 Git，可能不仅仅是一个代码管理工具，它可能变成一个主动帮助开发者的智能平台。</p><h4 id="第四十五章：Git-与云原生技术的结合"><a href="#第四十五章：Git-与云原生技术的结合" class="headerlink" title="第四十五章：Git 与云原生技术的结合"></a><strong>第四十五章：Git 与云原生技术的结合</strong></h4><p>随着 Kubernetes、Docker 等云原生技术的普及，团队的工作流程和开发环境也发生了巨大的变化。尤其是在微服务架构、容器化和云部署方面，Git 被赋予了新的角色。小李看到了 Git 与云原生技术结合的巨大潜力，开始思考如何将 Git 更好地融入到云原生的开发和部署流程中。</p><p>“小李，考虑到我们现在使用的 Kubernetes 和 Docker，如何将 Git 与这些工具结合，以便更好地支持我们在云环境中的开发和部署？” 项目经理提出了新的挑战。</p><p>小李微笑着回答：“Git 在云原生开发中的作用将变得越来越重要。它不仅可以用于代码管理和版本控制，还能与 CI&#x2F;CD 工具和容器化管理平台如 Docker 和 Kubernetes 紧密集成。通过 Git，我们可以管理云原生应用的代码、配置和容器镜像的版本，并通过 Git 的工作流管理持续集成和交付。”</p><p>“能不能更具体地说说 Git 如何与这些工具集成？” 项目经理继续问。</p><p>“当然。我们可以通过 Git 来管理 Kubernetes 的 YAML 配置文件和 Dockerfile，每次提交都会自动更新这些文件并生成新的容器镜像。然后，我们可以将 Git 与 CI&#x2F;CD 工具（如 Jenkins、GitLab CI 或 CircleCI）集成，让每次代码提交都触发自动化构建、测试和部署流程。当新的容器镜像构建完成后，Kubernetes 可以自动更新集群中的服务，确保所有服务运行的是最新版本的容器。” 小李解释道。</p><p>小李随后展示了如何将 Git、Docker 和 Kubernetes 融合在一起。他为团队配置了 GitLab CI，通过 GitLab 的 CI 管道，自动化地将每次提交的代码构建成 Docker 镜像，并将其推送到容器镜像仓库。然后，GitLab CI 会触发 Kubernetes 的滚动更新，将最新的容器镜像部署到集群中。</p><p>“这样一来，团队可以通过 Git 统一管理应用代码、容器镜像和配置文件，所有的操作都可以自动化完成，大大提升了开发和部署效率。” 小李补充道。</p><p>项目经理非常满意：“通过 Git、Docker 和 Kubernetes 的结合，我们能够实现更高效的开发和部署流程，这样我们的云原生应用管理会变得更加灵活和自动化。”</p><h4 id="第四十六章：Git-与人工智能的融合——自动化代码审查"><a href="#第四十六章：Git-与人工智能的融合——自动化代码审查" class="headerlink" title="第四十六章：Git 与人工智能的融合——自动化代码审查"></a><strong>第四十六章：Git 与人工智能的融合——自动化代码审查</strong></h4><p>小李对 Git 的理解越来越深，他意识到，随着人工智能（AI）的发展，Git 与 AI 的结合将带来革命性的变化，尤其是在代码审查和质量保障方面。人工智能的智能化算法可以帮助自动化审查每次提交的代码，检测潜在的 bug、代码风格问题、甚至安全漏洞，从而进一步提高开发效率和代码质量。</p><p>“小李，你提到过 Git 可以与人工智能结合，我非常感兴趣。你认为 Git 和 AI 会如何结合呢？” 项目经理问道。</p><p>小李兴奋地回答：“未来 Git 可以与 AI 技术结合，自动化地分析每次提交的代码并提供反馈。比如，AI 可以通过机器学习算法分析代码的历史版本，识别出常见的代码问题、低效的代码结构和潜在的安全漏洞。每当开发者提交代码时，AI 会自动进行审查，甚至给出优化建议，帮助开发者提高代码质量。”</p><p>他继续解释：“AI 还可以根据项目的代码库和历史记录学习最佳实践，为每次提交提供个性化的建议。此外，AI 还可以通过分析大量的开源项目，帮助开发者学习其他项目的代码风格和技术实现，优化自己的代码。”</p><p>小李展示了如何将 Git 与 AI 集成，利用 GitHub Actions 和第三方 AI 插件，自动对每次提交的代码进行静态分析，检测潜在的 bug 和性能瓶颈。通过这种方式，开发者可以在代码提交之前获得实时的反馈，大大减少了错误的发生，并提高了代码的质量。</p><p>项目经理听后非常赞赏：“这个方案非常前沿，未来的 Git 不仅仅是一个版本控制工具，它还能成为智能的代码审查助手，主动帮助开发者提升代码质量。”</p><h4 id="第四十七章：Git-与团队文化的深度融合"><a href="#第四十七章：Git-与团队文化的深度融合" class="headerlink" title="第四十七章：Git 与团队文化的深度融合"></a><strong>第四十七章：Git 与团队文化的深度融合</strong></h4><p>随着时间的推移，Git 不仅仅作为一个技术工具融入了团队的开发流程，也深刻影响了团队的文化。通过 Git，团队逐渐形成了一种透明、开放、协作的文化，所有的代码变更都能被追溯，团队成员之间的沟通变得更加顺畅。</p><p>“小李，最近我发现团队成员之间的沟通和协作变得更加高效了，大家在提交代码时，都在 <code>commit message</code> 中写得很清楚，代码审查时也能快速理解每个提交的目的和实现。” 项目经理总结道。</p><p>小李点头表示同意：“是的，Git 让我们的团队更透明。每个提交记录不仅仅是对代码的记录，也是对开发过程的记录。通过清晰的提交信息和 Pull Request，我们能够看到每个开发者的工作进展和思路，及时发现并解决问题。”</p><p>项目经理继续说道：“而且，Git 让我们保持了高效的协作，每个人都能在自己的分支上独立开发，只有经过审查和确认后，才会合并到主分支。这样我们不仅能保证代码质量，也避免了直接推送到主分支可能带来的风险。”</p><p>小李感慨道：“Git 让我们建立了一个高效、透明的开发文化，不仅提高了工作效率，还增强了团队之间的信任和合作。”</p><h4 id="第四十八章：Git-与创新的结合——开源贡献与全球合作"><a href="#第四十八章：Git-与创新的结合——开源贡献与全球合作" class="headerlink" title="第四十八章：Git 与创新的结合——开源贡献与全球合作"></a><strong>第四十八章：Git 与创新的结合——开源贡献与全球合作</strong></h4><p>随着团队项目的不断发展，小李的思维也逐渐扩展到全球开源社区的协作。在一次技术分享会上，项目经理提到了一个新的发展方向：“小李，我们是否可以将我们的部分技术栈或工具开源，贡献给全球开发者社区，获得更多的反馈和贡献？”</p><p>小李顿时眼前一亮：“开源是一个很好的方式，可以通过全球社区的力量推动项目进步。同时，Git 本身就是开源的，已经深深融入了全球开发者的工作流。我们可以通过 GitHub 或 GitLab 等平台将我们的项目开源，让更多的人参与进来。”</p><p>“你说得对，开源不仅能促进技术创新，还能让我们获得来自全球的反馈。” 项目经理笑道，“那我们开始考虑如何将我们的项目开源吧。”</p><p>小李开始探索如何将团队开发的工具和库开源，并通过 Git 管理开源项目。首先，他为项目创建了一个 GitHub 仓库，并在仓库中提供了详细的文档、安装指南、功能说明等内容。接着，他将项目代码整理好，确保它能与其他开发者无缝集成。</p><p>在开源项目的管理过程中，小李使用 Git 的 Pull Request 工作流来管理外部贡献。当其他开发者提出修改或优化时，团队通过审查 Pull Request 来评估贡献质量，最终合并到主仓库中。这种流程帮助团队高效管理外部的贡献，同时确保代码质量和稳定性。</p><p>“小李，看到这些来自全球开发者的贡献，我们不仅提高了工具的质量，也扩大了团队的影响力。” 项目经理感叹道，“通过 Git 和开源，我们实现了全球范围的技术合作。”</p><p>小李也感到无比兴奋，他知道开源不仅是对技术的贡献，更是一种全球化的合作方式。通过 Git 管理的开源项目，他与全球开发者共同推动了技术的进步。</p><h4 id="第四十九章：Git-与-DevOps-2-0——智能化运维与持续交付"><a href="#第四十九章：Git-与-DevOps-2-0——智能化运维与持续交付" class="headerlink" title="第四十九章：Git 与 DevOps 2.0——智能化运维与持续交付"></a><strong>第四十九章：Git 与 DevOps 2.0——智能化运维与持续交付</strong></h4><p>在一次团队会议中，随着 DevOps 实践的深入，小李意识到，随着自动化、人工智能和机器学习的引入，DevOps 也逐渐进入了智能化的新阶段。团队在原有的 CI&#x2F;CD 管道上进一步优化，加入了智能化运维和持续交付（Continuous Delivery，CD）的理念。</p><p>“小李，现在我们已经将 CI&#x2F;CD 集成到项目中，但如何进一步优化并提高运维的智能化水平呢？” 项目经理问道。</p><p>小李思索了一下，回答道：“我认为，我们可以通过将 AI 和机器学习引入到 DevOps 流程中，提升运维和发布的智能化水平。Git 可以与这些新技术结合，通过持续监控、数据分析和预测算法，帮助团队提前发现潜在的问题，甚至自动执行修复。”</p><p>他继续解释：“例如，我们可以通过 Git 与机器学习模型的结合，分析每次提交的代码，预测可能的性能瓶颈或代码错误。根据这些预测，CI&#x2F;CD 管道可以提前生成优化建议，甚至自动修复代码中的常见问题。”</p><p>项目经理对这个思路非常感兴趣：“这个方向非常有前景。Git 不仅仅是管理版本的工具，未来它还可能成为我们 DevOps 2.0 中智能化运维的一部分。”</p><p>小李开始着手实现这一方案。他集成了 Git、Jenkins 和 AI 模型，通过分析每次提交的代码，预测潜在的性能问题和安全漏洞，并将预测结果通过 Git 提交记录反馈给开发者。当 Git 检测到潜在问题时，自动发出警告，并触发自动化修复任务。</p><p>“通过 Git 与 AI 的结合，我们的 DevOps 2.0 管道变得更加智能化，能够自动监控、分析和修复代码中的问题，减少了人工干预。” 小李兴奋地说道。</p><p>项目经理也非常满意：“这不仅能提高开发效率，还能让我们更早地发现并解决问题，减少了运维的负担。”</p><h4 id="第五十章：Git-与自动化测试的无缝对接"><a href="#第五十章：Git-与自动化测试的无缝对接" class="headerlink" title="第五十章：Git 与自动化测试的无缝对接"></a><strong>第五十章：Git 与自动化测试的无缝对接</strong></h4><p>随着团队对自动化的需求增加，团队决定将自动化测试与 Git 完全集成，确保每次提交和部署都能通过自动化测试来保障代码质量。在过去的项目中，虽然有一些自动化测试，但由于没有与 Git 紧密结合，很多时候测试结果无法及时反馈给开发者，导致修复过程缓慢。</p><p>“小李，我们希望能够将自动化测试与 Git 完美集成，实现每次提交后自动执行单元测试，并将测试结果即时反馈给开发者。” 项目经理提出了新的需求。</p><p>“这个方案完全可以实现。” 小李回答道，“通过 Git 与 CI 工具的结合，我们可以在每次代码提交后自动触发测试脚本，确保代码的质量不受影响。同时，我们还可以将测试结果实时显示在 GitHub 或 GitLab 上，开发者可以第一时间看到自己的提交是否通过了测试。”</p><p>于是，小李开始配置 Git 与 Jenkins 和 Selenium 的集成。每次团队成员向 Git 提交代码时，Jenkins 会自动拉取代码并执行自动化测试，确保每个功能模块都经过严格的测试。测试结果会通过邮件或 Git 的通知功能反馈给开发者，确保开发者能及时修复问题。</p><p>“小李，这样一来，我们就能确保每次提交的代码都经过了自动化测试，不仅提高了代码质量，还能加快开发进程。” 项目经理满意地说道。</p><p>小李也意识到，Git 与自动化测试的结合将使开发流程更加高效和安全，减少了因人为错误或疏忽导致的问题。</p><h4 id="第五十一章：Git-与云平台的深度集成"><a href="#第五十一章：Git-与云平台的深度集成" class="headerlink" title="第五十一章：Git 与云平台的深度集成"></a><strong>第五十一章：Git 与云平台的深度集成</strong></h4><p>随着公司逐渐迁移到云平台进行开发和部署，云平台成为了小李和团队工作流程中的重要部分。如何将 Git 与云平台无缝结合，成为了小李在这一阶段的新挑战。</p><p>“小李，我们已经在使用 AWS 和 Azure 进行开发和部署，但如何将 Git 与云平台更好地结合，形成一个高效的开发和部署流程？” 项目经理问道。</p><p>“我们可以通过 Git 与云平台的 DevOps 工具集成，来实现自动化构建、部署和监控。” 小李回答道，“例如，通过将 Git 与 AWS CodePipeline 或 Azure DevOps 集成，每次代码提交后，Git 会自动触发云平台的构建和部署流程。我们还可以通过云平台的监控工具实时获取应用的运行状态，确保代码始终在稳定的环境中运行。”</p><p>小李帮助团队配置了 AWS CodePipeline，并通过 GitHub 集成了自动构建和部署流程。每当团队成员提交代码时，AWS CodePipeline 会自动拉取代码、构建应用并部署到 AWS 上进行运行。通过云平台的监控工具，团队可以实时查看应用的健康状态，确保应用的稳定性。</p><p>“通过 Git 与云平台的集成，我们能够将开发和部署完全自动化，不仅减少了人工操作，还能实时监控应用的状态。” 小李总结道。</p><p>项目经理对这个集成方案表示高度满意：“这大大提高了我们团队的开发和部署效率，也让我们在云平台上的管理更加便捷。”</p><h4 id="第五十二章：：Git——开发者永不止步的伙伴"><a href="#第五十二章：：Git——开发者永不止步的伙伴" class="headerlink" title="第五十二章：：Git——开发者永不止步的伙伴"></a><strong>第五十二章：：Git——开发者永不止步的伙伴</strong></h4><p>回顾这些年，小李的 Git 旅程不仅仅是一个技术学习的过程，它已经深刻地影响了团队的工作方式，推动了团队从传统开发模式走向 DevOps、AI 和云原生的未来。Git 不仅仅是一个版本控制工具，它已经演化为开发流程的核心，融入了团队的文化和协作方式。</p><p>“小李，你的努力让我们的团队在技术上不断创新，从自动化测试到云平台集成，Git 在我们的开发流程中扮演了越来越重要的角色。” 项目经理感慨道。</p><p>“Git 是我职业生涯中最重要的伙伴，它让我从一个新手开发者成长为今天的技术专家。未来我会继续学习，继续进步。” 小李自信地回答。</p><p>无论技术如何进化，Git 都将继续成为开发者的重要工具，帮助他们管理代码、提升协作效率、自动化工作流程。随着时代的变化，Git 也将继续为开发者提供强大的支持，成为他们永不止步的伙伴。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;第一章：不明觉厉的-Git&quot;&gt;&lt;a href=&quot;#第一章：不明觉厉的-Git&quot; class=&quot;headerlink&quot; title=&quot;第一章：不明觉厉的 Git&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一章：不明觉厉的 Git&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;小李刚从大学毕业，加入了一家快速发展的初创公司，成为了公司的前端开发工程师。这是他人生中的第一份正式工作，他兴奋又忐忑。虽然他在学校里学过一些编程技术，但真正的项目经验还很薄弱。第一天，老板就把他分配到了一个正在开发的 Web 项目中，需要用 Git 进行版本管理。&lt;/p&gt;
&lt;p&gt;“小李，这是你需要参与的项目，我们已经把代码推到 GitHub 上了，记得拉取下来工作。”老板简短的几句话让小李有点懵。&lt;/p&gt;
&lt;p&gt;“GitHub？拉取？我听说过 Git，但从来没用过。”小李在心里嘀咕着。他记得在学校的课堂上，老师提到过 Git 作为一种版本控制工具，可以帮助开发团队协作，但具体怎么使用，还是个谜。&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://airag.click/categories/GIT/"/>
    
    
    <category term="GIT" scheme="https://airag.click/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服开发篇（七）： 解析 Docker Compose Override</title>
    <link href="https://airag.click/posts/7ac076b/"/>
    <id>https://airag.click/posts/7ac076b/</id>
    <published>2025-07-17T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>看过很多的 Docker 教程，也都不曾提到过 compose override，第一次接触到这个是在懒猫微服上解开 LPK 看到的，用来注入 docker 引擎的环境变量。但是还以为是懒猫微服的小技巧，今天整理笔记才发现原来的 Docker compose 用来做多环境部署的配置文件，比如用来给开发和生产分别注入不同的环境变量和配置文件。</p><blockquote><p>参考文档：<a href="https://developer.lazycat.cloud/advanced-compose-override.html">Docker Compose Override - LazyCat Developer Guide</a></p></blockquote> <span id="more"></span><p>使用场景是这样，在实际开发中，通常我们需要分别为开发和生产环境配置不同的服务和环境变量。虽然可以为每个环境维护独立的 Compose 文件，Docker Compose 提供了一个非常有用的特性，可以将多个 Compose 文件结合使用，简化配置管理。</p><ul><li><strong>基础配置文件</strong>：第一个 Compose 文件通常作为基础配置，后续的文件可以覆盖该基础文件中的配置。</li><li><strong>覆盖配置</strong>：每个额外的文件不仅可以覆盖基础文件中的已有配置，还可以添加新的配置。</li></ul><p>默认情况下，Compose 会读取以下两个文件：</p><ul><li><strong>docker-compose.yml</strong>：基础配置文件</li><li><strong>docker-compose.override.yml</strong>：覆盖文件</li></ul><p>你还可以通过 <code>-f</code> 参数指定多个非默认的覆盖文件，Compose 会按顺序合并这些文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose -f docker-compose.yml -f dev.override.yml up</span><br></pre></td></tr></table></figure><ul><li><strong>docker-compose config</strong>：这是一个非常有用的命令，可以帮助你验证最终的配置文件，尤其是在使用多个 Compose 文件时。它显示了合并后的 Compose 配置，帮助你确保配置符合预期。</li></ul><h3 id="示例：Nginx-配置"><a href="#示例：Nginx-配置" class="headerlink" title="示例：Nginx 配置"></a>示例：Nginx 配置</h3><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br></pre></td></tr></table></figure><h4 id="docker-compose-override-yml"><a href="#docker-compose-override-yml" class="headerlink" title="docker-compose.override.yml"></a>docker-compose.override.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./dev:/usr/share/nginx/html</span> <span class="comment"># 使用本地开发文件夹覆盖默认卷</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEBUG=true</span> <span class="comment"># 启用开发环境的调试模式</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250717205319123-20250717213705118.png" alt="image-20250717205319123"></p><p>在这个例子中，<code>docker-compose.override.yml</code> 覆盖了 <code>docker-compose.yml</code> 中的配置，添加了开发环境相关的文件挂载和环境变量设置。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250717205507275.png" alt="image-20250717205507275"></p><h3 id="合并后的配置（查看通过-docker-compose-config-命令生成的配置）"><a href="#合并后的配置（查看通过-docker-compose-config-命令生成的配置）" class="headerlink" title="合并后的配置（查看通过 docker-compose config 命令生成的配置）"></a>合并后的配置（查看通过 <code>docker-compose config</code> 命令生成的配置）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    environment:</span><br><span class="line">      DEBUG: <span class="string">&quot;true&quot;</span></span><br><span class="line">    image: nginx:latest</span><br><span class="line">    networks:</span><br><span class="line">      default: null</span><br><span class="line">    ports:</span><br><span class="line">      - mode: ingress</span><br><span class="line">        target: 80</span><br><span class="line">        published: <span class="string">&quot;80&quot;</span></span><br><span class="line">        protocol: tcp</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="built_in">type</span>: <span class="built_in">bind</span></span><br><span class="line">        <span class="built_in">source</span>: /Users/name/Desktop/dev</span><br><span class="line">        target: /usr/share/nginx/html</span><br><span class="line">        <span class="built_in">bind</span>:</span><br><span class="line">          create_host_path: <span class="literal">true</span></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    name: 3_default</span><br></pre></td></tr></table></figure><p>可以看到，通过合并配置，开发环境的调试模式和本地文件夹挂载已经成功加入了配置。</p><h3 id="懒猫应用的上的-compose-override"><a href="#懒猫应用的上的-compose-override" class="headerlink" title="懒猫应用的上的 compose override"></a>懒猫应用的上的 compose override</h3><p>针对一些 lpk 规范目前无法覆盖到的运行权限需求， 可以通过 <a href="https://docs.docker.com/reference/compose-file/merge/">compose override</a> 机制来间接实现。</p><p>通过应用查看器可以看到，这是 <strong>Docker Compose</strong> 配置的一部分，用于定义容器中的 <code>containly</code> 服务，并映射 playground 的 docker 引擎。具体的配置说明如下：</p><ul><li><strong>services</strong>: 这是 Docker Compose 文件的顶级字段，定义了服务列表。<code>containly</code> 是定义的一个服务名称。</li><li><strong>containly</strong>: 这是服务的名称。在此配置下，的服务名是 <code>containly</code>。</li><li><strong>volumes</strong>: 定义了容器与宿主机（本地）之间的文件夹共享和挂载。该部分的配置是映射一个本地目录到容器内部的目录。<ul><li><strong>bind</strong>: 使用绑定挂载的方式（bind mount），允许宿主机的文件或目录直接映射到容器内部。这里设置了 <code>create_host_path: true</code>，意思是如果宿主机上的 <code>/data/playground</code> 目录不存在，它会自动创建。</li><li><strong>source</strong>: 宿主机的路径，映射为容器中的目录。这里指定了 <code>/data/playground</code> 作为源路径，意味着宿主机上的这个目录将被挂载到容器内。</li><li><strong>target</strong>: 容器内的路径，即宿主机上的 <code>source</code> 目录映射到容器内部的 <code>/lzcapp/run/playground</code> 目录。容器内的应用可以访问这个目录。</li><li><strong>type</strong>: 这里设置的是 <code>bind</code>，表示采用绑定挂载方式</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250717210507516.png" alt="image-20250717210507516"></p><p>最后 highlight 下 WIKI 里的三句话：</p><ol><li><strong>确认最终生成的 <code>lpk</code> 中存在名为 <code>compose.override.yml</code> 的文件</strong>，并且内容是一个合法的 Compose 合并文件。</li><li><strong>通过 SSH 进入 <code>/data/system/pkgm/run/$appid</code> 目录</strong>，确认该目录下是否存在 <code>override.yml</code> 文件。</li><li><strong>使用 <code>lzc-docker-compose config</code> 命令查看最终合并后的配置</strong>，确保它符合预期。</li></ol><p>子&#x2F;data&#x2F;system&#x2F;pkgm&#x2F;run&#x2F;$appid 目录里，我的结果如下,供参考。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker compose config</span><br><span class="line"></span><br><span class="line">name: xudeploycontainly</span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">....</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">bind</span></span><br><span class="line">        <span class="built_in">source</span>: /data/playground</span><br><span class="line">        target: /lzcapp/run/playground</span><br><span class="line">        <span class="built_in">bind</span>:</span><br><span class="line">          create_host_path: <span class="literal">true</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(base) lzcbox-029c588e /data/system/pkgm/run/xu.deploy.containly <span class="comment"># ls</span></span><br><span class="line">compose.override.yml  docker-compose.yml  pkg</span><br><span class="line">(base) lzcbox-029c588e /data/system/pkgm/run/xu.deploy.containly <span class="comment"># cat compose.override.yml</span></span><br><span class="line">services:</span><br><span class="line">  containly:</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="built_in">bind</span>:</span><br><span class="line">          create_host_path: <span class="literal">true</span></span><br><span class="line">        <span class="built_in">source</span>: /data/playground</span><br><span class="line">        target: /lzcapp/run/playground</span><br><span class="line">        <span class="built_in">type</span>: <span class="built_in">bind</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;看过很多的 Docker 教程，也都不曾提到过 compose override，第一次接触到这个是在懒猫微服上解开 LPK 看到的，用来注入 docker 引擎的环境变量。但是还以为是懒猫微服的小技巧，今天整理笔记才发现原来的 Docker compose 用来做多环境部署的配置文件，比如用来给开发和生产分别注入不同的环境变量和配置文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://developer.lazycat.cloud/advanced-compose-override.html&quot;&gt;Docker Compose Override - LazyCat Developer Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://airag.click/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服进阶心得（十一）：把懒猫微服当作旁路由，客户端无需转发直接访问内外地址</title>
    <link href="https://airag.click/posts/5018903b/"/>
    <id>https://airag.click/posts/5018903b/</id>
    <published>2025-07-17T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>今天在外面通过懒猫转发访问路由器时，发现需要逐一映射多个内网地址，操作起来有点麻烦，于是想到了一种一劳永逸的解决办法。</p><p>最开始我用 Squid 来代理 AWS VPC，后来想到懒猫也可以用作同样的功能。以下是我准备的 Compose 配置，我已经完成了 app 镜像的复制。</p> <span id="more"></span><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">squid:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3128</span><span class="string">:3128</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lazycat.cloud/u04123229/ubuntu/squid:c534e32e8e1e766e</span></span><br><span class="line"><span class="attr">networks:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>下面是 Docker 截图：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250718122636189-20250718130918029.png" alt="image-20250718122636189"></p><p>默认安装后，Squid 的默认规则会屏蔽所有网站。若要访问内网地址，就会看到“访问被拒绝”的提示。接下来，我们需要修改转发规则。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250718124511756.png" alt="image-20250718124511756"></p><p>进入 Squid 容器，编辑配置文件，然后重启容器即可生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/squid/squid.conf</span><br><span class="line"># 在文件底部添加以下行以允许所有 HTTP 访问</span><br><span class="line">http_access allow all</span><br></pre></td></tr></table></figure><p>现在就可以使用你喜欢的工具进行访问了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250718124727452.png" alt="image-20250718124727452"></p><p>然后就可以在外边访问私有地址了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250718150626296.png" alt="image-20250718150626296"></p><p>或者在终端上，通过设置环境变量以通过代理服务器访问 HTTP 和 HTTPS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://your_proxy_ip:3128</span><br><span class="line">export https_proxy=http://your_proxy_ip:3128</span><br></pre></td></tr></table></figure><h4 id="如果你需要白名单功能："><a href="#如果你需要白名单功能：" class="headerlink" title="如果你需要白名单功能："></a>如果你需要白名单功能：</h4><p>首先，创建一个包含你希望允许访问的域名的白名单文件。该文件会用于匹配允许的域名。</p><ol><li><p>打开终端并创建白名单文件。例如，我们将其存放在 <code>/etc/squid/whitelist</code> 路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/squid/whitelist</span><br></pre></td></tr></table></figure></li><li><p>在文件中，每行列出一个希望允许访问的域名。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.youtube.com</span><br><span class="line">.bilibili.com</span><br><span class="line">.example.com</span><br></pre></td></tr></table></figure><p>这样就允许 <code>youtube.com</code>、<code>bilibili.com</code> 和 <code>example.com</code> 的请求通过代理，而其他未列出的域名将被拒绝。</p></li></ol><h4 id="2-编辑-squid-conf-配置文件"><a href="#2-编辑-squid-conf-配置文件" class="headerlink" title="2. 编辑 squid.conf 配置文件"></a>2. <strong>编辑 <code>squid.conf</code> 配置文件</strong></h4><p>接下来，编辑 Squid 的主配置文件 <code>squid.conf</code>，将白名单配置添加到文件中。</p><ol><li><p>打开 Squid 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/squid/squid.conf</span><br></pre></td></tr></table></figure></li><li><p>在文件中，找到并添加以下规则：</p><ul><li><p><strong>允许 <code>localhost</code> 访问</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access allow localhost</span><br></pre></td></tr></table></figure><p>该规则允许本地计算机（localhost）访问代理服务器。</p></li><li><p><strong>添加白名单配置</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acl whitelist dstdomain &quot;/etc/squid/whitelist&quot;</span><br><span class="line">http_access allow whitelist</span><br></pre></td></tr></table></figure><p>这两行配置定义了一个名为 <code>whitelist</code> 的 ACL（访问控制列表），它从 <code>/etc/squid/whitelist</code> 文件中加载允许的域名。然后，我们允许匹配这些域名的请求。</p></li><li><p><strong>拒绝所有其他访问</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access deny all</span><br></pre></td></tr></table></figure><p>该规则确保只有白名单中的域名可以访问代理，其他所有请求都将被拒绝。</p></li></ul></li><li><p><strong>配置端口和缓存</strong>：</p><p>你可以在 <code>squid.conf</code> 文件中设置 Squid 的监听端口并配置缓存目录（如有需要）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_port 3128</span><br><span class="line">coredump_dir /var/spool/squid</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;今天在外面通过懒猫转发访问路由器时，发现需要逐一映射多个内网地址，操作起来有点麻烦，于是想到了一种一劳永逸的解决办法。&lt;/p&gt;
&lt;p&gt;最开始我用 Squid 来代理 AWS VPC，后来想到懒猫也可以用作同样的功能。以下是我准备的 Compose 配置，我已经完成了 app 镜像的复制。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="代理" scheme="https://airag.click/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>EC2 没有绑定 EIP，重启后 IP 会变？DDNS-GO 自动更新你的域名</title>
    <link href="https://airag.click/posts/369cde6d/"/>
    <id>https://airag.click/posts/369cde6d/</id>
    <published>2025-07-14T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.892Z</updated>
    
    <content type="html"><![CDATA[<p>在 IPV4 即将枯竭的年代，云服务商的 EIP 也开始收费了。对于没有弹性公网 IP（EIP）的云服务器，我们可以通过 DDNS-GO 实现动态域名解析。本文介绍了如何使用 Docker 快速部署 DDNS-GO，并借助 DDNS 实现动态域名绑定，从而让服务器即使公网 IP 变化，也能够实时更新域名解析记录，这样只需要使用域名访问，不再需要在控制台查看。</p><hr><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>使用官方安装脚本快速安装 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br></pre></td></tr></table></figure><span id="more"></span><p>设置 Docker 开机自启并立即启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><hr><h2 id="添加当前用户到-docker-用户组（避免每次用-sudo）"><a href="#添加当前用户到-docker-用户组（避免每次用-sudo）" class="headerlink" title="添加当前用户到 docker 用户组（避免每次用 sudo）"></a>添加当前用户到 <code>docker</code> 用户组（避免每次用 sudo）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="生效方式："><a href="#生效方式：" class="headerlink" title="生效方式："></a>生效方式：</h3><ul><li>推荐：<strong>重新登录终端会话</strong></li><li>或使用临时方式立即生效：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><p>验证是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>若无权限报错，则配置已生效。</p><hr><h2 id="Docker-中部署-DDNS-GO"><a href="#Docker-中部署-DDNS-GO" class="headerlink" title="Docker 中部署 DDNS-GO"></a>Docker 中部署 DDNS-GO</h2><p>我们将使用 Docker 的 <code>host</code> 网络模式挂载主机目录，确保 DDNS 能正常检测本地 IP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name ddns-go --restart=always --net=host -v /opt/ddns-go:/root jeessy/ddns-go</span><br></pre></td></tr></table></figure><ul><li><p><code>/opt/ddns-go</code> 是主机目录，你可以替换为任意路径，用于持久化配置。</p></li><li><p>启动后，DDNS-GO 的配置文件为 <code>.ddns-go.yaml</code>，位于挂载目录中。</p></li></ul><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>部署完成后，打开浏览器访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;Docker主机IP&gt;:9876</span><br></pre></td></tr></table></figure><p>你会看到 DDNS-GO 的初始化页面，如图所示：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715114247261.png" alt="初始化配置页面"></p><p>DDNS-GO 是一个开源的动态域名更新工具，支持多个域名服务商，我的域名托管在 cloudflare 上，所以需要在 cloudflare 上申请一个 API-KEY 来做这个更新。</p><ul><li><strong>TTL 建议设置为“自动”</strong></li><li><strong>IP 获取方式推荐使用外网 API（如 ipip.net）</strong></li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715115315906-20250715122303544.png" alt="成功绑定 DDNS 地址"></p><p>前往 Cloudflare 的 <a href="https://dash.cloudflare.com/profile/api-tokens">API Token 页面</a>，为 DDNS-GO 创建一个具备修改 DNS 权限的 Token。</p><p>建议选择 <strong>“Edit zone DNS”</strong> 模板，只赋予必要权限，并可以限制在特定域名范围内使用。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/ceb3433ce7976c7c3199fc54402af084-20250715122245169.png" alt="Cloudflare API Token 创建"></p><p>此外，DDNS-GO 支持 webhook 通知，可选用如 Slack、Server 酱等方式实时通知 IP 变动情况。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715121816313.png" alt="image-20250715121816313"></p><hr><h2 id="验证-DDNS-的效果"><a href="#验证-DDNS-的效果" class="headerlink" title="验证 DDNS 的效果"></a>验证 DDNS 的效果</h2><p>我们尝试停止云主机后再重新开启，公网 IP 会发生变化：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715120531839.png" alt="公网 IP 变化"></p><p>重启后 DDNS-GO 会自动检测 IP 变动并更新域名解析：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715120827569.png" alt="DDNS 更新成功"></p><p>通过域名访问服务仍然保持不变，无需手动更新 IP。</p><hr><p>同时 Server 也会把这个消息推送到手机上：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250715121937366.png" alt="image-20250715121937366"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>即使云服务器没有绑定弹性公网 IP，借助 DDNS-GO 和 Docker，我们依然可以实现动态域名解析：</p><ul><li><strong>低成本</strong>：无需购买 EIP，节省开销；</li><li><strong>自动化</strong>：IP 改变后自动更新域名解析；</li><li><strong>易部署</strong>：Docker 一键运行，配置简单直观。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 IPV4 即将枯竭的年代，云服务商的 EIP 也开始收费了。对于没有弹性公网 IP（EIP）的云服务器，我们可以通过 DDNS-GO 实现动态域名解析。本文介绍了如何使用 Docker 快速部署 DDNS-GO，并借助 DDNS 实现动态域名绑定，从而让服务器即使公网 IP 变化，也能够实时更新域名解析记录，这样只需要使用域名访问，不再需要在控制台查看。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装-Docker&quot;&gt;&lt;a href=&quot;#安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;安装 Docker&quot;&gt;&lt;/a&gt;安装 Docker&lt;/h2&gt;&lt;p&gt;使用官方安装脚本快速安装 Docker：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -fsSL https://get.docker.com -o get-docker.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;sudo&lt;/span&gt; sh get-docker.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="AWS" scheme="https://airag.click/categories/AWS/"/>
    
    
    <category term="AWS" scheme="https://airag.click/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（二十二）：使用 DDNS-GO 给 Cloudflare 做动态域名解析</title>
    <link href="https://airag.click/posts/e12a36f0/"/>
    <id>https://airag.click/posts/e12a36f0/</id>
    <published>2025-07-13T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>我的域名最初是在 AWS 的 Route53 上购买的，然而在使用过程中发现 Host Zone 的费用并不低，除了每月的托管费用，还包括 TTL 更新等开销。在朋友建议下，我决定将域名解析的任务从 AWS 迁移到 Cloudflare，一方面可以节省成本，另一方面配置也更为灵活。</p><h2 id="第一步：更改-NS-记录"><a href="#第一步：更改-NS-记录" class="headerlink" title="第一步：更改 NS 记录"></a>第一步：更改 NS 记录</h2><p>准确地说，需要在原域名注册商（我的是 AWS Route53）处修改 Name Server，将默认的 AWS NS 记录改为 Cloudflare 提供的 NS 地址。这样，域名解析权就转移到了 Cloudflare。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/bf852b6fc90fdb8aeca974c19ebe15fa-20250714213924253-20250714213959894.png" alt="Route53 修改 NS"><br>Route53 中的 NS 修改界面 如下， <em>替换成 Cloudflare 的 NS 后，域名正式托管在 Cloudflare</em></p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250714212603214.png" alt="NS 修改示意"></p><h2 id="第二步：创建-API-Token"><a href="#第二步：创建-API-Token" class="headerlink" title="第二步：创建 API Token"></a>第二步：创建 API Token</h2><p>前往 Cloudflare 的 <a href="https://dash.cloudflare.com/profile/api-tokens">API Token 页面</a>，为 DDNS-GO 创建一个具备修改 DNS 权限的 Token。</p><p>建议选择 <strong>“Edit zone DNS”</strong> 模板，只赋予必要权限，并可以限制在特定域名范围内使用。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/ceb3433ce7976c7c3199fc54402af084.png" alt="Cloudflare API Token 创建"></p><hr><h2 id="第三步：配置-DDNS-GO"><a href="#第三步：配置-DDNS-GO" class="headerlink" title="第三步：配置 DDNS-GO"></a>第三步：配置 DDNS-GO</h2><p>DDNS-GO 是一个开源的动态域名更新工具，支持多个域名服务商（不包括 AWS 的 Route53）。看来不仅迁移出来省钱，还省心。我们把上一步申请的 token 添加到这里，TTL 设置成自动就行。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250714211648662.png" alt="DDNS-GO 配置界面"></p><ul><li><strong>TTL 建议设置为“自动”</strong></li><li><strong>IP 获取方式推荐使用外网 API（如 ipip.net）</strong></li></ul><p>此外，DDNS-GO 支持 webhook 通知，可选用如 Slack、Server 酱等方式实时通知 IP 变动情况。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250714211710302.png" alt="Webhook 配置"></p><h2 id="第四步：查看效果"><a href="#第四步：查看效果" class="headerlink" title="第四步：查看效果"></a>第四步：查看效果</h2><p>我将 DDNS 记录绑定到家用公网 IP（IPv4），未启用 IPv6。保存配置后，前往 Cloudflare 后台查看 DNS 记录，已成功同步更新。</p><blockquote><p>⚠️ 小提示：如果你绑定的 IP 是中国大陆的，<strong>建议不要开启 Cloudflare 的代理功能（小云朵），否则可能出现连接问题</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250714213533869.png" alt="CF DNS 记录更新"></p><h2 id="Bonus：免费-TLS-证书"><a href="#Bonus：免费-TLS-证书" class="headerlink" title="Bonus：免费 TLS 证书"></a>Bonus：免费 TLS 证书</h2><p>使用 Cloudflare 托管 DNS，访问你的网站时会根据规则<strong>加上 TLS 证书</strong>，实现 HTTPS 加密，非常方便省心。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250714212823244.png" alt="自动 TLS 证书"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过将域名解析迁移到 Cloudflare，并配合 DDNS-GO 工具进行动态更新，既省钱又省事，还顺带获得了免费证书加持。相比 AWS Route53 的托管费用和配置复杂度，Cloudflare 无疑是个人用户和轻量级应用的更优选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的域名最初是在 AWS 的 Route53 上购买的，然而在使用过程中发现 Host Zone 的费用并不低，除了每月的托管费用，还包括 TTL 更新等开销。在朋友建议下，我决定将域名解析的任务从 AWS 迁移到 Cloudflare，一方面可以节省成本，另一方面配置也更为灵活。&lt;/p&gt;
&lt;h2 id=&quot;第一步：更改-NS-记录&quot;&gt;&lt;a href=&quot;#第一步：更改-NS-记录&quot; class=&quot;headerlink&quot; title=&quot;第一步：更改 NS 记录&quot;&gt;&lt;/a&gt;第一步：更改 NS 记录&lt;/h2&gt;&lt;p&gt;准确地说，需要在原域名注册商（我的是 AWS Route53）处修改 Name Server，将默认的 AWS NS 记录改为 Cloudflare 提供的 NS 地址。这样，域名解析权就转移到了 Cloudflare。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    <category term="家庭网络" scheme="https://airag.click/tags/%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（二十三）：使用 GitHub 单点登录到 Memos</title>
    <link href="https://airag.click/posts/b10cd1f4/"/>
    <id>https://airag.click/posts/b10cd1f4/</id>
    <published>2025-07-12T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>在构建团队协作平台或知识系统时，接入 GitHub 登录是一种常见的低成本单点登录（SSO）方案，既简洁又安全。本教程将手把手教大家如何创建 GitHub OAuth 应用，并将其集成到 <a href="https://github.com/usememos/memos">Memos</a> 等支持 OAuth 的系统中，帮助用户实现无感登录体验。</p><hr><h2 id="一、创建-GitHub-OAuth-应用"><a href="#一、创建-GitHub-OAuth-应用" class="headerlink" title="一、创建 GitHub OAuth 应用"></a>一、创建 GitHub OAuth 应用</h2><h3 id="1-打开-GitHub-OAuth-应用配置入口"><a href="#1-打开-GitHub-OAuth-应用配置入口" class="headerlink" title="1. 打开 GitHub OAuth 应用配置入口"></a>1. 打开 GitHub OAuth 应用配置入口</h3><ol><li>登录 GitHub，点击右上角头像，选择 <strong>Settings（设置）</strong></li><li>在左侧栏选择 <strong>Developer settings</strong></li><li>点击 <strong>OAuth Apps</strong>，然后点击右侧的 <strong>New OAuth App</strong> 创建新的应用</li></ol><p>📷 页面示意：</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/640-20250713224449968-20250713225034801.png" alt="创建 OAuth 应用"></p><hr><h3 id="2-填写应用基本信息"><a href="#2-填写应用基本信息" class="headerlink" title="2. 填写应用基本信息"></a>2. 填写应用基本信息</h3><p>在创建页面中填写如下字段：</p><ul><li><p><strong>Application Name</strong>：如 <code>Console SSO</code></p></li><li><p><strong>Homepage URL</strong>：建议填写系统主页，例如 <code>https://memos.name.heiyu.space</code></p></li><li><p><strong>Authorization callback URL</strong>：授权成功后的回调地址，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://memos.name.heiyu.space/auth/callback</span><br></pre></td></tr></table></figure></li></ul><p>📷 示例填写界面：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250713224139574.png" alt="填写信息"></p><hr><h3 id="3-获取-Client-ID-和-Client-Secret"><a href="#3-获取-Client-ID-和-Client-Secret" class="headerlink" title="3. 获取 Client ID 和 Client Secret"></a>3. 获取 Client ID 和 Client Secret</h3><p>提交后，GitHub 将生成：</p><ul><li><strong>Client ID</strong>：用于标识该 OAuth 应用</li><li><strong>Client Secret</strong>：用于身份验证，请妥善保存，<strong>不要泄露！</strong></li></ul><p>📷 凭证界面如下：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/640" alt="获取客户端凭证"></p><hr><h2 id="二、查看和管理-OAuth-应用"><a href="#二、查看和管理-OAuth-应用" class="headerlink" title="二、查看和管理 OAuth 应用"></a>二、查看和管理 OAuth 应用</h2><p>创建完成后，返回 OAuth 应用列表，即可看到刚创建的应用。</p><p>点击应用名可查看授权信息和应用详情：</p><p>📷 应用列表和详情视图：</p><ul><li><p>应用列表页面<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/640-20250713224027323-20250713224450558-20250713225035672" alt="OAuth 应用列表"></p><p>然后邮件会收到 Github 绑定 Oauth 的通知。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/bb21e51f43bf5eedd8b6c44ef27e3fd9-20250713225035879.png" alt="授权详情"></p></li></ul><hr><h3 id="4-在-Memos-中配置-GitHub-登录"><a href="#4-在-Memos-中配置-GitHub-登录" class="headerlink" title="4. 在 Memos 中配置 GitHub 登录"></a>4. 在 Memos 中配置 GitHub 登录</h3><p>进入系统设置页面：</p><ol><li>点击左下角齿轮图标（设置）</li><li>选择 <strong>单点登录（SSO）</strong></li><li>选择 GitHub 作为登录方式，填写刚获取的 Client ID 和 Client Secret</li></ol><p>📷 Memos 配置页面示例：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250713224629619.png" alt="设置 GitHub 单点登录"></p><p>配置保存后，注销当前账号，登录页面会显示 GitHub 登录按钮。</p><p>📷 登录页面展示效果：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/26dac7e6f9531a83010a5cc44e95c71f-20250713225036385.png" alt="GitHub 登录入口"></p><p>通过以上步骤，我们完成了 GitHub 登录的接入流程：</p><p>✅ 创建并配置 GitHub OAuth 应用<br>✅ 获取并填入凭证<br>✅ 在 Memos 中启用 OAuth 登录</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在构建团队协作平台或知识系统时，接入 GitHub 登录是一种常见的低成本单点登录（SSO）方案，既简洁又安全。本教程将手把手教大家如何创建 GitHub OAuth 应用，并将其集成到 &lt;a href=&quot;https://github.com/usememos/memos&quot;&gt;Memos&lt;/a&gt; 等支持 OAuth 的系统中，帮助用户实现无感登录体验。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、创建-GitHub-OAuth-应用&quot;&gt;&lt;a href=&quot;#一、创建-GitHub-OAuth-应用&quot; class=&quot;headerlink&quot; title=&quot;一、创建 GitHub OAuth 应用&quot;&gt;&lt;/a&gt;一、创建 GitHub OAuth 应用&lt;/h2&gt;&lt;h3 id=&quot;1-打开-GitHub-OAuth-应用配置入口&quot;&gt;&lt;a href=&quot;#1-打开-GitHub-OAuth-应用配置入口&quot; class=&quot;headerlink&quot; title=&quot;1. 打开 GitHub OAuth 应用配置入口&quot;&gt;&lt;/a&gt;1. 打开 GitHub OAuth 应用配置入口&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;登录 GitHub，点击右上角头像，选择 &lt;strong&gt;Settings（设置）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在左侧栏选择 &lt;strong&gt;Developer settings&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击 &lt;strong&gt;OAuth Apps&lt;/strong&gt;，然后点击右侧的 &lt;strong&gt;New OAuth App&lt;/strong&gt; 创建新的应用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;📷 页面示意：&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>快速启动 http 站点</title>
    <link href="https://airag.click/posts/572b7187/"/>
    <id>https://airag.click/posts/572b7187/</id>
    <published>2025-07-11T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.893Z</updated>
    
    <content type="html"><![CDATA[<p>以下是 Python 内置 HTTP 服务器的几种常用启动方式：</p><ol><li>默认端口启动（8000）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><span id="more"></span><ol start="2"><li>指定端口启动（示例使用 1378 端口）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 1378</span><br></pre></td></tr></table></figure><ol start="3"><li>支持 IPv6 的启动方式：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 1378 --<span class="built_in">bind</span> ::</span><br></pre></td></tr></table></figure><p>这些命令会在当前目录启动一个简单的 HTTP 文件服务器，方便快速共享文件或测试网页。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是 Python 内置 HTTP 服务器的几种常用启动方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认端口启动（8000）：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python -m http.server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://airag.click/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="开发" scheme="https://airag.click/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（二十一）：使用 Memos 替代 Flomo</title>
    <link href="https://airag.click/posts/6f97c31a/"/>
    <id>https://airag.click/posts/6f97c31a/</id>
    <published>2025-07-11T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>曾经用过 Flomo，一度觉得体验不错，但后来因不想续费会员而中止使用。最近在懒猫微服的商店中发现了 <a href="https://github.com/usememos/memos">Memos</a>，完全开源、支持自托管，是个很不错的替代方案。</p><hr><h2 id="什么是-Memos？"><a href="#什么是-Memos？" class="headerlink" title="什么是 Memos？"></a>什么是 Memos？</h2><p><a href="https://github.com/usememos/memos">Memos</a> 是一款开源、极简、现代化的笔记系统，主打「快速记录、随时检索」。适合捕捉灵感、日常备忘、碎片想法、读书笔记等多种用途。</p><p>它具有以下特点：</p><span id="more"></span><ul><li>🧩 极简 Markdown 编辑器，写作无干扰</li><li>🔍 支持标签与多条件过滤，查找便捷</li><li>📱 原生适配移动端界面，自动响应式布局</li><li>🌐 内置开放 API，可接入自动化工具或客户端</li><li>🗂 支持归档、置顶、图像插入、链接跳转等实用功能</li><li>🔐 数据完全自托管，掌控在自己手中</li></ul><p>目前 GitHub star 数已超 6k，开发活跃，文档完善，社区生态也在不断壮大。</p><hr><h2 id="页面结构与使用方式"><a href="#页面结构与使用方式" class="headerlink" title="页面结构与使用方式"></a>页面结构与使用方式</h2><p>Memos 主页面分为两栏：</p><h3 id="✅-左侧侧边栏："><a href="#✅-左侧侧边栏：" class="headerlink" title="✅ 左侧侧边栏："></a>✅ 左侧侧边栏：</h3><ul><li><strong>创建 Memo</strong>：点击加号即可撰写新内容</li><li><strong>标签筛选</strong>：点击任意标签快速过滤</li><li><strong>快捷菜单</strong>：查看所有 Memo、归档 Memo、置顶 Memo、搜索功能等</li></ul><h3 id="✅-右侧内容区："><a href="#✅-右侧内容区：" class="headerlink" title="✅ 右侧内容区："></a>✅ 右侧内容区：</h3><ul><li><p>展示所有 Memo 内容，以时间倒序排列</p></li><li><p>每条 Memo 支持：</p><ul><li>编辑、置顶、归档</li><li>标签添加（支持 <code>#标签名</code> 快捷方式）</li><li>Markdown 格式（支持标题、代码块、列表、引用等）</li><li>拖拽上传图片或截图粘贴</li><li>自动识别链接并可点击跳转</li></ul></li></ul><p>📷 示例页面如下：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711183947167.png" alt="image-20250711183947167"></p><hr><h2 id="开启-API-支持"><a href="#开启-API-支持" class="headerlink" title="开启 API 支持"></a>开启 API 支持</h2><p>在设置中可以启用 API 功能，系统会生成一个唯一的 <code>API KEY</code>，用于连接第三方客户端或自动化工具（如 Moe Memos）。</p><p>📷 API 开关和密钥生成页面如下：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711184031658.png" alt="image-20250711184031658"></p><hr><h2 id="Moe-Memos-客户端"><a href="#Moe-Memos-客户端" class="headerlink" title="Moe Memos 客户端"></a>Moe Memos 客户端</h2><p>App Store 上的 Moe Memos 是一款第三方移动端客户端，原生适配 Memos 的 API 接口，界面极简，使用流畅。</p><p>📷 图标预览：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711184107888.png" alt="image-20250711184107888"></p><hr><h2 id="如何登录-Moe-Memos"><a href="#如何登录-Moe-Memos" class="headerlink" title="如何登录 Moe Memos"></a>如何登录 Moe Memos</h2><ol><li>安装 Moe Memos 后，打开 App</li><li>输入你的自托管域名，如 <code>https://memos.name.heiyu.space</code></li><li>填写 API KEY 即可登录（需在系统中开启单租户模式）</li></ol><p>📷 登录后界面展示：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711183848763.png" alt="image-20250711183848763"></p><hr><h2 id="简单对比-Flomo"><a href="#简单对比-Flomo" class="headerlink" title="简单对比 Flomo"></a>简单对比 Flomo</h2><table><thead><tr><th>功能</th><th>Flomo</th><th>Memos（自托管）</th></tr></thead><tbody><tr><td>微信同步</td><td>✅（原生）</td><td>❌（可接 webhook 实现）</td></tr><tr><td>多端支持</td><td>✅</td><td>✅ Moe Memos</td></tr><tr><td>数据隐私</td><td>❌ 云端托管</td><td>✅ 完全自持</td></tr><tr><td>开放 API</td><td>❌ 限制较多</td><td>✅ 支持 API KEY</td></tr><tr><td>成本</td><td>收费会员制</td><td>免费开源（除托管成本）</td></tr><tr><td>Markdown</td><td>❌</td><td>✅ 原生支持</td></tr><tr><td>图片粘贴上传</td><td>❌</td><td>✅</td></tr></tbody></table><p>虽然 Memos 不支持微信原生同步，但凭借开放架构和高度可定制性，能实现更强的私有笔记体验。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Memos 是一款功能恰到好处、设计极简、部署门槛低的笔记系统，非常适合替代 Flomo 这类灵感记录工具。配合懒猫微服提供的部署方案，可以做到：</p><ul><li>一键上线，无需服务器运维知识</li><li>API 集成快捷，客户端体验佳</li><li>数据可备份、可迁移、可掌控</li></ul><p>适合用来做「知识碎片记录」、「阅读随想」、「灵感管理」、「工程笔记」等场景。欢迎大家一起探索更多玩法！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;曾经用过 Flomo，一度觉得体验不错，但后来因不想续费会员而中止使用。最近在懒猫微服的商店中发现了 &lt;a href=&quot;https://github.com/usememos/memos&quot;&gt;Memos&lt;/a&gt;，完全开源、支持自托管，是个很不错的替代方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是-Memos？&quot;&gt;&lt;a href=&quot;#什么是-Memos？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Memos？&quot;&gt;&lt;/a&gt;什么是 Memos？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/usememos/memos&quot;&gt;Memos&lt;/a&gt; 是一款开源、极简、现代化的笔记系统，主打「快速记录、随时检索」。适合捕捉灵感、日常备忘、碎片想法、读书笔记等多种用途。&lt;/p&gt;
&lt;p&gt;它具有以下特点：&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 环境下运行 EasySearch 报错无法信任 Java 包的解决方案</title>
    <link href="https://airag.click/posts/b77119f9/"/>
    <id>https://airag.click/posts/b77119f9/</id>
    <published>2025-07-11T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.888Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>近期因 MacBook 系统降级重装，需重新部署 EasySearch 环境。由于系统未预装 Java，选择下载捆绑 JDK 的 EasySearch 版本，但在安装过程中遇到以下问题：</p><ol><li>系统安全机制拦截 Java 运行</li><li>密码认证异常（持续返回 401 错误）<span id="more"></span></li></ol><h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><ol><li><p><strong>安全拦截</strong><br>MacOS Gatekeeper 阻止运行捆绑的 JDK，即使在「系统偏好设置-安全性与隐私」中手动放行后，仍出现权限不足提示（见图 1）。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/46af71cf990c6b337b0368dff20c8e83.png" alt="安全拦截提示"></p></li><li><p><strong>认证失效</strong><br>配置文件中的密码校验异常，任何登录尝试均返回 401 状态码。</p></li></ol><h4 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h4><ol><li><p><strong>全局权限设置</strong><br>首先通过终端命令关闭系统安全限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> spctl --master-disable</span><br></pre></td></tr></table></figure><p>但发现此操作仍无法解决 JDK 运行问题。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/16d776ecf82e11ffda565666c96494aa-20250712103722754.png" alt="权限设置无效提示"></p></li><li><p><strong>最终解决方案</strong><br>采用处理「App 损坏」报错的方法：</p><ul><li><p>重新解压安装包</p></li><li><p>执行扩展属性清除命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xattr -cr jdk/bin/java</span><br></pre></td></tr></table></figure></li><li><p>重新初始化 EasySearch</p></li></ul></li></ol><h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><p>成功运行 EasySearch 并完成系统初始化（见图 3）。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250712103428122.png" alt="运行成功截图"></p><h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><p>MacOS 对未公证应用的限制日趋严格，建议：</p><ol><li>优先使用公证版本软件</li><li>遇到权限问题时，<code>xattr -cr</code>命令可有效清除可能导致拦截的扩展属性</li><li>401 错误可能与系统权限深度关联，需综合处理运行环境和配置文件</li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h4&gt;&lt;p&gt;近期因 MacBook 系统降级重装，需重新部署 EasySearch 环境。由于系统未预装 Java，选择下载捆绑 JDK 的 EasySearch 版本，但在安装过程中遇到以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统安全机制拦截 Java 运行&lt;/li&gt;
&lt;li&gt;密码认证异常（持续返回 401 错误）</summary>
    
    
    
    <category term="极限科技" scheme="https://airag.click/categories/%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="搜索引擎（ES）" scheme="https://airag.click/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%88ES%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>用Filebeat OSS 7.10.2将收集日志到Easysearch</title>
    <link href="https://airag.click/posts/a0786458/"/>
    <id>https://airag.click/posts/a0786458/</id>
    <published>2025-07-11T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.888Z</updated>
    
    <content type="html"><![CDATA[<p>Filebeat OSS (Open Source Software) 7.10.2 版本是 Elastic 公司提供的开源版本。移除了一些<strong>Elasticsearch</strong>商业化的功能插件（但是没移出去干净）</p><p><a href="https://www.elastic.co/cn/downloads/past-releases/filebeat-oss-7-10-2%E3%80%82">https://www.elastic.co/cn/downloads/past-releases/filebeat-oss-7-10-2。</a></p><p>这主要还是 AWS 和 Elastic 公司之间的矛盾，AWS 托管的 ES 会和 Elastic 抢客户。所以 Elastic 搞了一个不能商业化的协议，影响了这个生态圈，也给开发者造成了很多不方便。</p><span id="more"></span><p>还记得这个非常戏剧性的 Issue：<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/90d8e0f338c94eccb9d48b6f104730bb.png" alt="在这里插入图片描述"></p><p><a href="https://github.com/elastic/beats/issues/8086">https://github.com/elastic/beats/issues/8086</a></p><p>下面将介绍如何配置该版本 Filebeat 将日志发送到 Easysearch。</p><p>以下是完整的<code>filebeat.yml</code>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/messages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/log/httpd/*.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.elasticsearch:</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;yourEasysearchEndpoint:443&quot;</span>]</span><br><span class="line">  <span class="attr">protocol:</span> <span class="string">&quot;https&quot;</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">  <span class="attr">ssl.verification_mode:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下配置用于处理xpack相关兼容性问题</span></span><br><span class="line"><span class="attr">setup.template.name:</span> <span class="string">&quot;filebeat&quot;</span></span><br><span class="line"><span class="attr">setup.template.pattern:</span> <span class="string">&quot;filebeat-*&quot;</span></span><br><span class="line"><span class="attr">setup.template.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">setup.ilm.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>setup.template 和 setup.ilm 相关的操作就是和没移除干净的 xpack 有关系，所以得再配置文件加上这些东西。</p><p>同时也得在 Easysearch 里面开启兼容 ES 的 API，不然会遇到这个报错。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250712125907654-20250712130307504.png" alt="image-20250712125907654"></p><p>在我的 MBP 上是这样：（config&#x2F;easysearch.yml）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">discovery.type:</span> <span class="string">single-node</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">elasticsearch.api_compatibility:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol><li><strong>启动并测试 Filebeat</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start filebeat</span><br><span class="line"><span class="built_in">sudo</span> filebeat <span class="built_in">test</span> output</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>检查服务状态</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status filebeat</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>生成测试日志</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test log <span class="subst">$(date)</span>&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /var/log/messages</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>在 Easysearch 中查询日志</strong>：<br>使用 Dev Tools 执行以下查询：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET filebeat-*/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/bd08bfc218c45c962378117b76933e61.png"></p><p>成功响应示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat-7.10.2-2025.04.18&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XXXXXXX&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-04-29T09:04:09.566Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/log/messages&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test log Fri Apr 29 09:04:00 UTC 2025&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;log&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ecs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.6.0&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>曾经在 ubuntu 上遇到过只要启动 filebeat 就报错一堆内存的信息：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/7a95ae40a701ef3df2d34cd0a560c7c5.png" alt="7a95ae40a701ef3df2d34cd0a560c7c5"></p><p>这个文章给了一个解决办法：</p><p><a href="https://infinilabs.cn/blog/2025/ubuntu_run_filebeat/%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8A%E9%85%8D%E7%BD%AE%E5%92%8C%E6%AD%A5%E9%AA%A4%EF%BC%8C%E6%82%A8%E5%BA%94%E8%AF%A5%E8%83%BD%E5%A4%9F%E6%88%90%E5%8A%9F%E4%BD%BF%E7%94%A8Filebeat">https://infinilabs.cn/blog/2025/ubuntu_run_filebeat/通过以上配置和步骤，您应该能够成功使用Filebeat</a> OSS 7.10.2 版本将日志收集到 Easysearch 中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Filebeat OSS (Open Source Software) 7.10.2 版本是 Elastic 公司提供的开源版本。移除了一些&lt;strong&gt;Elasticsearch&lt;/strong&gt;商业化的功能插件（但是没移出去干净）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/cn/downloads/past-releases/filebeat-oss-7-10-2%E3%80%82&quot;&gt;https://www.elastic.co/cn/downloads/past-releases/filebeat-oss-7-10-2。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这主要还是 AWS 和 Elastic 公司之间的矛盾，AWS 托管的 ES 会和 Elastic 抢客户。所以 Elastic 搞了一个不能商业化的协议，影响了这个生态圈，也给开发者造成了很多不方便。&lt;/p&gt;</summary>
    
    
    
    <category term="极限科技" scheme="https://airag.click/categories/%E6%9E%81%E9%99%90%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="搜索引擎（ES）" scheme="https://airag.click/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%88ES%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（二十）：如何使用 Time Machine 将 Mac 备份到懒猫微服</title>
    <link href="https://airag.click/posts/c5298d72/"/>
    <id>https://airag.click/posts/c5298d72/</id>
    <published>2025-07-10T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>看了 Apple 的文档，时间机器备份到 SMB 或者外接设备（APFS）。正好懒猫微服带了 SMB 的共享。然后我们可以把时间机器备份到网盘里。虽然默认连接的是懒猫网盘根目录，但是我们也可以映射一个子文件夹 TimeMachine。如下：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711074625650.png" alt="image-20250711074625650"></p><span id="more"></span><h4 id="一、-在-Mac-上连接到-SMB-共享"><a href="#一、-在-Mac-上连接到-SMB-共享" class="headerlink" title="一、 在 Mac 上连接到 SMB 共享"></a><strong>一、 在 Mac 上连接到 SMB 共享</strong></h4><ol><li>在 Finder 中，点击菜单栏的 <strong>“前往” (Go)</strong> &gt; **“连接服务器…” (Connect to Server…)**。</li><li>在弹出的窗口中，输入 SMB 共享的地址，格式通常是 <code>smb://[懒猫微服的IP地址或主机名]/[共享文件夹名称]</code>。<ul><li>例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb://192.168.1.100/用户名/timemachine</span><br></pre></td></tr></table></figure></li><li>（域名也可以）</li></ul></li><li>点击“连接”。系统会提示你输入用户名和密码。（懒猫微服的用户密码）<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710205349694.png" alt="image-20250710205349694"><br>成功连接后，你会在 Finder 中看到这个网络共享。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710205328553.png" alt="image-20250710205328553"></li></ol><h4 id="二、-设置-Time-Machine-进行备份"><a href="#二、-设置-Time-Machine-进行备份" class="headerlink" title="二、 设置 Time Machine 进行备份"></a><strong>二、 设置 Time Machine 进行备份</strong></h4><ol><li><p>打开 **“系统设置” (System Settings)**（或旧版 macOS 中的“系统偏好设置”）。</p></li><li><p>点击 <strong>“通用” (General)</strong> &gt; **“时间机器” (Time Machine)**。</p></li><li><p>点击 **“添加备份磁盘…” (Add Backup Disk…)**。</p></li><li><p>在弹出的列表中，你应该能看到你刚刚连接的 SMB 共享文件夹。</p></li><li><p>如果再次提示输入凭据，请再次输入你在懒猫微服上设置的用户名和密码。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/9fb154461fa6adfe4d02abc8540d441d.png" alt="9fb154461fa6adfe4d02abc8540d441d"></p></li></ol><p>Time Machine 会在共享中创建一个特殊的 <code>.sparsebundle</code> 文件，然后开始首次备份。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/2347dfcbdd318a7afe54f46467ea48b3.png" alt="yo"></p><h4 id="三、-解决-Time-Machine-备份变慢的问题"><a href="#三、-解决-Time-Machine-备份变慢的问题" class="headerlink" title="三、 解决 Time Machine 备份变慢的问题"></a><strong>三、 解决 Time Machine 备份变慢的问题</strong></h4><p>在某些情况下，macOS 的默认设置或某些第三方应用程序可能会导致 Time Machine 备份变慢。</p><p><strong>1. 暂时禁用磁盘节流（Disk Throttling）</strong></p><p>macOS 默认会对后台进程（包括 Time Machine）进行磁盘 I&#x2F;O 节流，以确保系统响应速度。在首次备份或需要快速完成备份时，可以暂时禁用此节流。</p><ul><li><strong>操作方法</strong>： 打开“终端”应用程序（位于“应用程序”&gt;“实用工具”），输入以下命令并按回车键：<br><code>bash sudo sysctl debug.lowpri_throttle_enabled=0 </code><br>输入管理员密码后，该设置会立即生效。请注意，这会使 Time Machine 占用更多系统资源，可能影响 Mac 在备份期间的流畅性。备份完成后，建议通过以下命令重新启用节流：<br><code>bash sudo sysctl debug.lowpri_throttle_enabled=1 </code><br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/e32943d816fa309bbdc6c67f67ae80d7.png" alt="e32943d816fa309bbdc6c67f67ae80d7"><br><strong>2. 检查和禁用干扰备份的应用程序</strong></li></ul><p>某些应用程序，特别是防病毒软件、系统清理工具或文件同步工具，可能会频繁访问磁盘，从而干扰 Time Machine 的正常运行。</p><ul><li><strong>操作方法</strong>： 尝试在 Time Machine 备份期间暂时禁用这些应用程序，或者检查它们的设置，看是否可以将 Time Machine 备份盘从其扫描范围中排除。</li></ul><p><strong>3. 确保 Mac 保持唤醒状态</strong></p><p>对于大型备份，如果 Mac 进入睡眠状态，可能会中断或减慢备份进程。</p><ul><li><strong>操作方法</strong>： 在备份期间，你可以前往“系统设置”&gt;“显示器”（或“节能”）调整显示器关闭时间和电脑睡眠设置，或使用 <code>caffeinate</code> 命令让 Mac 保持唤醒：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caffeinate -s -m -i -t 36000 &amp;</span><br></pre></td></tr></table></figure>此命令将使 Mac 在 10 小时内（36000 秒）保持唤醒，<code>&amp;</code> 符号表示在后台运行。</li></ul><h4 id="四、-查看备份情况"><a href="#四、-查看备份情况" class="headerlink" title="四、 查看备份情况"></a><strong>四、 查看备份情况</strong></h4><p>可以按到我目前磁盘使用了 90 个 G，在时间机器中看到占用 50G。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710205108688.png" alt="image-20250710205108688"></p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711073425325.png" alt="image-20250711073425325"></p><p>在懒猫网盘中也可以看到这个数据。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711072633958.png" alt="image-20250711072633958"></p><p>通过以上步骤，你就可以成功地将你的 Mac 通过 Time Machine 备份到懒猫微服提供的 SMB 共享了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看了 Apple 的文档，时间机器备份到 SMB 或者外接设备（APFS）。正好懒猫微服带了 SMB 的共享。然后我们可以把时间机器备份到网盘里。虽然默认连接的是懒猫网盘根目录，但是我们也可以映射一个子文件夹 TimeMachine。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250711074625650.png&quot; alt=&quot;image-20250711074625650&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    <category term="Apple" scheme="https://airag.click/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十九）：我最喜欢的 RSS 阅读器-FreshRSS</title>
    <link href="https://airag.click/posts/9fd148d9/"/>
    <id>https://airag.click/posts/9fd148d9/</id>
    <published>2025-07-09T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>自建的博客都可以接入 RSS 订阅，我之很喜欢的一款 FreshRSS 在懒猫微服的商店上架了，可以联动一下了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710111228317.png" alt="image-20250710111228317"></p><p>我的博客 RSS 订阅是：<a href="https://cloudsmithy.github.io/atom.xml">https://cloudsmithy.github.io/atom.xml</a></p><p>然后点击左上角的订阅管理，先新建一个分类，然后是输入 RSS 订阅地址即可。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710111327135.png" alt="image-20250710111327135"></p><p>我也添加了懒猫微服王总的博客订阅：<a href="https://manateelazycat.github.io/feed.xml">https://manateelazycat.github.io/feed.xml</a></p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/fdb69d74740805003e9eba315c23c30b.png" alt="fdb69d74740805003e9eba315c23c30b"></p><p>这个是我博客的订阅效果，这样在 PC 和移动端都可以访问了：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710110130424.png" alt="image-20250710110130424"></p><p>那如果想让用其他的软件订阅这个 FreshRSS 呢，在右上角点击设置，然后选择认证，点击允许 API 访问。然后就可以通过抓数据的方式进行访问。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710110209454.png" alt="image-20250710110209454"></p><p>然后回到账户管理，这个时候下面就出来了 API 管理这个选项，设置 token 然后就可以使用了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710110308889.png" alt="image-20250710110308889"></p><p>然后我们访问 API 端点：<a href="https://freshrss/">https://freshrss</a>.&lt;机器名字&gt;.heiyu.space&#x2F;api&#x2F;</p><p>这里可以看到 Google Reader compatible API 和 Fever compatible API。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FreshRSS API endpoints</span><br><span class="line">Google Reader compatible API</span><br><span class="line">Your API address:</span><br><span class="line">https://freshrss.&lt;机器名字&gt;.heiyu.space/api/greader.php</span><br><span class="line">Google Reader API configuration test:</span><br><span class="line">✔️ PASS</span><br><span class="line">Fever compatible API</span><br><span class="line">Your API address:</span><br><span class="line">https://freshrss.micro.&lt;机器名字&gt;.space/api/fever.php</span><br><span class="line">Fever API configuration test:</span><br><span class="line">✔️ PASS</span><br></pre></td></tr></table></figure><p>那接下来使用 fluent-reader 订阅微服里的 FreshRSS。选择 Fever API，输入上边 RSS API 返回的 URL。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/22a10f7d54a372eee2250cd11700ed11.png" alt="22a10f7d54a372eee2250cd11700ed11"></p><p>用户名和密码是登录 FreshRSS 的用户密码，然后端点是 Fever compatible API。（这里没有用到 token）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/776b56ff7038d900f9d7d8c7c08f0b27.png" alt="776b56ff7038d900f9d7d8c7c08f0b27"></p><p>这个就是订阅的效果了。（FreshRSS 夹带私货自动订阅 release）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710113632046.png" alt="image-20250710113632046"></p><p>在 APP 里还挺好看的。（除了 fluent-reader 不支持检索）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/2bb3f4399b86b3d27f86988571d8018b.png" alt="2bb3f4399b86b3d27f86988571d8018b"></p><p>用懒猫微服当作一个 RSS 存储的后端，同时也提供了一个 FreshRSS 的部署版本，很多记忆再也不会丢了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自建的博客都可以接入 RSS 订阅，我之很喜欢的一款 FreshRSS 在懒猫微服的商店上架了，可以联动一下了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250710111228317.png&quot; alt=&quot;image-20250710111228317&quot;&gt;&lt;/p&gt;
&lt;p&gt;我的博客 RSS 订阅是：&lt;a href=&quot;https://cloudsmithy.github.io/atom.xml&quot;&gt;https://cloudsmithy.github.io/atom.xml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后点击左上角的订阅管理，先新建一个分类，然后是输入 RSS 订阅地址即可。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>给传统 NAS 玩家介绍一下懒猫微服</title>
    <link href="https://airag.click/posts/47885d90/"/>
    <id>https://airag.click/posts/47885d90/</id>
    <published>2025-07-09T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.885Z</updated>
    
    <content type="html"><![CDATA[<p>玩过不少 NAS，从最早的黑群晖，威联通开始，后面陆陆续续接触了飞牛，绿联，极空间，UNRAID，EXSI，Proxmox VE，也算有点话语权。</p><p>首先最直观的区别是软件客户端，像群晖，威联通的电脑版客户端是用来发现机器的 IP 地址的，然后后续所有的操作都在浏览器完成，比如新建用户，登录，审计，访问数据，查看监控。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704080937359.png" alt="image-20250704080937359"></p><p>而懒猫微服的所有操作几乎都在客户端完成，网页端更像是一个应用的 Dashboard。然后访问的时候使用域名，配合厂家的穿透服务，无论你是互联网访问还是局域网访问机器，用这一个地址就够了，不再需要在路由器上做端口转发，也基本可以告别自己搭建内网穿透的痛苦了。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704070707399.png" alt="image-20250704070707399"></p><p>还有一个非常主要的是社群，懒猫微服既有官方的大群交流技术，也有 VIP 的小群私人定制。大群里有各式各样的玩家，除了懒猫微服之外大家还会交流各种 Github 的开源项目，Linux 技巧以及电脑外设心得， 然后每天大家都贡献攻略。因为公司 base 在武汉嘛，当然也会有接地气的武汉风情。 VIP 小群会针对个性化的需要做一对一的指导，比如曾经帮我排查了家庭宽带 DNS 污染，UPS 信号干扰，甚至 OpenID Connect (OIDC) 的使用和接入等问题，对于开源软件部署在懒猫上有问题也是尽全力 额度支持，届时可以拉一个小会，然后共享屏幕给他们查看。可以放心的 show linux 命令和飙专业术语啥的。 很多的问题可以在半小时到一个小时就能解决，有时候甚至会更短。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704070841376.png" alt="image-20250704070841376"></p><p>不只是自己写的软件部署上去访问有延迟他们会帮忙排查，而且一些商店里社区用户贡献的开源软件的问题，他们也会帮忙查看并且给出一些解答方式。 毕竟开源软件的 issue 真的不少，他们不会叫你去开 issue 然后漫长的等待，他们会去帮忙追。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704083116697.png" alt="image-20250704083116697"></p><p>而传统 NAS 的社群主要靠的是爱好者自己发起和维护的，有问题在群里问可能最后没有讨论出结果就不了了之了。甚至很多时候都会纠结到底是选 Proxmox VE 还是 EXSI。对于攻略部分，大多是散落在资深用户的个人博客上，比如很多威联通的文章都会发在什么值得买上面。而对于提问能不能得到答案，完全取决于作者用爱发电的程度了。如果商业 NAS 提案例，那么响应时间可能要很久，如果你提简单的案例，那么可能立马有人给你打电话，如果是比较难的问题，可能最后就不了了之了。只能说在服务客户这方面亚马逊是在是开了一个很不好的头，大概是这样：</p><blockquote><p>因为 AWS 负责运行、管理和控制从主机操作系统和虚拟层到服务运营所在设施的物理安全性的组件。客户负责管理来宾操作系统（包括更新和安全补丁）、其他相关应用程序软件以及 AWS 提供的安全组防火墙的配置。客户应该仔细考虑自己选择的服务，因为他们的责任取决于所使用的服务、，这些服务与其 IT 环境的集成以及适用的法律法规。责任共担还为客户提供了部署需要的灵活性和控制力。</p></blockquote><p>所以有时候遇到两个产品交叉的问题，我们一般是很难得到方案，很有可能两方都说这涉及三方产品你需要找对方，我们不了解你这个三方产品，没办法给你方案。而对于三方玩家几乎是没有办法同时把两个产品的售后叫到一起的。无论你是开案例还是拉一个会议，这难度很大很大。</p><p>然后是系统层面的对比，懒猫微服是 基于 debian 优化一套系统，后来又开了 root 权限，所以基本 Linux 能做的事他都能做，更是出厂预置了 dockage，dozzle 这样方面调试 docker 的软件，基本属于开箱即用。甚至我们还能使用 Docker 打包自己的软件然后上架给其他玩家使用，甚至可以对其他人说；</p><blockquote><p>我的懒猫微服教程是中文圈里非常优秀的实战指南。</p><p>我的开发&#x2F;移植软件也有非常多的懒猫用户在使用。</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/6c12c920-1fd4-4300-b9cf-7918026d7c8f.png" alt="6c12c920-1fd4-4300-b9cf-7918026d7c8f"></p><p>而开源的 NAS 基本上大家只玩虚拟机和按照教程配置 Docker，几乎是没有包管理工具的，所以安装的软件很受限。 如果真的想移植应用，那个开发者文档也是不太好看。起码对于普通玩家是真的劝退了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704081028625.png" alt="image-20250704081028625"></p><p>最后一点也就是很重要的一点，关于 APP 访问这块。在从互联网访问这边，传统 NAS 有一个很大的痛点。一个是移动端软件适配不好，还有就是服务多了端口都得自己记住。再加上路由器转发的端口，真的很难记住了。而懒猫微服在移动端和 PC 上的页面几乎是差不多的，所有操作几乎可以在 APP 内部完成。应用商店上架的应用大部分都是 https 的协议和 443 的端口。不用自己做加密同时以及免去了记忆软件信息烦恼，毕竟即使是专业玩家，也不想天天做服务器的运维工作。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704081156422.png" alt="image-20250704081156422"></p><p>普通用户图一个方便。专业用户图一个折腾，然后缺少的就是一个稳定的穿透和传输，精力有限不想自己维护一些底层的东西。买个懒猫微服差不多全能解决了。</p><p>我一直有一个愿望，写一本 NAS 的书，让技术融入到爱好者的生活，技术不是枯燥的理论，当我们遇到问题的时候，才能想清楚他们为什么这么设计。技术人永不为奴。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;玩过不少 NAS，从最早的黑群晖，威联通开始，后面陆陆续续接触了飞牛，绿联，极空间，UNRAID，EXSI，Proxmox VE，也算有点话语权。&lt;/p&gt;
&lt;p&gt;首先最直观的区别是软件客户端，像群晖，威联通的电脑版客户端是用来发现机器的 IP 地址的，然后后续所有的操作都在浏览器完成，比如新建用户，登录，审计，访问数据，查看监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250704080937359.png&quot; alt=&quot;image-20250704080937359&quot;&gt;&lt;/p&gt;
&lt;p&gt;而懒猫微服的所有操作几乎都在客户端完成，网页端更像是一个应用的 Dashboard。然后访问的时候使用域名，配合厂家的穿透服务，无论你是互联网访问还是局域网访问机器，用这一个地址就够了，不再需要在路由器上做端口转发，也基本可以告别自己搭建内网穿透的痛苦了。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="NAS" scheme="https://airag.click/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服开发篇（四）：懒猫微服如何使用 OpenID Connect （OIDC）？（上）</title>
    <link href="https://airag.click/posts/dcc47393/"/>
    <id>https://airag.click/posts/dcc47393/</id>
    <published>2025-07-08T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>OpenID Connect（OIDC）是一个基于 <strong>OAuth 2.0</strong> 的身份认证协议，允许用户使用一个账号（如 Google、微信、Microsoft 账号）登录多个不同的网站或应用，而无需重复注册。我们经常把他和<strong>OAuth 2.0</strong> 混为一谈。</p><p>它主要用于 <strong>身份认证（Authentication）</strong>，而 OAuth 2.0 主要用于 <strong>授权（Authorization）</strong>。简单来说：</p><ul><li><strong>OAuth 2.0</strong> → 让应用能访问你的数据（如获取微信头像），还要自己做用户管理。</li><li><strong>OIDC</strong> → 让应用能确认“你是谁”（如用微信账号登录）</li></ul><p>下面以我的懒猫 ENV 查看器为例，来讲解这个登录流程。</p><p>当你在应用处点击登录就会重定向到登录中心，我们通常管这个叫做身份提供商（IDP），如果是其他的软件有可能是 <strong>“使用 Google 登录”</strong> 或 <strong>“微信登录”</strong> 。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250702210408529.png" alt="image-20250702210408529"></p><p>跳转到认证中心，一般都会提示你是否确认登录，某某应用将要获取登录的权限，查看你的信息。在懒猫微服里这直接点击 Grant Access 即可。在其他的 IDP 中，会让你输入账号密码登录，并同意授权该网站访问你的基本信息（如邮箱、昵称）。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250702210333539.png" alt="image-20250702210333539"></p><p>当 IDP 验证完的身份后，返回一个 <strong>JWT（JSON Web Token）</strong>，其中包含你的身份信息。当网站验证 JWT 后，确认你的身份，并让你登录成功。我们也可以在 jwt.io 和 jwt.ms 这个网站去做解码。</p><p>我解码了其中一个 token，我们可以看到里面的信息，可以看到加密算法，颁发机构，过期时间，用户信息什么的，</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250702212449226.png" alt="image-20250702212449226"></p><p>这个是一般登录的流程，比如首次用户名和密码登录成功之后会返回一个 JWT，然后后续把这个 JWT 当做 bear token 来请求后面的资源。我们的 OIDC 和这个原理类似，只不过稍微复杂一些。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/7aed62612920d1042f175cb87c1f049e.png" alt="7aed62612920d1042f175cb87c1f049e"></p><p>在 <code>OIDC</code> 协议中，会遇到三种 Token: <code>id_token</code>, <code>access_token</code> 和 <code>refresh_token</code>。</p><ol><li><p>Access Token 用于基于 Token 的认证模式，允许应用访问一个资源 API。用户认证授权成功后，Authing 会签发 Access Token 给应用。应用后面就带着这个** Access Token** 访问资源 API。</p></li><li><p>ID Token 相当于用户的身份凭证，开发者的前端访问后端接口时可以携带 <strong>ID Token</strong>，<strong>开发者服务器</strong>可以校验用户的 <strong>ID Token</strong> 以确定用户身份，<a href="https://docs.authing.cn/v2/guides/faqs/how-to-validate-user-token.html">验证</a>通过后返回相关资源。</p></li></ol><p>AccessToken 和 IdToken 都是 JWT，<strong>有效时间</strong>通常较短。通常用户在获取资源的时候需要携带 AccessToken，当 AccessToken 过期后，用户需要获取一个新的 AccessToken。</p><ol start="3"><li>Refresh Token 用于获取新的 AccessToken。这样可以缩短 AccessToken 的过期时间保证安全，同时又不会因为频繁过期重新要求用户登录。用户在初次认证时，Refresh Token 会和 AccessToken、IdToken 一起返回。应用携带 Refresh Token 向 Token 端点发起请求时，这个时候会续签 AccessToken 和 IdToken 与 ID token。</li></ol><p>所以我们一般说的 JWT 就是 Access Token 的部分用于授权。而<strong>ID Token</strong> 用户标注用户信息，Refresh Token 用来续签 Access Token 。</p><p>在懒猫微服上使用 OIDC 有一个好处就是，不用在 IDP 上填写申请信息，在程序运行过程中可以直接注入相应的环境变量，这样我们直接用就可以了。相当于传统 IDP 需要填写应用名称，做分组控制而言，这个自动注入的 OIDC 开箱即用很方便。</p><p>一般是有这几个信息：</p><ol><li>CLIENT_ID：从我的 app 来看，这个就是包名</li><li>CLIENT_SECRET： 这个是随机的</li><li>ISSUER_URI：https:&#x2F;&#x2F;微服域名&#x2F;sys&#x2F;oauth</li><li>TOKEN_URI：https:&#x2F;&#x2F;微服域名&#x2F;sys&#x2F;oauth&#x2F;token</li><li>USERINFO_URI：https:&#x2F;&#x2F;微服域名&#x2F;sys&#x2F;oauth&#x2F;userinfo</li></ol><p>先说 ISSUER_URI，这个是 OIDC 的入口，其中.well-known&#x2F;openid-configuration 里可以拿到各种 URL，算是 OIDC 的入口，即使环境变量中没给信息我们也可以在这里查看。比如用来校验 JWT 的 jwks_uri。</p><p>GET https:&#x2F;&#x2F;&lt;微服域名&gt;&#x2F;sys&#x2F;oauth&#x2F;.well-known&#x2F;openid-configuration 结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;issuer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;authorization_endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/auth&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/token&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jwks_uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/keys&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userinfo_endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/userinfo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;device_authorization_endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/device/code&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;introspection_endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://&lt;name&gt;.heiyu.space/sys/oauth/token/introspect&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;grant_types_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;authorization_code&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;refresh_token&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;urn:ietf:params:oauth:grant-type:device_code&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;urn:ietf:params:oauth:grant-type:token-exchange&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;response_types_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;code&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;subject_types_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;public&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id_token_signing_alg_values_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;RS256&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code_challenge_methods_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;S256&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plain&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scopes_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;openid&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;email&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;groups&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;profile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;offline_access&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token_endpoint_auth_methods_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;client_secret_basic&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;client_secret_post&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;claims_supported&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;iss&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;sub&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;aud&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;iat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;exp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;email&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;email_verified&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;locale&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;preferred_username&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;at_hash&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>至于回调 URL，这个是需要自己设置的部分。可能由于开发习惯导致每个应用的回调 URL 不一样。相对于在 IDP 中填写信息，在懒猫微服的 lzc-manifest.yml 中加这么一行即可。也只有设置了 application.oidc_redirect_path 之后，才能使用 OIDC 相关的环境变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">application.oidc_redirect_path:</span> <span class="string">/callback</span></span><br></pre></td></tr></table></figure><p>可以看看我的懒猫 ENV 查看器的设置。通过 oidc_redirect_path 设置回调地址，然后使用 environment 字段还这是需要的环境变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lzc-sdk-version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">懒猫ENV查看器</span></span><br><span class="line"><span class="attr">package:</span> <span class="string">xu.deploy.env</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">license:</span> <span class="string">https://choosealicense.com/licenses/mit/</span></span><br><span class="line"><span class="attr">homepage:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">xu</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">env</span></span><br><span class="line">  <span class="attr">oidc_redirect_path:</span> <span class="string">/callback</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/=exec://5005,./lzcapp/pkg/content/run.sh</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_CLIENT_ID=$&#123;LAZYCAT_AUTH_OIDC_CLIENT_ID&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_CLIENT_SECRET=$&#123;LAZYCAT_AUTH_OIDC_CLIENT_SECRET&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_AUTH_URI=$&#123;LAZYCAT_AUTH_OIDC_AUTH_URI&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_TOKEN_URI=$&#123;LAZYCAT_AUTH_OIDC_TOKEN_URI&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_USERINFO_URI=$&#123;LAZYCAT_AUTH_OIDC_USERINFO_URI&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">LAZYCAT_AUTH_OIDC_ISSUER_URI=$&#123;LAZYCAT_AUTH_OIDC_ISSUER_URI&#125;</span></span><br></pre></td></tr></table></figure><p>然后我们来看 OIDC 的几种授权模式。</p><table><thead><tr><th align="left">应用类型</th><th align="left">授权模式</th></tr></thead><tbody><tr><td align="left">有后端场景</td><td align="left">授权码模式</td></tr><tr><td align="left">SPA，无后端</td><td align="left">隐式模式</td></tr><tr><td align="left">应安全存储密钥</td><td align="left">密码模式</td></tr><tr><td align="left">服务器之间</td><td align="left">Client Credentials</td></tr></tbody></table><p>这个是 Authing 推荐的选择方式，不过据我的经验来讲，就 Web 开发而言大多还是选择隐式授权的居多。看的出来懒猫的 OIDC 也是用的这种。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/7c23a4d3-edef-4873-af13-ac75a1ab1094.png" alt="7c23a4d3-edef-4873-af13-ac75a1ab1094"></p><p>懒猫微服也是用的授权码模式, 所以跳转的时候我们抓浏览器请求会看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://url/callback?code=xxxx</span><br></pre></td></tr></table></figure><p>其实一个良好的 OIDC 流程是这样的：</p><ol start="0"><li><p>当访问没有权限的路由的时候，在路由守卫中重定向到登录页面。</p></li><li><p>当用户登录的时候，跳转到对应的的 IDP 控制页面，然后输入用户凭证。这个时候会走 IDP 的认证。</p></li><li><p>认证之后会颁发一次性 code（授权码模式），如果是简单的密码模式，那么就会直接返回 Access Token，ID token 以及 refresh token。</p></li><li><p>使用授权码 code 换取 AccessToken、IdToken 以及 refresh token。授权码模式的好处是，把真正的令牌藏在后端交换，只暴露一次性 code，从而极大降低令牌泄露和被滥用的风险。</p></li><li><p>最后我们再用 AccessToken 来访问资源。</p></li></ol><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/98e71384-dfcb-426b-9f6e-3190f4e09701.png" alt="98e71384-dfcb-426b-9f6e-3190f4e09701"></p><p>以上是基于懒猫的 OpenID Connect （OIDC）的理论讲解的部分，后面我们会进行实操，手把手创建可以接入 OIDC 的应用。</p><p>备注：关于部分 OIDC 的图文来自 Authing 文档。</p><p><a href="https://docs.authing.cn/v2/concepts/oidc/choose-flow.html">https://docs.authing.cn/v2/concepts/oidc/choose-flow.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenID Connect（OIDC）是一个基于 &lt;strong&gt;OAuth 2.0&lt;/strong&gt; 的身份认证协议，允许用户使用一个账号（如 Google、微信、Microsoft 账号）登录多个不同的网站或应用，而无需重复注册。我们经常把他和&lt;strong&gt;OAuth 2.0&lt;/strong&gt; 混为一谈。&lt;/p&gt;
&lt;p&gt;它主要用于 &lt;strong&gt;身份认证（Authentication）&lt;/strong&gt;，而 OAuth 2.0 主要用于 &lt;strong&gt;授权（Authorization）&lt;/strong&gt;。简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OAuth 2.0&lt;/strong&gt; → 让应用能访问你的数据（如获取微信头像），还要自己做用户管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OIDC&lt;/strong&gt; → 让应用能确认“你是谁”（如用微信账号登录）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以我的懒猫 ENV 查看器为例，来讲解这个登录流程。&lt;/p&gt;
&lt;p&gt;当你在应用处点击登录就会重定向到登录中心，我们通常管这个叫做身份提供商（IDP），如果是其他的软件有可能是 &lt;strong&gt;“使用 Google 登录”&lt;/strong&gt; 或 &lt;strong&gt;“微信登录”&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="开发" scheme="https://airag.click/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>京东售后拒修 AirPods 称&quot;无问题&quot;，苹果官方检测后直接换新！京东竟删除检测记录？</title>
    <link href="https://airag.click/posts/c67acea7/"/>
    <id>https://airag.click/posts/c67acea7/</id>
    <published>2025-07-08T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.890Z</updated>
    
    <content type="html"><![CDATA[<p>去年在京东买的 Airpod Pro2 售后记录，以前都是在官网买的，还是图省事了。结果闹了个哭笑不得。</p><p>故障问题是，只有一边的耳机有声音，于是京东寄修，得到的答案是没问题，直接给我原反了。然后后台给我一个一张检测单（请记住这个，后面京东后台竟然把这个删了）</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250709052850888.png" alt="image-20250709052850888"></p><p>所谓京东的人给我打电话，是沈阳口音，然后听起来就是一点不懂技术的样子。说耳机是固件的 bug，然后直接把固件降级然后就好了。</p><p>然后我直接三连问：</p><ol><li>airpod 的固件是自动升级的，用户没办法干预，怎么保证下次自动升级不会再有问题？</li><li>有没有什么硬件问题？有时候合上盖子还有声音？</li><li>有时候一个耳机掉电快，另外一个基本满电能不能看一看？</li></ol><p>口头说好找人看，然后耳机直接给寄回来了，没有任何后续。</p><p>京东 Apple 里的耳机检测图片，一看就很不专业，像是某种小店。一口一个有苹果官方的人员主场，一口一个不解决问题，怕不是外包 hhh</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/9787159f629105169a842120863bc4ed.jpg" alt="9787159f629105169a842120863bc4ed"></p><p>但是，寄回来的耳机仍然是一样的问题。再次申请售后是不予受理。理由是上一次检测没有问题，让我去 Apple 线下自行解决。从普通客服到专员，再到所谓的客服经理无一不如此。真是，体验简直太差。那就让我去 Apple 直营店打你们的脸吧。</p><p>去了 Apple 三里屯，检测确实有硬件问题，左耳机收音有问题，右耳机能隔着盒子放出来声音，于是给换新了。贴一下检测单。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250709055342011.png" alt="image-20250709055342011"></p><p>然后继续去京东 battle，说 apple 给换新了，你们京东为啥检测不出来。然后仍然是不予受理，继续装死。然后默默的把之前检测没问题的单子给删除了。（最前面的一张）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250709055117286.png" alt="image-20250709055117286"></p><p>这里的红框圈起来的部分，本来是原来那个检测单的，后来竟然给删了，销毁证据，京东你真行。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250709055010618.png" alt="image-20250709055010618"></p><p>以后电子产品大件还怎么放心在京东买啊？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年在京东买的 Airpod Pro2 售后记录，以前都是在官网买的，还是图省事了。结果闹了个哭笑不得。&lt;/p&gt;
&lt;p&gt;故障问题是，只有一边的耳机有声音，于是京东寄修，得到的答案是没问题，直接给我原反了。然后后台给我一个一张检测单（请记住这个，后面京东后台竟然把这个删了）&lt;/p&gt;</summary>
    
    
    
    <category term="Apple" scheme="https://airag.click/categories/Apple/"/>
    
    
    <category term="Apple" scheme="https://airag.click/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服开发篇（三）：如何将已有 Docker Compose 应用移植到懒猫微服</title>
    <link href="https://airag.click/posts/5e5f8aaa/"/>
    <id>https://airag.click/posts/5e5f8aaa/</id>
    <published>2025-07-07T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文延续前两篇，演示如何把一个已经在本地运行良好的 Docker Compose 应用打包并上架到懒猫微服应用商店。以 Milvus 为例，逐步拆解 Manifest 配置、路由映射、数据卷绑定以及镜像加速等关键环节，帮助大家快速完成移植。</p></blockquote><h3 id="1-目录结构与核心文件"><a href="#1-目录结构与核心文件" class="headerlink" title="1. 目录结构与核心文件"></a>1. 目录结构与核心文件</h3><p>在懒猫微服中，一个最小可用的应用包仅需两个文件：</p><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td><code>lzc-build.yml</code></td><td>描述打包流程及应用图标。简单应用只需指定 <code>icon</code> 即可。</td></tr><tr><td><code>lzc-manifest.yml</code></td><td>定义应用元数据与服务编排，是移植的重点。</td></tr></tbody></table><p>本文主要关注 <code>lzc-manifest.yml</code> 的编写。</p><h3 id="2-lzc-manifest-yml-字段逐一解析"><a href="#2-lzc-manifest-yml-字段逐一解析" class="headerlink" title="2. lzc-manifest.yml 字段逐一解析"></a>2. <code>lzc-manifest.yml</code> 字段逐一解析</h3><p>现在有了懒猫应用查看器很方便，我们以商店里的 Milvus 的示例 Manifest 为例，并附带注释说明。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250702125730816.png" alt="image-20250702125730816"></p><p>这个 lzc-mainfest.yml 解析是重点。主要是 subdomain，ingress，services 这几个字段。总体上还是延续了 Docker compose 的风格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lzc-sdk-version:</span> <span class="string">&quot;0.1&quot;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Milvus</span></span><br><span class="line"><span class="attr">package:</span> <span class="string">in.zhaoj.milvus</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.5</span><span class="number">.8</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">milvus</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="comment"># 子域名：应用上线后将访问 https://milvus.&lt;机器名&gt;.heiyu.space</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">milvus</span></span><br><span class="line">  <span class="attr">background_task:</span> <span class="literal">false</span> <span class="comment"># 是否允许后台运行</span></span><br><span class="line">  <span class="attr">multi_instance:</span> <span class="literal">false</span> <span class="comment"># 是否允许多实例</span></span><br><span class="line">  <span class="attr">gpu_accel:</span> <span class="literal">false</span> <span class="comment"># 是否请求 GPU</span></span><br><span class="line">  <span class="attr">routes:</span> <span class="comment"># 七层（HTTP）路由</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/=http://attu.in.zhaoj.milvus.lzcapp:3000/</span></span><br><span class="line">  <span class="attr">ingress:</span> <span class="comment"># 四层（TCP）转发</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">19530</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">standalone</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 以下基本等同于 docker‑compose 中的 services</span></span><br><span class="line">  <span class="attr">etcd:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lazycat.cloud/longixaoyi/milvusdb/etcd:v3.5.18</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_AUTO_COMPACTION_MODE=revision</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_AUTO_COMPACTION_RETENTION=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_QUOTA_BACKEND_BYTES=4294967296</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_SNAPSHOT_COUNT=50000</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      etcd -advertise-client-urls=http://127.0.0.1:2379</span></span><br><span class="line"><span class="string">           -listen-client-urls http://0.0.0.0:2379</span></span><br><span class="line"><span class="string">           --data-dir /etcd</span></span><br><span class="line"><span class="string"></span>    <span class="attr">binds:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/lzcapp/var/etcd:/etcd</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lazycat.cloud/longixaoyi/milvusdb/minio:RELEASE.2023-03-20T20-16-18Z</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ACCESS_KEY=minioadmin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_SECRET_KEY=minioadmin</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">minio</span> <span class="string">server</span> <span class="string">/minio_data</span></span><br><span class="line">    <span class="attr">binds:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/lzcapp/var/minio_data:/minio_data</span></span><br><span class="line">    <span class="attr">health_check:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">  <span class="attr">standalone:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lazycat.cloud/longixaoyi/milvusdb/milvus:v2.6.0-rc1</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">milvus</span> <span class="string">run</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_ENDPOINTS=etcd:2379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MINIO_ADDRESS=minio:9000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">etcd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">minio</span></span><br><span class="line">    <span class="attr">binds:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/lzcapp/var/milvus:/var/lib/milvus</span></span><br><span class="line">  <span class="attr">attu:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lazycat.cloud/longixaoyi/zilliz/attu:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MILVUS_URL=standalone:19530</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">standalone</span></span><br></pre></td></tr></table></figure><h4 id="2-1-subdomain"><a href="#2-1-subdomain" class="headerlink" title="2.1 subdomain"></a>2.1 <code>subdomain</code></h4><p>subdomain 是应用程序上线的域名，例如上述配置上线后即为 <code>https://milvus.&lt;节点名&gt;.heiyu.space</code>。</p><h4 id="2-2-routes"><a href="#2-2-routes" class="headerlink" title="2.2 routes"></a>2.2 <code>routes</code></h4><p>route 来做七层的 HTTP 转发，类似 Nginx 的反向代理。规则格式为 <code>本地路径 = 目标 URL</code>。在示例中，根路径 <code>/</code> 被转发到前端服务 <code>attu</code> 的 3000 端口。</p><p>URL 规则：服务名.包名.lzcapp:端口。（包名随意起）</p><pre><code>- /=http://attu.in.zhaoj.milvus.lzcapp:3000/</code></pre><p>这里 attu 是服务名，端口是 3000，in.zhaoj.milvus 是包名。</p><h4 id="2-3-ingress"><a href="#2-3-ingress" class="headerlink" title="2.3 ingress"></a>2.3 <code>ingress</code></h4><p>用于四层直通转发，适用于非 HTTP 协议（数据库、SSH 等）。示例将 Milvus 的 gRPC (19530) 与 HTTP (9091) 端口暴露给外部。</p><h4 id="2-4-bind"><a href="#2-4-bind" class="headerlink" title="2.4 bind"></a>2.4 <code>bind</code></h4><p>Manifest 中的绑定路径以 <code>/lzcapp/var</code> 为前缀。发布后会被映射到宿主机的 <code>/data/app/var/&lt;package&gt;</code>，也算是为了简化程序移植和学习成本。和 Docker-compose 写绝对路径来说，这里的可移植性执行更好。</p><p>健康检查在这里不是必须的，因为打包的上架的时候服务会帮忙做这个事情。</p><h3 id="3-服务映射与-docker-compose-yml-对照"><a href="#3-服务映射与-docker-compose-yml-对照" class="headerlink" title="3. 服务映射与 docker-compose.yml 对照"></a>3. 服务映射与 <code>docker-compose.yml</code> 对照</h3><p>懒猫 Manifest 的 <code>services</code> 段几乎一一复刻了传统 Compose 配置，常用键均保持一致。以下列出了 Milvus 官方 <code>docker-compose.yml</code>，方便对照理解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">etcd:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">milvus-etcd</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">quay.io/coreos/etcd:v3.5.18</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_AUTO_COMPACTION_MODE=revision</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_AUTO_COMPACTION_RETENTION=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_QUOTA_BACKEND_BYTES=4294967296</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ETCD_SNAPSHOT_COUNT=50000</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DOCKER_VOLUME_DIRECTORY:-.&#125;/volumes/etcd:/etcd</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">etcd</span> <span class="string">-advertise-client-urls=http://etcd:2379</span> <span class="string">-listen-client-urls</span> <span class="string">http://0.0.0.0:2379</span> <span class="string">--data-dir</span> <span class="string">/etcd</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;etcdctl&quot;</span>, <span class="string">&quot;endpoint&quot;</span>, <span class="string">&quot;health&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">milvus-minio</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:RELEASE.2023-03-20T20-16-18Z</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MINIO_ACCESS_KEY:</span> <span class="string">minioadmin</span></span><br><span class="line">      <span class="attr">MINIO_SECRET_KEY:</span> <span class="string">minioadmin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DOCKER_VOLUME_DIRECTORY:-.&#125;/volumes/minio:/minio_data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">minio</span> <span class="string">server</span> <span class="string">/minio_data</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">standalone:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">milvus-standalone</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">milvusdb/milvus:v2.6.0-rc1</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;milvus&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;standalone&quot;</span>]</span><br><span class="line">    <span class="attr">security_opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">seccomp:unconfined</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ETCD_ENDPOINTS:</span> <span class="string">etcd:2379</span></span><br><span class="line">      <span class="attr">MINIO_ADDRESS:</span> <span class="string">minio:9000</span></span><br><span class="line">      <span class="attr">MQ_TYPE:</span> <span class="string">woodpecker</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DOCKER_VOLUME_DIRECTORY:-.&#125;/volumes/milvus:/var/lib/milvus</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9091/healthz&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">90s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;19530:19530&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;etcd&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;minio&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">milvus</span></span><br></pre></td></tr></table></figure><p>差异点主要体现在：</p><ul><li>镜像源：建议通过 <code>lzc-cli appstore copy-image &lt;image&gt;</code> 把镜像同步到 <code>registry.lazycat.cloud</code>，解决国内网络拉取问题。</li><li>端口声明：在 Manifest 中，外部访问端口通过 <code>ingress</code>，不再使用 Compose 的 <code>ports</code>。</li><li>健康检查：懒猫平台会统一探测容器存活，可按需省略 <code>healthcheck</code>。</li></ul><h3 id="4-镜像加速实践"><a href="#4-镜像加速实践" class="headerlink" title="4. 镜像加速实践"></a>4. 镜像加速实践</h3><p>一条命令即可完成镜像复制并输出新的仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lzc-cli appstore copy-image nginx                                                                                                                           (base) 13:15:36</span><br><span class="line">Waiting ... ( copy nginx to lazycat offical registry)</span><br><span class="line">uploading</span><br><span class="line">23e05839: [####################################################################################################] 100%</span><br><span class="line">23e05839: [####################################################################################################] 100%</span><br><span class="line">23e05839: [####################################################################################################] 100%</span><br><span class="line">3da95a90: [####################################################################################################] 100%</span><br><span class="line">48670a58: [####################################################################################################] 100%</span><br><span class="line">6c8e51cf: [####################################################################################################] 100%</span><br><span class="line">9bbbd7ee: [####################################################################################################] 100%</span><br><span class="line">ce713206: [####################################################################################################] 100%</span><br><span class="line">ee95256d: [####################################################################################################] 100%</span><br><span class="line"></span><br><span class="line">uploaded:  registry.lazycat.cloud/u04123229/library/nginx:d037205fbaf7d60a</span><br></pre></td></tr></table></figure><p>将生成的地址替换到 Manifest 的 <code>image</code> 字段即可。</p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li>Manifest 为核心：<code>lzc-manifest.yml</code> 描述了全部运行时需求，移植时优先完善此文件。</li><li>路由分层：<code>routes</code> 管理 HTTP，<code>ingress</code> 管理 TCP，二者配合即可覆盖绝大多数场景。</li><li>统一数据目录：使用 <code>/lzcapp/var</code> 避免硬编码路径，便于跨节点迁移。</li><li>镜像国内托管：通过 <code>lzc-cli appstore copy-image</code> 自动同步到 LazyCat Registry，稳定又快速。</li></ul><p>至此，Milvus 的 Docker Compose 应用已成功移植到懒猫微服。更多进阶玩法，例如 OIDC、VNC 集成等，我们将在后续文章继续分享。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文延续前两篇，演示如何把一个已经在本地运行良好的 Docker Compose 应用打包并上架到懒猫微服应用商店。以 Milvus 为例，逐步拆解 Manifest 配置、路由映射、数据卷绑定以及镜像加速等关键环节，帮助大家快速完成移植。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-目录结构与核心文件&quot;&gt;&lt;a href=&quot;#1-目录结构与核心文件&quot; class=&quot;headerlink&quot; title=&quot;1. 目录结构与核心文件&quot;&gt;&lt;/a&gt;1. 目录结构与核心文件&lt;/h3&gt;&lt;p&gt;在懒猫微服中，一个最小可用的应用包仅需两个文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lzc-build.yml&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;描述打包流程及应用图标。简单应用只需指定 &lt;code&gt;icon&lt;/code&gt; 即可。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lzc-manifest.yml&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义应用元数据与服务编排，是移植的重点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;本文主要关注 &lt;code&gt;lzc-manifest.yml&lt;/code&gt; 的编写。&lt;/p&gt;
&lt;h3 id=&quot;2-lzc-manifest-yml-字段逐一解析&quot;&gt;&lt;a href=&quot;#2-lzc-manifest-yml-字段逐一解析&quot; class=&quot;headerlink&quot; title=&quot;2. lzc-manifest.yml 字段逐一解析&quot;&gt;&lt;/a&gt;2. &lt;code&gt;lzc-manifest.yml&lt;/code&gt; 字段逐一解析&lt;/h3&gt;&lt;p&gt;现在有了懒猫应用查看器很方便，我们以商店里的 Milvus 的示例 Manifest 为例，并附带注释说明。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="开发" scheme="https://airag.click/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高版本的MacOS如何降级？</title>
    <link href="https://airag.click/posts/5b6f9bd/"/>
    <id>https://airag.click/posts/5b6f9bd/</id>
    <published>2025-07-07T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.891Z</updated>
    
    <content type="html"><![CDATA[<p>很早问过Apple客服MacOS的降级机制，半天也没说明白。但是M芯片的Macbook经常崩溃，如果说windows的蓝屏时，那我这个MacBook就能崩溃出彩虹色。</p><p>寻找过Apple支持，答案就是升级系统。Apple的行政关系团队给我找了一个非常不靠谱的人，一问三不知，问她什么就是再转问工程团队，然后所有的事情都推第三方软件。然后行政关系团队陈某说对技术不做评价，然后一再坚持他们的人都是专业培训上岗的，然后坚持不换人，坚持不解决电脑问题来给客户扣不配合的帽子。</p><span id="more"></span><p>然后一直拖到过保。以前iphone接不到电话是这样，现在Macbook还是这样。</p><p>言归正传。Mac刷机一般几种办法。</p><ol><li>U盘刷机，这个是传统了，玩过PE的都懂。</li><li>系统内格式化：就跟手机差不多的那种。个人感觉不彻底。</li><li>DFU刷机：需要你有另外一个MacOS的电脑。类似于安卓线刷。</li></ol><p>MacOS降级我采用的是U盘装机。参考这个帖子</p><p><a href="https://support.apple.com/zh-cn/101578">https://support.apple.com/zh-cn/101578</a></p><p>从Apple Store下载OS，然后把U盘的label改成&#x2F;Volumes&#x2F;MyVolume，最后做随身碟</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250708203135382.png" alt="image-20250708203135382"></p><p>可以选择各个MacOS大版本的最后的release。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250708203344815.png" alt="image-20250708203344815"></p><p>烧录命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /Applications/Install\ macOS\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure><p>如果需要其他的系统，那么换一个版本号即可。</p><p>我的23年的M2 Pro，当时出长的时候是MacOS13 Ventura，所以当我想换回MacOS12的时候下载都报错。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250708203409606.png" alt="image-20250708203409606"></p><p>如果直接安装还会报错：这个卷无法降级。（不理解这个操作，windows的话随便格式化）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/de83700ed1e47e0386ebf756f594c4d3.jpg" alt="de83700ed1e47e0386ebf756f594c4d3"></p><p>需要进入磁盘工具降级：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/v2-674c2048221fed20e5536c5aa67ff964_1440w.webp" alt="img"></p><p>然后安装就可可以了，剩下就是漫长的等待。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250708203801861.png" alt="image-20250708203801861"></p><p>从Intel黑苹果时代走过来的，结果白的还没黑的好用。。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早问过Apple客服MacOS的降级机制，半天也没说明白。但是M芯片的Macbook经常崩溃，如果说windows的蓝屏时，那我这个MacBook就能崩溃出彩虹色。&lt;/p&gt;
&lt;p&gt;寻找过Apple支持，答案就是升级系统。Apple的行政关系团队给我找了一个非常不靠谱的人，一问三不知，问她什么就是再转问工程团队，然后所有的事情都推第三方软件。然后行政关系团队陈某说对技术不做评价，然后一再坚持他们的人都是专业培训上岗的，然后坚持不换人，坚持不解决电脑问题来给客户扣不配合的帽子。&lt;/p&gt;</summary>
    
    
    
    <category term="Apple" scheme="https://airag.click/categories/Apple/"/>
    
    
    <category term="Apple" scheme="https://airag.click/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十八）：用 planka 做项目管理</title>
    <link href="https://airag.click/posts/51800531/"/>
    <id>https://airag.click/posts/51800531/</id>
    <published>2025-07-06T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>工作里用 Jira 管理项目进度。家里也是想找个类似的软件来管理一些长期的事情，如果能带一多人合作的功能就更好了。在网上找了很久也没有太好用的，直到在懒猫微服中找到 planka，在对比了几个同类型的软件之后，决定使用这个软件来管理自己的一些事情。</p><span id="more"></span><p>其他的软件体验不佳的点主要是：</p><ol><li>付费：还都是订阅制，没有找到终身制的软件</li><li>界面太丑，操作太复杂</li><li>Saas 免费版本延迟太高</li><li>移动端访问体验不佳</li></ol><p>Planka 算是解决了大部分的问题：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250706142600994.png" alt="image-20250706142600994">虽然这个页面不是很现代化风格，但是也不丑，页面响应速度很快。而其他软件大多臃肿体验不佳，要么就是延迟的很高耽误体验。</p><p>简介的 UI 和快速的响应很好的诠释了 less is more 的原则。</p><p>进入主页之后可以新建多个项目，算是一个隔离吧，虽然我目前也只是用到了一个。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250706140800760.png" alt="image-20250706140800760"></p><p>每一个 Project 都能开好几个 board，这样就把不同类别的事情跟区分开了。</p><p>然后每个 board 上标注 Todo，Doing，Pending，Done，Deprecated 来确认事情的进度。有点白版卡片的那个味道了，不用自己像线下那种写贴纸来回移动，也不用再花费软件的订阅的费用。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/103a3a28-0ceb-466d-9d96-50161d150b04.png" alt="103a3a28-0ceb-466d-9d96-50161d150b04"></p><p>这个是我和前端协作开发时候一起做的 Dashboard，当时在一起开发一个前后端分离的大语言模型的 APP。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/8703083443e36972236a8450eab7c1c7.png" alt="8703083443e36972236a8450eab7c1c7"></p><p>只要给他新建一个用户就可以了，然后分给他某个面板的权限，然后就可以可以一起愉快的协作了。（前提给他安装了懒猫微服的客户端，分了 app 权限）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250706145557778.png" alt="image-20250706145557778"></p><p>这个是面板的详细参数，可以把 task 分配给某个成员，然后也可以添加 task 描述，task 子任务拆解以及成员评论，拿来记录一些 change log 还是不错的，起码测试的一些过程可以随手记录在这里了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250706140941967.png" alt="image-20250706140941967"></p><p>Dashboard 功能还需要继续探索，比如计时，打标签一些的功能。</p><p>不过我目前用到的功能就这么多，也算能基本覆盖全部的场景了。</p><p>这个是我用 planka 来追踪关于懒猫微服的写作和上架应用的一些事情，真的帮助了我很多很多。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250707080727189.png" alt="image-20250707080727189"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作里用 Jira 管理项目进度。家里也是想找个类似的软件来管理一些长期的事情，如果能带一多人合作的功能就更好了。在网上找了很久也没有太好用的，直到在懒猫微服中找到 planka，在对比了几个同类型的软件之后，决定使用这个软件来管理自己的一些事情。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://airag.click/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服开发篇（二）：远程调试之 Devshell</title>
    <link href="https://airag.click/posts/2c167bb4/"/>
    <id>https://airag.click/posts/2c167bb4/</id>
    <published>2025-07-06T16:00:00.000Z</published>
    <updated>2025-07-20T12:05:44.884Z</updated>
    
    <content type="html"><![CDATA[<p>我们上一篇讲述了如何打包上架 APP，这期我们就来看如何远程调试即将上架的 APP。</p><p>简单来讲，这个 devshell 其实就是在微服上打开了一个虚拟机环境，然后我们可以进去里面测试我们的命令。非要说技术实现，那就是 docker exec 了。只不过是做成了本地和微服之间同步的样子。</p><p>输入微服的名字&#x2F;v2&#x2F;_catalog，可以看到微服里面 Docker 仓库存放的镜像，debug.bridge 开头的就是 devshell 的 image。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;repositories&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;debug.bridge/231ee20d4e4d8edbd2004e7609fd9c15&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;debug.bridge/ddc6dbf609125b7bd2c0efb0ed4254d1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 lzc-build.yml 里定义了 devshell 的配置，这个的意思是就是安装 node 和 python 的环境，设置国内源，然后讲根目录转发到 5173，这个是 vue 的端口。所以我们可以推断，这个是一个 Vue+python 的全栈项目，所以我们可以开两个终端来进入 devshell，分别调试前后端。</p><span id="more"></span><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devshell:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/=http://127.0.0.1:5173</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodejs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">py3-pip</span></span><br><span class="line">  <span class="attr">setupscript:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    export npm_config_registry=https://registry.npmmirror.com</span></span><br><span class="line"><span class="string">    export PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure><p>使用 lzc-cli project devshell -f 进入 devshell，可以看到这个使用了 registry.lazycat.cloud&#x2F;lzc-cli&#x2F;devshell 作为 base image，然后换源安装依赖。最后设置 setupscript 里面的 ENV。而 CMD [“sleep”, “infinity”]<code>会让容器启动后执行</code>sleep infinity&#96; 命令，即无限休眠。目的是防止容器因没有前台进程而自动退出（保持容器处于“运行”状态）。</p><p>这里有个问题，如果你在 lzc-manifest.yml 里指定了 routes 也同样会生效。如果你要跑一些初始化脚本，可以在使用这两个办法</p><ol><li>在 lzc-manifest.yml 文件中使用&#x2F;api&#x2F;&#x3D;exec:&#x2F;&#x2F;3000,.&#x2F;lzcapp&#x2F;pkg&#x2F;content&#x2F;backend&#x2F;run.sh</li><li>lzc-build.yml 中注入脚本 setupscript。</li></ol><p>如果你偷懒在 lzc-build.yml 里 routes 的执行&#x2F;api&#x2F;&#x3D;exec:&#x2F;&#x2F;3000,.&#x2F;lzcapp&#x2F;pkg&#x2F;cache&#x2F;backend&#x2F;run.sh，似乎也只能转发端口，不能运行脚本。</p><p>从日志看，也就是说还是安装了一个应用程序上去，只不过我们可以通过类似 ssh remote 的方式来动态调试。如果 APP 上架之后，能做的恐怕只有 lzc-docker exec 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">跳过执行 buildscript</span><br><span class="line">跳过拷贝 contentdir 内容</span><br><span class="line"></span><br><span class="line">Dockerfile</span><br><span class="line">STEP 1/4: FROM registry.lazycat.cloud/lzc-cli/devshell:v0.0.5</span><br><span class="line">STEP 2/4: RUN sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27; /etc/apk/repositories</span><br><span class="line">--&gt; Using cache 2302149ded79afb639f9935a07e7ea0d63b5644b10e9890d49ad06786e7b31db</span><br><span class="line">--&gt; 2302149ded79</span><br><span class="line">STEP 3/4: RUN apk add --no-cache bash nodejs npm py3-pip python3   &amp;&amp; echo &quot;root:root&quot; | chpasswd</span><br><span class="line">--&gt; Using cache 9bb679fa2c9d10ab1a2433be4c59c852affb2a6844c62ecd9eb8d727505821fb</span><br><span class="line">--&gt; 9bb679fa2c9d</span><br><span class="line">STEP 4/4: CMD [&quot;sleep&quot;, &quot;infinity&quot;]</span><br><span class="line">--&gt; Using cache 5ed701af0e0f7040c3dc5409f547b271b4f4e792fd4fcbfc4af8a3abecf8d363</span><br><span class="line">COMMIT debug.bridge/ddc6dbf609125b7bd2c0efb0ed4254d1:latest</span><br><span class="line">--&gt; 5ed701af0e0f</span><br><span class="line">Successfully tagged debug.bridge/ddc6dbf609125b7bd2c0efb0ed4254d1:latest</span><br><span class="line">5ed701af0e0f7040c3dc5409f547b271b4f4e792fd4fcbfc4af8a3abecf8d363</span><br><span class="line">Getting image source signatures</span><br><span class="line">Copying blob sha256:c164879b06ca56693b742ec917059cce495320d4d8f6140bde7e875f53377ea1</span><br><span class="line">Copying blob sha256:69bc8c25bce956e4c34fdfee091c531ffa8660454526ea9f76c956f9b930c57b</span><br><span class="line">Copying blob sha256:98e60e58e2d093fd95b5d5d61ae6dac25bff89ba1b46d42395d480dfb75bddab</span><br><span class="line">Copying blob sha256:d4fc045c9e3a848011de66f34b81f052d4f2c15a17bb196d637e526349601820</span><br><span class="line">Copying blob sha256:b244bd08b327b00bfbbbbf4f424ade914ee891a52d9192a573dbe484e22d86ab</span><br><span class="line">Copying config sha256:5ed701af0e0f7040c3dc5409f547b271b4f4e792fd4fcbfc4af8a3abecf8d363</span><br><span class="line">Writing manifest to image destination</span><br><span class="line">输出lpk包 /Users/xu/Desktop/todolist-py-lzcapp-demo/cloud.lazycat.app.todolistpy-v0.0.1.lpk</span><br><span class="line">开始部署应用</span><br><span class="line">开始安装应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装成功！</span><br><span class="line">👉 请在浏览器中访问 https://todolistpy.dev.heiyu.space</span><br><span class="line">👉 并使用微服的用户名和密码登录</span><br><span class="line"></span><br><span class="line">+ export &#x27;npm_config_registry=https://registry.npmmirror.com&#x27;</span><br><span class="line">+ export &#x27;PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple&#x27;</span><br><span class="line">+ set -e</span><br><span class="line">+ mkdir -p /lzcapp/cache/devshell</span><br><span class="line"></span><br><span class="line">+ cd /lzcapp/cache/devshell</span><br><span class="line">+ exec /bin/sh</span><br><span class="line">/lzcapp/cache/devshell #</span><br><span class="line">/lzcapp/cache/devshell # ls</span><br><span class="line">README.md         backend           build.sh          lzc-build.yml     lzc-icon.png      lzc-manifest.yml  ui</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到文件夹的内容已经被同步过来了，我们可以实时同步开发机文件的创建和修改。不过目前和移动，重命名相关的同步有点小问题，具体表现为</p><ol><li>本地删除旧的文件，但是 devshell 里不会同步删除</li><li>删除文件 a，但是把 b 重名为 a，devshell 不会同步更改（但是删除 a 重建可以）</li></ol><p>相信这两个小问题修好也只是时间问题，当然也有 workaround。</p><p>从&#x2F;data&#x2F;app&#x2F;cache&#x2F;包名这个目录删除 devshell 文件夹之后，然后重新执行 lzc-cli project devshell -f ，这样工作区就被清理干净了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) lzcbox-029c588e /data/app/cache/cloud.lazycat.app.todolistpy <span class="comment"># ls</span></span><br><span class="line">devshell</span><br><span class="line">(base) lzcbox-029c588e /data/app/cache/cloud.lazycat.app.todolistpy <span class="comment"># cd devshell/</span></span><br><span class="line">(base) lzcbox-029c588e /data/app/cache/cloud.lazycat.app.todolistpy/devshell <span class="comment"># ls</span></span><br><span class="line">1  1312  README.md  backend  build.sh  lzc-build.yml  lzc-icon.png  lzc-manifest.yml  ui</span><br></pre></td></tr></table></figure><p>另外，我们再通过 ssh 进入&#x2F;data&#x2F;app 这个目录，有两个子文件夹，一个叫做 cache，一个叫做 var。 cache 就是我们这个 devshell 的工作区。var 就是数据持久化的目录。如果在这里新建一个目录，那么就可以在网盘里实时看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/app/var/xu.deploy.lazycat-nav <span class="comment"># touch test</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250702063901802.png" alt="image-20250702063901802"></p><p>以上就是 devshell 的全部内容了，如果你需要借助微服的一些特性还进行开发，比如获取环境变量，OIDC 什么的，可以用这个方法来轻松调试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们上一篇讲述了如何打包上架 APP，这期我们就来看如何远程调试即将上架的 APP。&lt;/p&gt;
&lt;p&gt;简单来讲，这个 devshell 其实就是在微服上打开了一个虚拟机环境，然后我们可以进去里面测试我们的命令。非要说技术实现，那就是 docker exec 了。只不过是做成了本地和微服之间同步的样子。&lt;/p&gt;
&lt;p&gt;输入微服的名字&amp;#x2F;v2&amp;#x2F;_catalog，可以看到微服里面 Docker 仓库存放的镜像，debug.bridge 开头的就是 devshell 的 image。&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&amp;quot;repositories&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;punctuation&quot;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;debug.bridge/231ee20d4e4d8edbd2004e7609fd9c15&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;debug.bridge/ddc6dbf609125b7bd2c0efb0ed4254d1&amp;quot;&lt;/span&gt;&lt;span class=&quot;punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;punctuation&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 lzc-build.yml 里定义了 devshell 的配置，这个的意思是就是安装 node 和 python 的环境，设置国内源，然后讲根目录转发到 5173，这个是 vue 的端口。所以我们可以推断，这个是一个 Vue+python 的全栈项目，所以我们可以开两个终端来进入 devshell，分别调试前后端。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://airag.click/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="开发" scheme="https://airag.click/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
