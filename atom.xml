<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>镜湖</title>
  
  
  <link href="https://xu-hardy.github.io/atom.xml" rel="self"/>
  
  <link href="https://xu-hardy.github.io/"/>
  <updated>2025-06-30T12:13:48.963Z</updated>
  <id>https://xu-hardy.github.io/</id>
  
  <author>
    <name>Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>懒猫微服开发篇（一）：懒猫微服全栈上架指南，一步打包，一键发布</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%BC%80%E5%8F%91%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%85%A8%E6%A0%88%E4%B8%8A%E6%9E%B6%E6%8C%87%E5%8D%97%EF%BC%8C%E4%B8%80%E6%AD%A5%E6%89%93%E5%8C%85%EF%BC%8C%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%BC%80%E5%8F%91%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%85%A8%E6%A0%88%E4%B8%8A%E6%9E%B6%E6%8C%87%E5%8D%97%EF%BC%8C%E4%B8%80%E6%AD%A5%E6%89%93%E5%8C%85%EF%BC%8C%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83/</id>
    <published>2025-07-02T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.963Z</updated>
    
    <content type="html"><![CDATA[<p>懒猫应用离不开社区的力量，有了各位社区贡献者的支持让懒猫商店的应用越来越丰富。下面示范如何把自己的<strong>全栈应用</strong>上架到懒猫微服。</p><p>官网给出的示例里只有 <strong>3 个必备文件</strong>：<code>lzc-build.yml</code>、<code>lzc-icon.png</code>、<code>lzc-manifest.yml</code>。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250630173852407.png" alt="示例目录结构"></p><ul><li>**<code>lzc-icon.png</code>**：应用图标，必须为  PNG。</li><li>**<code>lzc-build.yml</code>**：定义打包脚本、输出路径与图标路径。</li><li>**<code>lzc-manifest.yml</code>**：应用清单，描述路由规则等。<span id="more"></span></li></ul><h3 id="lzc-build-yml-示例"><a href="#lzc-build-yml-示例" class="headerlink" title="lzc-build.yml 示例"></a><code>lzc-build.yml</code> 示例</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包预处理，例子里是复制目录，打包前端文件</span></span><br><span class="line"><span class="comment"># 见build.sh这个文件</span></span><br><span class="line"><span class="comment"># rm -rf ./dist</span></span><br><span class="line"><span class="comment"># mkdir -p dist</span></span><br><span class="line"><span class="comment"># 构建后端二进制文件，因为后面写了contentdir是 dist 文件夹，</span></span><br><span class="line"><span class="comment"># 所以dist是打包的上下文</span></span><br><span class="line"><span class="comment"># cp -r backend dist/</span></span><br><span class="line"><span class="comment"># 构建前端，这里就是普通的前端打包命令，只是指定了输出文件夹</span></span><br><span class="line"><span class="comment"># cd ui &amp;&amp; npx vite build --emptyOutDir --outDir ../dist/web</span></span><br><span class="line"><span class="attr">buildscript:</span> <span class="string">sh</span> <span class="string">build.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># manifest: 指定 lpk 包的 manifest.yml ，一般是这个名字不改</span></span><br><span class="line"><span class="attr">manifest:</span> <span class="string">./lzc-manifest.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># contentdir: 前面把前后端打包到这个目录还是。</span></span><br><span class="line"><span class="attr">contentdir:</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pkgout: lpk 包的输出路径</span></span><br><span class="line"><span class="attr">pkgout:</span> <span class="string">./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># icon 指定 lpk 包 icon 的路径路径，如果不指定将会警告</span></span><br><span class="line"><span class="comment"># icon 仅仅允许 png 后缀的文件</span></span><br><span class="line"><span class="attr">icon:</span> <span class="string">./lzc-icon.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dvshell 指定开发依赖的情况，这个我们后面专门来讲讲</span></span><br><span class="line"><span class="comment"># 这种情况下，选用 alpine:latest 作为基础镜像，在 dependencies 中添加所需要的开发依赖即可</span></span><br><span class="line"><span class="comment"># 如果 dependencies 和 build 同时存在，将会优先使用 dependencies</span></span><br><span class="line"><span class="attr">devshell:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/=http://127.0.0.1:5173</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nodejs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">py3-pip</span></span><br><span class="line">  <span class="attr">setupscript:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    export npm_config_registry=https://registry.npmmirror.com</span></span><br><span class="line"><span class="string">    export PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure><p><code>build.sh</code> 执行完后目录结构大致如下：</p><ul><li><strong>dist&#x2F;backend</strong> →  后端（可执行&#x2F;脚本）</li><li><strong>dist&#x2F;web</strong> →  前端（静态文件）</li></ul><hr><h3 id="lzc-manifest-yml-示例"><a href="#lzc-manifest-yml-示例" class="headerlink" title="lzc-manifest.yml 示例"></a><code>lzc-manifest.yml</code> 示例</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lzc-sdk-version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">代办清单Py</span></span><br><span class="line"><span class="attr">package:</span> <span class="string">cloud.lazycat.app.todolistpy</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">license:</span> <span class="string">https://choosealicense.com/licenses/mit/</span></span><br><span class="line"><span class="attr">homepage:</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">  <span class="attr">subdomain:</span> <span class="string">todolistpy</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/=file:///lzcapp/pkg/content/web</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/api/=exec://3000,./lzcapp/pkg/content/backend/run.sh</span></span><br></pre></td></tr></table></figure><p>routes 这里有三种写法：</p><ol><li><strong>file</strong> 代表文件，一般是纯静态文件，比如打包后的前端文件，在 build.sh 打包的前端问题件，我们前面制定了 content 就是&#x2F;lzcapp&#x2F;pkg&#x2F;content&#x2F;，所以&#x2F;lzcapp&#x2F;pkg&#x2F;content&#x2F;web 也就是刚才的 dist&#x2F;web。这个的意思就是说把跟路由转发这个静态目录，其实就是类似 Nginx 托管静态文件这个样子，只是不需要手动打包，写好命令之后，打包工具帮忙做了这一套。</li><li><code>http(s)://$hostname/$path</code>， 这个是我们印象里的，也就是代理后端，比如&#x2F;api&#x2F;&#x3D;http(s):&#x2F;&#x2F;$hostname&#x2F;$path，其实就类似 Nginx 的 proxy_pass。这个是我们熟知的后端。</li><li><strong>exec</strong>：这个和 http(s)很像，后面多加了一个 run.sh，相当于在转发到 http(s)路由之前，先执行这个脚本。一般是用来一直环境，比如 pip install 什么的，但是由于每个人的环境不一样，还是要使用多个镜像源才保险，我上架的应用就遇到用户通过清华源下载报错 HTTP403 以及 腾讯源下载签名不匹配的问题，或者干脆使用 Docker，这个我们后面再说。</li></ol><p>附上 pip 多源的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已有 —— 主索引 &amp; 前两级备用</span></span><br><span class="line">pip config <span class="built_in">set</span>  global.index-url        https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip config --add global.extra-index-url https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">pip config --add global.extra-index-url https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ③ 阿里云（华东节点评测最稳）</span></span><br><span class="line">pip config --add global.extra-index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ④ 华为云（华南线路友好）</span></span><br><span class="line">pip config --add global.extra-index-url https://repo.huaweicloud.com/repository/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⑤ 字节跳动开源镜像（火山引擎，带全站 CDN）</span></span><br><span class="line">pip config --add global.extra-index-url https://mirrors.byteimg.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ⑥ 南京大学镜像（NJU，教育网 &amp; 华东建议保留）</span></span><br><span class="line">pip config --add global.extra-index-url https://mirrors.nju.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure><hr><h3 id="打包与安装"><a href="#打包与安装" class="headerlink" title="打包与安装"></a>打包与安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包成 LPK</span></span><br><span class="line">lzc-cli project build -o release.lpk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在线安装 LPK</span></span><br><span class="line">lzc-cli app install release.lpk</span><br></pre></td></tr></table></figure><p>然后是打包，如果缺少 lzc-build.yml，lzc-icon.png，lzc-manifest.yml 三者之一就会报错。</p><p>LPK 是懒猫微服应用商店 APP 的安装包格式，其实可以理解为一个配置文件的压缩包，安装之后其实就是在微服内部启动了一个 alpine 的 image，然后通过 build.sh 安装依赖。</p><p>通过 lzc-docker 来看，直接打包的就是这个 images registry.lazycat.cloud&#x2F;lzc&#x2F;lzcapp:3.20.3</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250630181419299.png" alt="image-20250630181419299"></p><p>命令如下<strong>lzc-docker history –no-trunc registry.lazycat.cloud&#x2F;lzc&#x2F;lzcapp:3.20.3</strong>，能够看到是 Alpine 作为 base image，然后更换中科大的源，以及安装 <strong>gcompat</strong> 以兼容 glibc 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) lzcbox-029c588e ~ <span class="comment"># lzc-docker history --no-trunc registry.lazycat.cloud/lzc/lzcapp:3.20.3</span></span><br><span class="line">IMAGE                                                                     CREATED        CREATED BY                                                                                                SIZE      COMMENT</span><br><span class="line">sha256:ba7a533c869a26d89e83bdc5ddb978df5a3502ac91452422a649d0d3cf52190b   7 months ago   RUN /bin/sh -c apk add gcompat <span class="comment"># buildkit                                                                 2.48MB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;                                                                 7 months ago   RUN /bin/sh -c sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apk/repositories <span class="comment"># buildkit   97B       buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;                                                                 9 months ago   CMD [<span class="string">&quot;/bin/sh&quot;</span>]                                                                                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;                                                                 9 months ago   ADD alpine-minirootfs-3.20.3-x86_64.tar.gz / <span class="comment"># buildkit                                                   7.8MB     buildkit.dockerfile.v0</span></span><br><span class="line">(base) lzcbox-029c588e ~ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>甚至可以看到，这个 image 是连 bash 以及各种开发运行时都没有的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) lzcbox-029c588e ~ # lzc-docker run -it registry.lazycat.cloud/lzc/lzcapp:3.20.3 bash</span><br><span class="line">docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: error during container init: exec: &quot;bash&quot;: executable file not found in $PATH: unknown.</span><br><span class="line">(base) lzcbox-029c588e ~ # lzc-docker run -it registry.lazycat.cloud/lzc/lzcapp:3.20.3 sh</span><br><span class="line">/ # go</span><br><span class="line">sh: go: not found</span><br><span class="line">/ # npm</span><br><span class="line">sh: npm: not found</span><br><span class="line">/ # pip</span><br><span class="line">sh: pip: not found</span><br><span class="line">/ # python</span><br><span class="line">sh: python: not found</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure><p>所以这个 backend 文件夹的 run.sh 是拿来安装 Python 依赖的。而前端是使用本地的 npm 打包的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># 切换到当前目录</span><br><span class="line">cd &quot;$(dirname &quot;$0&quot;)&quot;</span><br><span class="line">sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27; /etc/apk/repositories</span><br><span class="line">apk update</span><br><span class="line">apk add python3 py3-pip</span><br><span class="line"># ❶ 设主索引，只能有一个</span><br><span class="line"># 已有 —— 主索引 &amp; 前两级备用</span><br><span class="line">pip config set  global.index-url        https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip config --add global.extra-index-url https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">pip config --add global.extra-index-url https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br><span class="line"></span><br><span class="line"># ③ 阿里云（华东节点评测最稳）</span><br><span class="line">pip config --add global.extra-index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"># ④ 华为云（华南线路友好）</span><br><span class="line">pip config --add global.extra-index-url https://repo.huaweicloud.com/repository/pypi/simple/</span><br><span class="line"></span><br><span class="line"># ⑤ 字节跳动开源镜像（火山引擎，带全站 CDN）</span><br><span class="line">pip config --add global.extra-index-url https://mirrors.byteimg.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"># ⑥ 南京大学镜像（NJU，教育网 &amp; 华东建议保留）</span><br><span class="line">pip config --add global.extra-index-url https://mirrors.nju.edu.cn/pypi/web/simple/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pip install -r ./requirements.txt --break-system-packages</span><br><span class="line">python3 app.py</span><br></pre></td></tr></table></figure><p>安装之后的 app 可以通过 lzc-docker 查看，也可以使用 Dozze 查看日志，一般 debug 时候的时候会看这个。</p><p>DOZZL 需要安装开发者工具，然后使用<a href="https://dev.设备名.heiyu.space/dozzle/%E8%AE%BF%E9%97%AE%E3%80%82">https://dev.设备名.heiyu.space/dozzle/访问。</a></p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250630190230526.png" alt="image-20250630190230526"></p><p>一般来说部署有两个 pod，一个是 App-1 结尾的，主要是涉及到转发，run.sh 自动安装依赖，以及健康检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH:&quot;/&quot; is served by &quot;file&quot;://&quot;/lzcapp/pkg/content/dist&quot;</span><br><span class="line">PATH:&quot;/api/&quot; is served by &quot;http&quot;://&quot;host.lzcapp:53443&quot;</span><br><span class="line">health check finished</span><br></pre></td></tr></table></figure><p>应用名字-1 结尾的，这个才是应用的日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2025-06-29 17:29:29 +0800] [1] [INFO] Starting gunicorn 23.0.0</span><br><span class="line">[2025-06-29 17:29:29 +0800] [1] [INFO] Listening at: http://0.0.0.0:9527 (1)</span><br><span class="line">[2025-06-29 17:29:29 +0800] [1] [INFO] Using worker: sync</span><br><span class="line">[2025-06-29 17:29:29 +0800] [9] [INFO] Booting worker with pid: 9</span><br></pre></td></tr></table></figure><p>希望大家都能够多多为懒猫微服贡献应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒猫应用离不开社区的力量，有了各位社区贡献者的支持让懒猫商店的应用越来越丰富。下面示范如何把自己的&lt;strong&gt;全栈应用&lt;/strong&gt;上架到懒猫微服。&lt;/p&gt;
&lt;p&gt;官网给出的示例里只有 &lt;strong&gt;3 个必备文件&lt;/strong&gt;：&lt;code&gt;lzc-build.yml&lt;/code&gt;、&lt;code&gt;lzc-icon.png&lt;/code&gt;、&lt;code&gt;lzc-manifest.yml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250630173852407.png&quot; alt=&quot;示例目录结构&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**&lt;code&gt;lzc-icon.png&lt;/code&gt;**：应用图标，必须为  PNG。&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;lzc-build.yml&lt;/code&gt;**：定义打包脚本、输出路径与图标路径。&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;lzc-manifest.yml&lt;/code&gt;**：应用清单，描述路由规则等。</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="开发" scheme="https://xu-hardy.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Gemini-cli 踩坑机：国内环境 , 用过 Google Cloud 如何设置？</title>
    <link href="https://xu-hardy.github.io/gemini-cli-%E8%B8%A9%E5%9D%91%E6%9C%BA%EF%BC%9A%E5%9B%BD%E5%86%85%E7%8E%AF%E5%A2%83-%E7%94%A8%E8%BF%87-google-cloud-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%9F/"/>
    <id>https://xu-hardy.github.io/gemini-cli-%E8%B8%A9%E5%9D%91%E6%9C%BA%EF%BC%9A%E5%9B%BD%E5%86%85%E7%8E%AF%E5%A2%83-%E7%94%A8%E8%BF%87-google-cloud-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%9F/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>Gemini 也发布了类似的 AI 编程产品 Gemini Cli - 开源命令行 AI 工具</p><p>而且个人谷歌账号登录就能免费用！</p><p>免费额度为每分钟 60 次请求、每天 1000 次请求，是业内最高的免费额度，几乎不会遇到限制。</p><ul><li>支持 Google 搜索实时联网，为模型提供外部上下文。</li><li>支持 MCP 和扩展，便于功能拓展。</li><li>可自定义提示词和指令，适应个人或团队工作流。</li><li>可在脚本中非交互式调用，实现自动化和集成。</li></ul><h3 id="安装-gemini-cli"><a href="#安装-gemini-cli" class="headerlink" title="安装 gemini-cli"></a>安装 gemini-cli</h3><p>先来安装 gemini-cli，其实就是一个 NPM 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @google/gemini-cli</span><br><span class="line">gemini</span><br></pre></td></tr></table></figure><p>如果不出意外的话，执行之后会闪退。网上说需要设置 TUN 代理，甚至连命令行 export 环境变量也不行。</p><hr><h3 id="登录-Google-SSO-后仍无法使用"><a href="#登录-Google-SSO-后仍无法使用" class="headerlink" title="登录 Google SSO 后仍无法使用"></a>登录 Google SSO 后仍无法使用</h3><p>然后登录 Google SSO 验证，页面会显示 Gemini Code Assist 已获得访问您账号的授权。但是其实还是不行。我们继续看。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/de7757ea56e0bf2d668093ee788b240a.png" alt="de7757ea56e0bf2d668093ee788b240a"></p><p>命令行还是会得到这个报错：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250626075949247.png" alt="image-20250626075949247"></p><hr><h3 id="设置-GOOGLE-CLOUD-PROJECT-环境变量"><a href="#设置-GOOGLE-CLOUD-PROJECT-环境变量" class="headerlink" title="设置 GOOGLE_CLOUD_PROJECT 环境变量"></a>设置 GOOGLE_CLOUD_PROJECT 环境变量</h3><p>网上基本有这个教程：</p><blockquote><p>用过谷歌云或者 ai studio 的，使用 gemini cli 登陆时可能会有些麻烦，可能要打开 console.cloud.google.com，找到你的 project id，然后设置 GOOGLE_CLOUD_PROJECT 环境变量，使用这种方式打开 gemini cli，就可以用了</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250626080352544.png" alt="image-20250626080352544"></p><p>然后执行这句，这是环境变量。(临时设置, 仅当前会话有效）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOOGLE_CLOUD_PROJECT=&quot;your-project-id&quot;</span><br></pre></td></tr></table></figure><p>如果你想让这个永久生效的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export GOOGLE_CLOUD_PROJECT=&quot;your-project-id&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>然后 source ～&#x2F;.zshrc 就可以了。</p><hr><h3 id="报错：API-未启用"><a href="#报错：API-未启用" class="headerlink" title="报错：API 未启用"></a>报错：API 未启用</h3><p>有发现新的错，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span>API Error<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gemini for Google Cloud API has not been used in project xxxxx before or it is disabled. Enable it by visiting</span></span><br><span class="line"><span class="string"> https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxxxx then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our</span></span><br><span class="line"><span class="string"> systems and retry.&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;errors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gemini for Google Cloud API has not been used in project xxxx before or it is disabled. Enable it by visiting</span></span><br><span class="line"><span class="string"> https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxx then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our</span></span><br><span class="line"><span class="string"> systems and retry.&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="string">&quot;usageLimits&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accessNotConfigured&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;extendedHelp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://console.developers.google.com&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PERMISSION_DENIED&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/google.rpc.ErrorInfo&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SERVICE_DISABLED&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="string">&quot;googleapis.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;activationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;containerInfo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;consumer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;projects/xxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cloudaicompanion.googleapis.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;serviceTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gemini for Google Cloud API&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/google.rpc.LocalizedMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;locale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;en-US&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gemini for Google Cloud API has not been used in project xxxx before or it is disabled. Enable it by visiting</span></span><br><span class="line"><span class="string"> https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxx then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our</span></span><br><span class="line"><span class="string"> systems and retry.&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/google.rpc.Help&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;links&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="punctuation">&#123;</span></span><br><span class="line">             <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Google developers console API activation&quot;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxx&quot;</span></span><br><span class="line">           <span class="punctuation">&#125;</span></span><br><span class="line">         <span class="punctuation">]</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>打开报错了的网页 <a href="https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxxxx%EF%BC%8C%E6%AF%94%E5%A6%82%E8%BF%99%E4%B8%AA%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%98%AF%E5%92%8C%E4%BD%A0%E7%9A%84">https://console.developers.google.com/apis/api/cloudaicompanion.googleapis.com/overview?project=xxxxxx，比如这个，这个网页是和你的</a> ID 相关的，然后点击启用。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/d94297cbdd8e54f2d75d126f07f09bcb.png" alt="d94297cbdd8e54f2d75d126f07f09bcb"></p><hr><h3 id="成功运行！"><a href="#成功运行！" class="headerlink" title="成功运行！"></a>成功运行！</h3><p>终于可以用了不容易。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250626075518890.png" alt="image-20250626075518890"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gemini 也发布了类似的 AI 编程产品 Gemini Cli - 开源命令行 AI 工具&lt;/p&gt;
&lt;p&gt;而且个人谷歌账号登录就能免费用！&lt;/p&gt;
&lt;p&gt;免费额度为每分钟 60 次请求、每天 1000 次请求，是业内最高的免费额度，几乎不会遇到限制。&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="LLM" scheme="https://xu-hardy.github.io/categories/LLM/"/>
    
    
    <category term="LLM" scheme="https://xu-hardy.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>如何在 AWS EC2 上部署 Isaac Sim</title>
    <link href="https://xu-hardy.github.io/%E5%A6%82%E4%BD%95%E5%9C%A8-aws-ec2-%E4%B8%8A%E9%83%A8%E7%BD%B2-isaac-sim/"/>
    <id>https://xu-hardy.github.io/%E5%A6%82%E4%BD%95%E5%9C%A8-aws-ec2-%E4%B8%8A%E9%83%A8%E7%BD%B2-isaac-sim/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>网上已经有一些关于在阿里云和腾讯云上部署 Isaac Sim 的教程，本文将带大家了解如何在 <strong>AWS EC2 上部署 NVIDIA Isaac Sim 仿真平台</strong>，并以 <strong>A10G GPU（g5.2xlarge 实例）</strong>为例进行实战操作。</p><hr><h2 id="一、环境说明"><a href="#一、环境说明" class="headerlink" title="一、环境说明"></a>一、环境说明</h2><ul><li><strong>GPU 类型</strong>：A10G（适用于 RTX 渲染）</li><li><strong>实例类型</strong>：<code>g5.2xlarge</code></li><li><strong>操作系统镜像（AMI）</strong>：<br><code>Deep Learning OSS Nvidia Driver AMI GPU PyTorch 2.7 (Ubuntu 22.04)</code><br>👉 该镜像自带 NVIDIA 驱动、CUDA、Docker、nvidia-docker，无需手动安装</li></ul><hr><h2 id="二、登录-AWS-控制台并创建实例"><a href="#二、登录-AWS-控制台并创建实例" class="headerlink" title="二、登录 AWS 控制台并创建实例"></a>二、登录 AWS 控制台并创建实例</h2><ol><li><p>打开 <a href="https://aws.amazon.com/">AWS 官网</a>，点击右上角登录。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220057596.png" alt="登录入口"></p></li><li><p>选择 <strong>使用 Root 账户登录</strong>：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220133816.png" alt="root 登录"></p></li><li><p>输入 root 邮箱和密码，若首次登录需要绑定 MFA（建议使用 Authenticator App）：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220233221.png" alt="MFA 验证"></p></li><li><p>进入 AWS 控制台后，选择左侧的 EC2，点击右上角的 <strong>“启动实例”</strong>。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220401797.png" alt="启动 EC2 实例"></p></li></ol><hr><h2 id="三、配置-EC2-实例（含-GPU-驱动）"><a href="#三、配置-EC2-实例（含-GPU-驱动）" class="headerlink" title="三、配置 EC2 实例（含 GPU 驱动）"></a>三、配置 EC2 实例（含 GPU 驱动）</h2><ol><li><p><strong>选择操作系统镜像（AMI）</strong>：<br>搜索并选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deep Learning OSS Nvidia Driver AMI GPU PyTorch 2.7 (Ubuntu 22.04)</span><br></pre></td></tr></table></figure><blockquote><p>自带了 NVIDIA 驱动、nvidia-container-toolkit、Docker 等，无需额外安装。</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220549942.png" alt="选择镜像"></p></li><li><p><strong>选择实例类型</strong>：<code>g5.2xlarge</code>（带 A10G GPU）</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220637975.png" alt="选择实例类型"></p></li><li><p><strong>创建密钥对</strong>：系统会生成 <code>.pem</code> 格式的密钥，下载后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 400 your-key.pem</span><br></pre></td></tr></table></figure></li><li><p><strong>网络设置</strong>：</p><ul><li>选择已有 VPC，或默认网络</li><li>确保启用公网 IP 分配</li></ul></li><li><p><strong>安全组设置</strong>：</p><ul><li>开放所需端口</li><li>如部署 livestream 或远程访问，确保相应端口可用</li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614220708780.png" alt="安全组设置"></p></li></ol><hr><h2 id="四、连接实例并确认环境"><a href="#四、连接实例并确认环境" class="headerlink" title="四、连接实例并确认环境"></a>四、连接实例并确认环境</h2><p>使用 SSH 登录 EC2 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i your-key.pem ubuntu@&lt;EC2公有IP&gt;</span><br></pre></td></tr></table></figure><ol><li><p>查看基本系统信息（需先安装 neofetch）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install neofetch -y</span><br><span class="line">neofetch</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/d7283c4b7f3ae527c53fdb06facaf7bf.png" alt="neofetch 系统信息"></p></li><li><p>查看 GPU 驱动是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614221542279.png" alt="nvidia-smi"></p></li><li><p>查看是否已安装 <code>nvidia-docker</code> 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep -i nvidia</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250614225538525.png" alt="nvidia-docker 插件"></p></li></ol><hr><h2 id="五、安装-Isaac-Sim（官方容器方式）"><a href="#五、安装-Isaac-Sim（官方容器方式）" class="headerlink" title="五、安装 Isaac Sim（官方容器方式）"></a>五、安装 Isaac Sim（官方容器方式）</h2><p>接下来按照 NVIDIA 官方文档进行 Isaac Sim 的容器部署即可：</p><p>👉 文档链接：<br><a href="https://docs.isaacsim.omniverse.nvidia.com/4.5.0/installation/install_container.html">https://docs.isaacsim.omniverse.nvidia.com/4.5.0/installation/install_container.html</a></p><ul><li>如果首次启动卡在 <code>RtPso async compilation</code> 阶段较久（10 分钟左右），这是因为光线追踪 shader 正在编译。只要缓存持久化，之后启动会非常快（1 分钟内）。</li></ul><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><p>通过 AWS 的 G5 系列实例（搭载 A10G GPU），我们可以方便地在云端部署 Isaac Sim。选用 NVIDIA 官方预装驱动的 AMI，可以省去繁琐的 CUDA 和容器配置。搭配持久化缓存和合理的端口管理，即可稳定高效运行 Isaac Sim 的云端仿真。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上已经有一些关于在阿里云和腾讯云上部署 Isaac Sim 的教程，本文将带大家了解如何在 &lt;strong&gt;AWS EC2 上部署 NVIDIA Isaac Sim 仿真平台&lt;/strong&gt;，并以 &lt;strong&gt;A10G GPU（g5.2xlarge 实例）&lt;/str</summary>
      
    
    
    
    <category term="AWS" scheme="https://xu-hardy.github.io/categories/AWS/"/>
    
    
    <category term="Isaac" scheme="https://xu-hardy.github.io/tags/Isaac/"/>
    
  </entry>
  
  <entry>
    <title>组队参加 Amazon Q Idea 1000，我们的作品上了 AWS 峰会</title>
    <link href="https://xu-hardy.github.io/%E7%BB%84%E9%98%9F%E5%8F%82%E5%8A%A0-amazon-q-idea-1000%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84%E4%BD%9C%E5%93%81%E4%B8%8A%E4%BA%86-aws-%E5%B3%B0%E4%BC%9A/"/>
    <id>https://xu-hardy.github.io/%E7%BB%84%E9%98%9F%E5%8F%82%E5%8A%A0-amazon-q-idea-1000%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84%E4%BD%9C%E5%93%81%E4%B8%8A%E4%BA%86-aws-%E5%B3%B0%E4%BC%9A/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>最近生成式 AI 的比赛很多，也报名了 AWS Idea1000 的比赛，作品登录上了 AWS 的峰会。</p><p>我们的产品名称是“拍立懂”，团队名称是 “凌晨三点的夜”。主要是<strong>拍照识别</strong>商品成分、品牌资质，分析价格合理性，为老年人提供购买决策建议；通过<strong>实时语音聊天交互</strong>，<strong>亲人语音陪伴</strong>老年人购物，满足空巢老人的情感空缺。</p><p>我们的项目团队汇聚了文化创意创业者、资深互联网产品经理、互联网技术博主与 AI 前端工程师等多元背景，形成从商业策略到产品落地的完整闭环。团队成员对创新技术和用户价值怀有共同的热情，彼此协作、优势互补，致力于在商业模式和技术实现上持续突破，为项目注入持久动力。</p><p>说人话版本:</p><blockquote><p><strong>“拍立懂”首页：先定位、再拍照、还可语音，一站式搞定逛超市！</strong><br>进入小程序，系统会自动识别你所在的门店，保证每一次推荐都“本地有货”。</p><ul><li>对准商品“拍一拍”，AI 秒识品牌与规格，为你生成成分&#x2F;营养解析；</li><li>打开语音助手，直接问“这款油健康吗？”，即时语音作答；</li><li>想逛逛热卖？下拉切换「日用食品 &#x2F; 零食饮料 &#x2F; 时令食材」，AI 列出今日在售优质清单。<br><strong>拍照 + 语音 + 实时库存</strong>，让你逛超市不再纠结，用 AI 把复杂信息说得清清楚楚。</li></ul></blockquote><p>架构图如下：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/0f723804988ba318ff6ab24970dfc023.png" alt="0f723804988ba318ff6ab24970dfc023"></p><ol><li><strong>域名与流量入口</strong><ul><li>Route 53 购买域名以及负责域名解析</li><li>ALB 负载均衡 &amp; HTTPS 卸载</li></ul></li><li><strong>应用与模型服务</strong><ul><li><strong>Next.js</strong> (前端+SSR)</li><li><strong>Flask (语音识别、图像识别、流式对题) + FastAPI （OpenAI realtime 代理）</strong></li></ul></li><li><strong>数据与存储</strong><ul><li>S3 存音频&#x2F;图片</li><li><strong>Milvus (Zilliz Cloud on GCP)</strong> 向量检索做 RAG</li></ul></li><li><strong>多模态交互</strong><ul><li>OpenAI Vision + Realtime 实时对话</li></ul></li><li><strong>环境 &amp; CI&#x2F;CD</strong><ul><li>Lightsail 做 POC，懒猫微服异地组网调试</li><li>GitHub Actions 一件打包到 Dockerhub</li><li>Docker-compose 一键部署</li></ul></li></ol><p>这个是最初的设计。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250620102357142.png"></p><ul><li><strong>门店定位（顶部）</strong><ul><li>自动显示 _“上海市黄浦区马当路富民超市”_，说明系统已精准锁定当前购物地点，为后续推荐做铺垫。</li></ul></li><li><strong>商品识别卡片（居中大框）</strong><ul><li>灰阶渐变 + 相机图标，文案 _“对准商品 拍一拍”_。</li><li>点击即可拍照识别商品，进入智能解析流程，是整套体验的“入口 1”。</li></ul></li><li><strong>语音购物助手按钮（绿色条形）</strong><ul><li>显眼的绿色按钮 _“打开语音购物助手”_。</li><li>用户只需轻触，便可与 AI 语音对话，实现“入口 2”。</li></ul></li><li><strong>AI 推荐栏目（下方列表）</strong><ul><li>栏目标题 _“AI 帮你聪明买”_，右侧分类下拉框默认 _“日用食品”_。</li><li>下拉可切换 <em>“零食饮料 &#x2F; 时令食材”</em> 等，列表随之刷新“今日在售”优选商品。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/f6f98cd0-65ec-41fa-ab5b-1d43b75504b5.png" alt="f6f98cd0-65ec-41fa-ab5b-1d43b75504b5"></p><ul><li><strong>拍一下，AI 帮你把配料表翻译成人话！</strong><br>识别完成后，只需点开「成分分析」，AI 会：<ol><li>精准列出主要成分、配料比例；</li><li>提醒潜在风险（如高糖、高钠或人工添加）；</li><li>结合膳食指南，给出健康建议。<br>如果想进一步了解热量、矿物质等信息，切换到「营养价值」即可；想知道同类好物怎么选？点「选购建议」一键获得。<br><strong>拍立懂，让任何瓶瓶罐罐都不再是“天书”，分分钟看懂喝得放心！</strong></li></ol></li></ul><blockquote><p>“拍一下成分表，让 AI 帮你读懂配料、评估健康影响，真正做到买得安心、喝得放心。”</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/0375561d-e43e-4618-94be-66439460d91c.png" alt="0375561d-e43e-4618-94be-66439460d91c"></p><blockquote><p><strong>“坚果零食好不好？拍立懂 3 秒告诉你！”</strong><br>拍照上传后，AI 自动识别到「烤坚果夹片 145 g × 24 片」，并细致解析：</p><ul><li><strong>坚果种类</strong>、<strong>外层配料</strong>、<strong>甜味剂 &#x2F; 添加剂</strong> 全部列出；</li><li>逐项点评对心血管、体重管理、过敏风险的影响；</li><li>支持一键切换到「营养价值」查看热量、蛋白质等详细数据，或点「选购建议」获取更健康替代品。<br><strong>拍立懂</strong> —— 把复杂配料表翻译成人话，让零食的健康度一眼可见！</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250620134244888.png" alt="image-20250620134244888"></p><ul><li><strong>一句话上手语音购物助手</strong><br>点一下麦克风，不用输入、不用切页面，直接对 AI 说：“这款牛奶适合减肥吗？”——拍立懂立刻回答，让逛超市像跟朋友聊天一样简单。<ul><li><strong>极速连接</strong>：3 秒内完成网络 &amp; 麦克风检测</li><li><strong>实时反馈</strong>：对话状态一目了然，杜绝“说了没听见”</li><li><strong>智能引导</strong>：AI 主动提问，帮你快速聚焦购物痛点<br>语音 + AI，让信息检索更高效，让购物决策更轻松！</li></ul></li></ul><blockquote><p>“无需打字，长按语音键即可提问。拍立懂即刻为你解惑，让购物沟通更流畅。”</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/f5cd2824-be07-4152-8bc9-91bc6ddc6735.jpeg" alt="f5cd2824-be07-4152-8bc9-91bc6ddc6735"></p><ul><li><strong>商业计划书</strong><br><a href="https://edwqcun7v5.feishu.cn/docx/VBtWdFMB3omZxhxT2FGco73MnIe">https://edwqcun7v5.feishu.cn/docx/VBtWdFMB3omZxhxT2FGco73MnIe</a></li><li><strong>产品演示文档</strong><br><a href="https://edwqcun7v5.feishu.cn/docx/RNvldJCQVoU1nixqHjrcZ2TNnfc">https://edwqcun7v5.feishu.cn/docx/RNvldJCQVoU1nixqHjrcZ2TNnfc</a></li></ul><hr><blockquote><p>⏰ <strong>凌晨三点的夜</strong> 还在码字、调参，但有热情就不困。<br><strong>拍立懂</strong>，让爸妈“拍一拍就懂”，也让我们更懂爸妈。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近生成式 AI 的比赛很多，也报名了 AWS Idea1000 的比赛，作品登录上了 AWS 的峰会。&lt;/p&gt;
&lt;p&gt;我们的产品名称是“拍立懂”，团队名称是 “凌晨三点的夜”。主要是&lt;strong&gt;拍照识别&lt;/strong&gt;商品成分、品牌资质，分析价格合理性，为老年人提供</summary>
      
    
    
    
    <category term="AWS" scheme="https://xu-hardy.github.io/categories/AWS/"/>
    
    
    <category term="AWS" scheme="https://xu-hardy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>记一次Amazon Q pro的使用</title>
    <link href="https://xu-hardy.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1amazon-q-pro%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xu-hardy.github.io/%E8%AE%B0%E4%B8%80%E6%AC%A1amazon-q-pro%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>参加 AWS 的比赛申请了 Amazon Q pro，平时也在用 builderID 登陆使用免费的账户。Amazon Q pro 需要和 IAM identity center 一起用，不过比赛直接给配置好了，直接分发 IAM identity center 的账户，我们只需要注册，登陆，然后关联 Q pro。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613214705836.png" alt="image-20250613214705836"></p><p>从邮箱里给的链接注册，登录。然后绑定 MFA，这个 MFA 其实就是一个二次验证，如果账户被盗，对方没有 MFA 也是无法登录的。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613215145521.png" alt="image-20250613215145521"></p><p>我用了 2Fauth 来绑定的，当然你也可以使用 google authenticator 之类的软件，绑定六位动态码。当然比较常见的 MFA 就是短信验证码，当然还有打电话的。这边刚刚登录，这边电话马上过来。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/221ef1ff7faa7d41d0b2032bfe981928.png" alt="221ef1ff7faa7d41d0b2032bfe981928"></p><p>注册成功会有这个提示。后面需要使用这个绑定的 MFA 进行登录。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613214403296.png" alt="image-20250613214403296"></p><p>登录之后会跳转到这个门户页面，点击 Q 的图标之后会跳转到 Amazon Q 的官方文档。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/03f17da2afbfeaf936933ac5b9014db0.jpg" alt="03f17da2afbfeaf936933ac5b9014db0"></p><p>完成了登录，我们来做本地的配置：</p><p>在 VS code 商店中搜索 Amazon Q 并且安装：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613220402714.png" alt="image-20250613220402714"></p><p>Amazon Q 有免费版和 Pro 版。免费版使用 build ID 进行登录，无需 AWS 账户。而今天体验的是 Q pro 版本，还好主办方给配置好了 AWS 的账户，</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613220656884.png" alt="image-20250613220656884"></p><p>安装之后右下角就有一个提示登录的弹窗，点击 Sign in，URL 输入邮箱里给的 URL。其实就是 IAM identity center 的登录链接。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/75a9cf790abee0500c03a4fef5906e0b.png" alt="75a9cf790abee0500c03a4fef5906e0b"></p><p>然后是跳转浏览器：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/08d51abf78a42aac97e2f6d3901dbc4f.png" alt="08d51abf78a42aac97e2f6d3901dbc4f"></p><p>以及提示打开浏览器的弹窗：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613221104615.png" alt="image-20250613221104615"></p><p>浏览器打开之后有获取权限的提示：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/a77a557cab162ca6d22c644330b1debc.png" alt="a77a557cab162ca6d22c644330b1debc"></p><p>点击允许之后就大功告成了：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/a5eac153f41f318771e8ed90a258bb44.png" alt="a5eac153f41f318771e8ed90a258bb44"></p><p>同时 VScode 里的 Q 也会变成这样，最后变成聊天窗口</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613221132184.png" alt="image-20250613221132184"></p><p>如图是聊天模式：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250613221851367.png" alt="image-20250613221851367"></p><p>如果你使用 Ubuntu server：</p><ol><li><p>下载命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://desktop-release.q.us-east-1.amazonaws.com/latest/amazon-q.deb</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br><span class="line">sudo dpkg -i amazon-q.deb</span><br></pre></td></tr></table></figure></li><li><p>打开，然后同样的通过浏览器打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/4e449305647468b637ebe4600479a868.png" alt="4e449305647468b637ebe4600479a868"></p><p>如果你用的是苹果系统，就更简单了。从这个链接下载，直接安装就可以了。</p><p><a href="https://desktop-release.q.us-east-1.amazonaws.com/latest/Amazon%20Q.dmg">https://desktop-release.q.us-east-1.amazonaws.com/latest/Amazon%20Q.dmg</a></p><p>然后在终端中输入 q 或者 Q chat 就可以了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/714911ccd41755315794150d4e748318.png" alt="714911ccd41755315794150d4e748318"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参加 AWS 的比赛申请了 Amazon Q pro，平时也在用 builderID 登陆使用免费的账户。Amazon Q pro 需要和 IAM identity center 一起用，不过比赛直接给配置好了，直接分发 IAM identity center 的账户，我们</summary>
      
    
    
    
    <category term="AWS" scheme="https://xu-hardy.github.io/categories/AWS/"/>
    
    
    <category term="AWS" scheme="https://xu-hardy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>写给懒猫微服玩家的容器小书 Docker篇（一）：《无法部署的诅咒》</title>
    <link href="https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E3%80%8A%E6%97%A0%E6%B3%95%E9%83%A8%E7%BD%B2%E7%9A%84%E8%AF%85%E5%92%92%E3%80%8B/"/>
    <id>https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E3%80%8A%E6%97%A0%E6%B3%95%E9%83%A8%E7%BD%B2%E7%9A%84%E8%AF%85%E5%92%92%E3%80%8B/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。</p></blockquote><h1 id="《无法部署的诅咒》讲的是-Docker-的起源与作用、镜像与容器概念、安装入门"><a href="#《无法部署的诅咒》讲的是-Docker-的起源与作用、镜像与容器概念、安装入门" class="headerlink" title="《无法部署的诅咒》讲的是 Docker 的起源与作用、镜像与容器概念、安装入门"></a>《无法部署的诅咒》讲的是 Docker 的起源与作用、镜像与容器概念、安装入门</h1><h3 id="🏙️-开篇：代码在电脑上运行良好，部署却频频翻车"><a href="#🏙️-开篇：代码在电脑上运行良好，部署却频频翻车" class="headerlink" title="🏙️ 开篇：代码在电脑上运行良好，部署却频频翻车"></a>🏙️ 开篇：代码在电脑上运行良好，部署却频频翻车</h3><p>小李是一名后端工程师，刚完成一个用 Flask 编写的内部管理系统。他信心满满地将代码提交，交给测试工程师老赵部署。</p><p>可没想到——</p><blockquote><p>“报错了！你是不是少传文件了？”</p><p>“我这边 Python 是 3.6，怎么你这代码用了 <code>match case</code>？”</p><p>“你数据库呢？你 Redis 配了？环境变量在哪？”</p></blockquote><p>这一刻，小李陷入了一个叫「部署地狱」的世界。</p><p>这个世界里，每一台服务器都是独一无二的“宠物”，需要手动配置、手动部署、手动踩坑，稍有不慎就会陷入版本冲突、依赖缺失、环境不一致的深渊。</p><p>小李心里想：<strong>有没有一种办法，能让我把代码和环境一起打包起来，无论在哪运行都能保持一致？</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h3 id="🌀-变故：神秘的程序员大叔与魔法容器"><a href="#🌀-变故：神秘的程序员大叔与魔法容器" class="headerlink" title="🌀 变故：神秘的程序员大叔与魔法容器"></a>🌀 变故：神秘的程序员大叔与魔法容器</h3><p>在公司茶水间，小李邂逅了一个带着黑框眼镜的大叔，大家都叫他老周。</p><p>老周是个技术老炮，在各种部署大灾难中杀出血路。他听完小李的吐槽后，轻轻地推了一份文档过来，只写了五个字母：</p><blockquote><p><code>Docker</code></p></blockquote><p>“这是个<strong>魔法容器</strong>，”老周说，“把你代码和环境都打包进去，哪怕放在火星，也能跑。”</p><blockquote><p>“以后别再‘它在我电脑上可以跑’了，Docker 能让所有环境变得一致。”</p></blockquote><p>小李的眼睛亮了。</p><hr><h3 id="🔧-技术讲解-Part-1：什么是-Docker？"><a href="#🔧-技术讲解-Part-1：什么是-Docker？" class="headerlink" title="🔧 技术讲解 Part 1：什么是 Docker？"></a>🔧 技术讲解 Part 1：什么是 Docker？</h3><p>Docker 是一个<strong>开源的容器化平台</strong>，它允许开发者将应用及其所有依赖打包成一个“容器”，保证在任何平台上都可以一致运行。</p><p>你可以把 Docker 想象成：</p><blockquote><p><strong>程序员的打包箱子</strong>：把你写的程序、环境、库、配置都放进去，打包成一个“镜像”；</p><p><strong>程序员的快递服务</strong>：运行镜像就像打开快递，内容和你寄出时一模一样。</p></blockquote><h4 id="🚀-为什么要用-Docker？"><a href="#🚀-为什么要用-Docker？" class="headerlink" title="🚀 为什么要用 Docker？"></a>🚀 为什么要用 Docker？</h4><ul><li>✅ <strong>跨平台运行</strong>：一次构建，到处运行（Run anywhere）</li><li>✅ <strong>快速部署</strong>：秒级启动，适合 CI&#x2F;CD</li><li>✅ <strong>环境一致性</strong>：不再“你电脑能跑我电脑不行”</li><li>✅ <strong>轻量隔离</strong>：不像虚拟机那么重，不需要整个操作系统</li><li>✅ <strong>资源占用少</strong>：用起来更像一个进程，而不是一台虚拟机</li></ul><blockquote><p>☑️ 一句话总结：<strong>Docker 解决了“在我电脑上能跑”的问题。</strong></p></blockquote><hr><h3 id="🛠️-技术讲解-Part-2：如何安装-Docker？"><a href="#🛠️-技术讲解-Part-2：如何安装-Docker？" class="headerlink" title="🛠️ 技术讲解 Part 2：如何安装 Docker？"></a>🛠️ 技术讲解 Part 2：如何安装 Docker？</h3><p>老周拍了拍小李的肩膀，说：“先装起来，动手最重要。”</p><h4 id="🧑‍💻-在-Mac-Windows-上："><a href="#🧑‍💻-在-Mac-Windows-上：" class="headerlink" title="🧑‍💻 在 Mac &#x2F; Windows 上："></a>🧑‍💻 在 Mac &#x2F; Windows 上：</h4><ul><li>访问官网：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></li><li>下载并安装 Docker Desktop</li><li>安装后打开终端（Terminal），输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure><p>如果看到 Docker 的版本信息，说明安装成功。</p><h4 id="🧑‍💻-在-Linux（Ubuntu）上："><a href="#🧑‍💻-在-Linux（Ubuntu）上：" class="headerlink" title="🧑‍💻 在 Linux（Ubuntu）上："></a>🧑‍💻 在 Linux（Ubuntu）上：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install docker.io</span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>🔐 <em>建议将当前用户加入 docker 组，以免每次都要用 sudo：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><hr><h3 id="🧠-技术讲解-Part-3：Docker-的核心概念"><a href="#🧠-技术讲解-Part-3：Docker-的核心概念" class="headerlink" title="🧠 技术讲解 Part 3：Docker 的核心概念"></a>🧠 技术讲解 Part 3：Docker 的核心概念</h3><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>镜像（Image）</td><td>应用和其依赖的静态快照模板（如：打包好的 Python 环境 + Flask 项目）</td></tr><tr><td>容器（Container）</td><td>镜像运行出来的实例，是真正“活着”的程序</td></tr><tr><td>Dockerfile</td><td>编写镜像的“配方”，定义如何构建镜像</td></tr><tr><td>Docker Hub</td><td>类似 GitHub 的公共镜像仓库，可上传&#x2F;下载别人做好的镜像</td></tr><tr><td><code>docker</code> 命令</td><td>Docker 的主命令工具，用于操作镜像、容器、网络、卷等</td></tr></tbody></table><h4 id="📌-镜像-vs-容器"><a href="#📌-镜像-vs-容器" class="headerlink" title="📌 镜像 vs 容器"></a>📌 镜像 vs 容器</h4><ul><li>镜像是“模具”，容器是“实物”</li><li>镜像不可变，容器是可运行的环境</li><li>一个镜像可以运行多个容器</li></ul><hr><h3 id="🧪-技术实践：Hello-Docker-世界"><a href="#🧪-技术实践：Hello-Docker-世界" class="headerlink" title="🧪 技术实践：Hello Docker 世界"></a>🧪 技术实践：Hello Docker 世界</h3><p>老周指导小李敲下第一行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><blockquote><p>如果 docker run&#x2F;pull 有问题，那么可以通过<code>lzc-cli appstore copy-image your-images</code>来使用懒猫的镜像仓库。</p></blockquote><p>这个命令会做三件事：</p><ol><li>自动从 Docker Hub 拉取一个 <code>hello-world</code> 镜像（如果本地没有）</li><li>基于镜像运行容器</li><li>容器运行后输出信息，然后自动退出</li></ol><p>这是验证 Docker 是否正常运行的“点灯测试”。</p><hr><h3 id="🧱-小李的第一个真实容器：Flask-Web-项目打包实战"><a href="#🧱-小李的第一个真实容器：Flask-Web-项目打包实战" class="headerlink" title="🧱 小李的第一个真实容器：Flask Web 项目打包实战"></a>🧱 小李的第一个真实容器：Flask Web 项目打包实战</h3><p>老周笑着说：“现在，把你那个 Flask 管理系统也丢进 Docker 试试。”</p><p>小李在项目根目录下写了一个 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Python 官方基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><h4 id="构建镜像："><a href="#构建镜像：" class="headerlink" title="构建镜像："></a>构建镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-flask-app .</span><br></pre></td></tr></table></figure><h4 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5000:5000 my-flask-app</span><br></pre></td></tr></table></figure><p>现在访问浏览器 <code>http://localhost:5000</code>，你的项目上线了！</p><hr><h3 id="💡-小知识快闪"><a href="#💡-小知识快闪" class="headerlink" title="💡 小知识快闪"></a>💡 小知识快闪</h3><ul><li>Docker 容器内部不包含完整操作系统，只包含必要的运行库；</li><li>Dockerfile 的每一行都是一层（Layer），构建时会缓存复用；</li><li><code>docker ps</code> 查看运行中容器，<code>docker images</code> 查看已有镜像；</li><li>可以通过 <code>.dockerignore</code> 文件忽略不想加入镜像的文件，比如 <code>.git</code> 和日志。</li></ul><hr><h3 id="⚔️-章节尾声：打破部署诅咒"><a href="#⚔️-章节尾声：打破部署诅咒" class="headerlink" title="⚔️ 章节尾声：打破部署诅咒"></a>⚔️ 章节尾声：打破部署诅咒</h3><p>这次，小李把打好的镜像发给了测试老赵：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5000:5000 my-flask-app</span><br></pre></td></tr></table></figure><p>老赵只运行了一行命令，项目便神奇地跑了起来。</p><blockquote><p>“不改配置？不用装 Python？数据库也连上了？”<br>“你这是什么魔法！”</p></blockquote><p>小李笑了笑，第一次感觉部署是件简单的事。</p><hr><h2 id="🧭-第一章总结知识点："><a href="#🧭-第一章总结知识点：" class="headerlink" title="🧭 第一章总结知识点："></a>🧭 第一章总结知识点：</h2><table><thead><tr><th>技术点</th><th>命令</th></tr></thead><tbody><tr><td>安装 Docker</td><td>Mac&#x2F;Win 下载 Docker Desktop &#x2F; Ubuntu 安装 <code>docker.io</code></td></tr><tr><td>查看版本</td><td><code>docker --version</code></td></tr><tr><td>运行测试容器</td><td><code>docker run hello-world</code></td></tr><tr><td>编写 Dockerfile</td><td>FROM &#x2F; COPY &#x2F; RUN &#x2F; CMD</td></tr><tr><td>构建镜像</td><td><code>docker build -t name .</code></td></tr><tr><td>运行容器</td><td><code>docker run -p 宿主:容器 镜像名</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;《无法部署的诅咒》讲的是-Docker-的起源与作用、镜像与容器概念、安装入门&quot;&gt;&lt;a href=&quot;#《无法部署的诅咒》讲的是-Docker-的起源与作用、镜像与容器概念、安装入门&quot; class=&quot;headerlink&quot; title=&quot;《无法部署的诅咒》讲的是 Docker 的起源与作用、镜像与容器概念、安装入门&quot;&gt;&lt;/a&gt;《无法部署的诅咒》讲的是 Docker 的起源与作用、镜像与容器概念、安装入门&lt;/h1&gt;&lt;h3 id=&quot;🏙️-开篇：代码在电脑上运行良好，部署却频频翻车&quot;&gt;&lt;a href=&quot;#🏙️-开篇：代码在电脑上运行良好，部署却频频翻车&quot; class=&quot;headerlink&quot; title=&quot;🏙️ 开篇：代码在电脑上运行良好，部署却频频翻车&quot;&gt;&lt;/a&gt;🏙️ 开篇：代码在电脑上运行良好，部署却频频翻车&lt;/h3&gt;&lt;p&gt;小李是一名后端工程师，刚完成一个用 Flask 编写的内部管理系统。他信心满满地将代码提交，交给测试工程师老赵部署。&lt;/p&gt;
&lt;p&gt;可没想到——&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“报错了！你是不是少传文件了？”&lt;/p&gt;
&lt;p&gt;“我这边 Python 是 3.6，怎么你这代码用了 &lt;code&gt;match case&lt;/code&gt;？”&lt;/p&gt;
&lt;p&gt;“你数据库呢？你 Redis 配了？环境变量在哪？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一刻，小李陷入了一个叫「部署地狱」的世界。&lt;/p&gt;
&lt;p&gt;这个世界里，每一台服务器都是独一无二的“宠物”，需要手动配置、手动部署、手动踩坑，稍有不慎就会陷入版本冲突、依赖缺失、环境不一致的深渊。&lt;/p&gt;
&lt;p&gt;小李心里想：&lt;strong&gt;有没有一种办法，能让我把代码和环境一起打包起来，无论在哪运行都能保持一致？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://xu-hardy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>写给懒猫微服玩家的容器小书 Docker篇（三）：《容器部落生活》</title>
    <link href="https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E3%80%8A%E5%AE%B9%E5%99%A8%E9%83%A8%E8%90%BD%E7%94%9F%E6%B4%BB%E3%80%8B/"/>
    <id>https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E3%80%8A%E5%AE%B9%E5%99%A8%E9%83%A8%E8%90%BD%E7%94%9F%E6%B4%BB%E3%80%8B/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《容器部落生活》讲的是-容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作"><a href="#《容器部落生活》讲的是-容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作" class="headerlink" title="《容器部落生活》讲的是 容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作"></a>《容器部落生活》讲的是 容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作</h1><blockquote><p>一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。</p></blockquote><p>镜像旅馆的旅途告一段落，小李的下一站是<strong>容器部落</strong>。</p><p>老周牵着他走过一条闪烁着数字光芒的通道，一排排运行中的应用像帐篷一样排列着。有人在调试日志，有人在重启服务，还有人用 <code>bash</code> 正在某个容器里“打补丁”。</p><p>老周说：</p><blockquote><p>“镜像只是静态的模板，<strong>容器才是它们的生命</strong>。容器是镜像运行出来的真实世界。”</p></blockquote><hr><h2 id="🧠-技术基础：容器-vs-镜像"><a href="#🧠-技术基础：容器-vs-镜像" class="headerlink" title="🧠 技术基础：容器 vs 镜像"></a>🧠 技术基础：容器 vs 镜像</h2><table><thead><tr><th>项目</th><th>镜像（Image）</th><th>容器（Container）</th></tr></thead><tbody><tr><td>类比</td><td>模板、配方</td><td>实际的运行实例</td></tr><tr><td>特性</td><td>只读</td><td>可读写</td></tr><tr><td>作用</td><td>用来创建容器</td><td>实际运行中的程序环境</td></tr><tr><td>状态</td><td>不运行</td><td>可运行、停止、销毁</td></tr></tbody></table><hr><span id="more"></span><h2 id="🛫-第一节：容器的启动方式"><a href="#🛫-第一节：容器的启动方式" class="headerlink" title="🛫 第一节：容器的启动方式"></a>🛫 第一节：容器的启动方式</h2><p>小李想运行他的 Flask 应用镜像。</p><p>老周告诉他：</p><blockquote><p>“运行镜像的命令是 <code>docker run</code>，容器就像是用镜像盖起来的一顶帐篷。”</p></blockquote><h3 id="1-最常见方式（临时-前台）："><a href="#1-最常见方式（临时-前台）：" class="headerlink" title="1. 最常见方式（临时 + 前台）："></a>1. 最常见方式（临时 + 前台）：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run my-flask-app</span><br></pre></td></tr></table></figure><p>但程序一执行完就退出了。小李困惑。</p><p>老周解释：</p><blockquote><p>“容器会在主进程结束后自动退出，比如 <code>CMD [&quot;python&quot;, &quot;main.py&quot;]</code> 一旦结束，容器就结束了。”</p></blockquote><hr><h3 id="2-保持后台运行（常用）"><a href="#2-保持后台运行（常用）" class="headerlink" title="2. 保持后台运行（常用）"></a>2. 保持后台运行（常用）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name flask-app -p 5000:5000 my-flask-app</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>-d</code>：detached 模式，后台运行</li><li><code>--name</code>：给容器取个名字，方便管理</li><li><code>-p 宿主端口:容器端口</code>：端口映射，把容器内部 5000 暴露到外部</li></ul><blockquote><p>小李可以在浏览器里访问 <code>http://localhost:5000</code>，服务在跑！</p></blockquote><hr><h3 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e ENV=production my-flask-app</span><br></pre></td></tr></table></figure><p>在容器内可通过 <code>os.environ[&#39;ENV&#39;]</code> 访问。</p><hr><h3 id="4-设置自动重启策略（生产强烈建议）"><a href="#4-设置自动重启策略（生产强烈建议）" class="headerlink" title="4. 设置自动重启策略（生产强烈建议）"></a>4. 设置自动重启策略（生产强烈建议）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always my-flask-app</span><br></pre></td></tr></table></figure><p>可选策略：</p><table><thead><tr><th>策略名</th><th>说明</th></tr></thead><tbody><tr><td><code>no</code></td><td>不自动重启（默认）</td></tr><tr><td><code>on-failure</code></td><td>出错时重启</td></tr><tr><td><code>always</code></td><td>永远重启</td></tr><tr><td><code>unless-stopped</code></td><td>除非人为停止</td></tr></tbody></table><hr><h2 id="🧭-第二节：查看容器状态"><a href="#🧭-第二节：查看容器状态" class="headerlink" title="🧭 第二节：查看容器状态"></a>🧭 第二节：查看容器状态</h2><p>老周说：“运行中的容器就像是火堆，你得学会看它们是否还在烧。”</p><h3 id="查看运行中容器："><a href="#查看运行中容器：" class="headerlink" title="查看运行中容器："></a>查看运行中容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果想看所有容器（包括已退出的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE           STATUS         NAMES</span><br><span class="line">f123abc456     my-flask-app    Up 3 minutes   flask-app</span><br></pre></td></tr></table></figure><hr><h2 id="🔄-第三节：容器的停止与重启"><a href="#🔄-第三节：容器的停止与重启" class="headerlink" title="🔄 第三节：容器的停止与重启"></a>🔄 第三节：容器的停止与重启</h2><h3 id="停止容器："><a href="#停止容器：" class="headerlink" title="停止容器："></a>停止容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop flask-app</span><br></pre></td></tr></table></figure><h3 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start flask-app</span><br></pre></td></tr></table></figure><h3 id="重启容器："><a href="#重启容器：" class="headerlink" title="重启容器："></a>重启容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart flask-app</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 容器停止后并不会删除，除非显式用 <code>docker rm</code></p></blockquote><hr><h2 id="🧰-第四节：进入容器内“远程调试”"><a href="#🧰-第四节：进入容器内“远程调试”" class="headerlink" title="🧰 第四节：进入容器内“远程调试”"></a>🧰 第四节：进入容器内“远程调试”</h2><p>有一次小李发现容器里缺了个配置文件，他想进去看看。</p><h3 id="使用-exec-进入运行中的容器："><a href="#使用-exec-进入运行中的容器：" class="headerlink" title="使用 exec 进入运行中的容器："></a>使用 exec 进入运行中的容器：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it flask-app /bin/bash</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>：保持输入</li><li><code>-t</code>：分配终端</li><li><code>/bin/bash</code>：使用 bash shell（Alpine 镜像可能要用 <code>/bin/sh</code>）</li></ul><blockquote><p>现在他能像 SSH 进服务器一样，在容器里操作文件、日志、环境变量。</p></blockquote><hr><h2 id="📜-第五节：查看容器日志"><a href="#📜-第五节：查看容器日志" class="headerlink" title="📜 第五节：查看容器日志"></a>📜 第五节：查看容器日志</h2><p>某天应用崩溃了，小李要调日志。</p><p>老周提醒他：“容器日志直接走标准输出和错误输出。”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs flask-app</span><br></pre></td></tr></table></figure><p>可以加参数看最近内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --<span class="built_in">tail</span> 100 flask-app</span><br></pre></td></tr></table></figure><p>实时滚动输出（调试很有用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f flask-app</span><br></pre></td></tr></table></figure><hr><h2 id="🧽-第六节：删除容器"><a href="#🧽-第六节：删除容器" class="headerlink" title="🧽 第六节：删除容器"></a>🧽 第六节：删除容器</h2><p>小李尝试重建容器时，系统提示名字重复。</p><p>老周告诉他要先删除原来的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> flask-app</span><br></pre></td></tr></table></figure><p>如果容器还在运行，先 <code>stop</code> 再 <code>rm</code>，或直接强制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f flask-app</span><br></pre></td></tr></table></figure><hr><h2 id="🔄-第七节：容器生命周期一览表"><a href="#🔄-第七节：容器生命周期一览表" class="headerlink" title="🔄 第七节：容器生命周期一览表"></a>🔄 第七节：容器生命周期一览表</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>创建 + 运行容器</td><td><code>docker run</code></td></tr><tr><td>后台运行</td><td><code>docker run -d</code></td></tr><tr><td>设置名字</td><td><code>docker run --name name</code></td></tr><tr><td>设置端口映射</td><td><code>-p 外:内</code></td></tr><tr><td>查看容器</td><td><code>docker ps [-a]</code></td></tr><tr><td>停止容器</td><td><code>docker stop name</code></td></tr><tr><td>启动容器</td><td><code>docker start name</code></td></tr><tr><td>重启容器</td><td><code>docker restart name</code></td></tr><tr><td>删除容器</td><td><code>docker rm [-f] name</code></td></tr><tr><td>查看日志</td><td><code>docker logs [-f] name</code></td></tr><tr><td>进入容器</td><td><code>docker exec -it name /bin/bash</code></td></tr></tbody></table><hr><h2 id="🧪-小李的实战练习任务"><a href="#🧪-小李的实战练习任务" class="headerlink" title="🧪 小李的实战练习任务"></a>🧪 小李的实战练习任务</h2><p>老周布置了一个练习：</p><blockquote><p>“请你写一个脚本，构建镜像，运行容器，设置环境变量和端口，再用日志确认 Flask 成功启动。”</p></blockquote><p>小李完成如下步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t flask-test .</span><br><span class="line">docker run -d --name flask-run -p 8080:5000 -e MODE=debug flask-test</span><br><span class="line">docker logs -f flask-run</span><br><span class="line">docker <span class="built_in">exec</span> -it flask-run /bin/bash</span><br></pre></td></tr></table></figure><hr><h2 id="🧬-衍生补充：容器的状态码解释"><a href="#🧬-衍生补充：容器的状态码解释" class="headerlink" title="🧬 衍生补充：容器的状态码解释"></a>🧬 衍生补充：容器的状态码解释</h2><p>容器退出时，可以用 <code>docker ps -a</code> 查看 <code>STATUS</code> 栏：</p><ul><li><code>Exited (0)</code>：正常退出</li><li><code>Exited (1)</code>：出错退出</li><li><code>Up</code>：正在运行</li></ul><p>调试时很有用。</p><hr><h2 id="🎬-尾声：容器部落里的秩序"><a href="#🎬-尾声：容器部落里的秩序" class="headerlink" title="🎬 尾声：容器部落里的秩序"></a>🎬 尾声：容器部落里的秩序</h2><p>小李现在已经能够用容器完成：</p><ul><li>应用部署</li><li>环境隔离</li><li>日志查看</li><li>重启容错</li><li>在线修复问题</li></ul><p>他看着容器部落中灯火通明的帐篷，知道自己终于从一个“只会打包镜像”的新人，成长为能驾驭容器生命周期的工程师。</p><p>老周拍拍他肩膀说：</p><blockquote><p>“你已经能掌控容器的生死了，下一步——掌控它们的数据。”</p></blockquote><p>好嘞，我们来拓展<strong>第三章《容器部落生活》</strong>，新增三大实战内容：</p><blockquote><p>🚀 Nginx 容器部署<br>🔗 多个容器配合运行（应用 + 数据库）<br>🩺 容器的服务探针（健康检查）</p></blockquote><p>这部分会继续以<strong>故事+实战命令+讲解</strong>的方式展开，帮助你更贴近真实工作中的容器部署流程。</p><hr><h2 id="🧱-实战一：Nginx-容器部署小站点"><a href="#🧱-实战一：Nginx-容器部署小站点" class="headerlink" title="🧱 实战一：Nginx 容器部署小站点"></a>🧱 实战一：Nginx 容器部署小站点</h2><p>小李想搭个静态站点测试，老周给他出了一个练习：</p><blockquote><p>“用 Nginx 容器部署一个 HTML 网站，只通过 Docker 完成。”</p></blockquote><h3 id="1-准备文件结构："><a href="#1-准备文件结构：" class="headerlink" title="1. 准备文件结构："></a>1. 准备文件结构：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx-site/</span><br><span class="line">├── index.html</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure><p><code>index.html</code> 示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello from Nginx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Docker + Nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Dockerfile-内容（基于官方-Nginx）："><a href="#2-Dockerfile-内容（基于官方-Nginx）：" class="headerlink" title="2. Dockerfile 内容（基于官方 Nginx）："></a>2. Dockerfile 内容（基于官方 Nginx）：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><blockquote><p>✅ 把自己的网页文件覆盖掉默认首页。</p></blockquote><h3 id="3-构建-运行："><a href="#3-构建-运行：" class="headerlink" title="3. 构建 + 运行："></a>3. 构建 + 运行：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx-site .</span><br><span class="line">docker run -d --name my-nginx -p 8080:80 nginx-site</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <code>http://localhost:8080</code>，小李看到页面显示成功，笑得像个孩子。</p><hr><h2 id="🔗-实战二：应用容器-数据库容器组合运行"><a href="#🔗-实战二：应用容器-数据库容器组合运行" class="headerlink" title="🔗 实战二：应用容器 + 数据库容器组合运行"></a>🔗 实战二：应用容器 + 数据库容器组合运行</h2><p>接着老周出了第二个任务：</p><blockquote><p>“把你的 Flask 应用和一个 MySQL 数据库用两个容器跑起来，实现数据连接。”</p></blockquote><h3 id="方法一：手动网络-多容器连接"><a href="#方法一：手动网络-多容器连接" class="headerlink" title="方法一：手动网络 + 多容器连接"></a>方法一：手动网络 + 多容器连接</h3><h4 id="1-创建网络（容器间通信）："><a href="#1-创建网络（容器间通信）：" class="headerlink" title="1. 创建网络（容器间通信）："></a>1. 创建网络（容器间通信）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create flask-net</span><br></pre></td></tr></table></figure><h4 id="2-启动-MySQL-容器："><a href="#2-启动-MySQL-容器：" class="headerlink" title="2. 启动 MySQL 容器："></a>2. 启动 MySQL 容器：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-mysql \</span><br><span class="line">  --network flask-net \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=root123 \</span><br><span class="line">  -e MYSQL_DATABASE=mydb \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure><h4 id="3-启动-Flask-应用容器（连接到-MySQL）："><a href="#3-启动-Flask-应用容器（连接到-MySQL）：" class="headerlink" title="3. 启动 Flask 应用容器（连接到 MySQL）："></a>3. 启动 Flask 应用容器（连接到 MySQL）：</h4><p>假设 Flask 连接数据库时使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">&#x27;my-mysql&#x27;</span>  <span class="comment"># 容器名就是主机名</span></span><br></pre></td></tr></table></figure><p>启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name flask-app \</span><br><span class="line">  --network flask-net \</span><br><span class="line">  -e DB_HOST=my-mysql \</span><br><span class="line">  -p 5000:5000 \</span><br><span class="line">  my-flask-app</span><br></pre></td></tr></table></figure><blockquote><p>🔗 容器间在同一个网络中，通过名字直接通信，像局域网一样！</p></blockquote><hr><h3 id="方法二：使用-docker-compose（下一章会详细讲）"><a href="#方法二：使用-docker-compose（下一章会详细讲）" class="headerlink" title="方法二：使用 docker-compose（下一章会详细讲）"></a>方法二：使用 <code>docker-compose</code>（下一章会详细讲）</h3><hr><h2 id="🩺-实战三：为容器添加“健康探针”"><a href="#🩺-实战三：为容器添加“健康探针”" class="headerlink" title="🩺 实战三：为容器添加“健康探针”"></a>🩺 实战三：为容器添加“健康探针”</h2><p>老周问小李：“如果你的服务挂了，但容器还在运行，你怎么知道？”</p><blockquote><p>小李摇头：这不就是“僵尸容器”吗？</p></blockquote><p>老周笑了：</p><blockquote><p>“那就给它<strong>加一个健康探针（HEALTHCHECK）</strong>，定期检测服务状态。”</p></blockquote><h3 id="为-Flask-容器加健康检查："><a href="#为-Flask-容器加健康检查：" class="headerlink" title="为 Flask 容器加健康检查："></a>为 Flask 容器加健康检查：</h3><p>修改 <code>Dockerfile</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=30s --<span class="built_in">timeout</span>=5s --start-period=5s --retries=3 \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:5000/health || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>在 Flask 代码中添加一个健康检查路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/health&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">health</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>, <span class="number">200</span></span><br></pre></td></tr></table></figure><p>构建镜像，运行容器后，通过命令查看健康状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect flask-app | grep -i health</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Health&quot;: &#123;</span><br><span class="line">  &quot;Status&quot;: &quot;healthy&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>/health</code> 接口返回失败状态码，容器会标记为 <code>&quot;unhealthy&quot;</code>，可配合自动重启策略联动修复。</p><hr><h2 id="🧭-实战拓展总结表"><a href="#🧭-实战拓展总结表" class="headerlink" title="🧭 实战拓展总结表"></a>🧭 实战拓展总结表</h2><table><thead><tr><th>场景</th><th>命令 &#x2F; 技术</th></tr></thead><tbody><tr><td>部署静态站点</td><td>Nginx + COPY index.html</td></tr><tr><td>容器间通信</td><td><code>docker network create</code> + <code>--network</code> 参数</td></tr><tr><td>多容器组合</td><td>应用容器连接数据库容器</td></tr><tr><td>服务探针</td><td>Dockerfile 添加 <code>HEALTHCHECK</code>，应用实现 <code>/health</code></td></tr><tr><td>探针状态查看</td><td>&#96;docker inspect 容器名</td></tr></tbody></table><hr><h2 id="🎬-尾声-·-容器集群的微光"><a href="#🎬-尾声-·-容器集群的微光" class="headerlink" title="🎬 尾声 · 容器集群的微光"></a>🎬 尾声 · 容器集群的微光</h2><p>小李站在容器部落的山丘上，看着成百上千个容器像城市灯火一样运转。</p><p>Nginx 做前端代理，Flask 作为后端逻辑，MySQL 管理数据，每个服务都是一块积木，有秩序、有协作。</p><p>老周淡淡说：</p><blockquote><p>“这只是单机的容器调度，真正的战场——在云上。”</p></blockquote><p>小李的眼里闪起光芒：“那我下次要学的就是——Compose，K8s，还有 CI&#x2F;CD，对吧？”</p><p>老周点头：“没错，下一站——数据卷与共享、Compose 编排，再之后……你就要去打云原生的战了。”</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;《容器部落生活》讲的是-容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作&quot;&gt;&lt;a href=&quot;#《容器部落生活》讲的是-容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作&quot; class=&quot;headerlink&quot; title=&quot;《容器部落生活》讲的是 容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作&quot;&gt;&lt;/a&gt;《容器部落生活》讲的是 容器生命周期管理，包括容器的启动、停止、查看、交互、日志、后台运行、重启策略等操作&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;镜像旅馆的旅途告一段落，小李的下一站是&lt;strong&gt;容器部落&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;老周牵着他走过一条闪烁着数字光芒的通道，一排排运行中的应用像帐篷一样排列着。有人在调试日志，有人在重启服务，还有人用 &lt;code&gt;bash&lt;/code&gt; 正在某个容器里“打补丁”。&lt;/p&gt;
&lt;p&gt;老周说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“镜像只是静态的模板，&lt;strong&gt;容器才是它们的生命&lt;/strong&gt;。容器是镜像运行出来的真实世界。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🧠-技术基础：容器-vs-镜像&quot;&gt;&lt;a href=&quot;#🧠-技术基础：容器-vs-镜像&quot; class=&quot;headerlink&quot; title=&quot;🧠 技术基础：容器 vs 镜像&quot;&gt;&lt;/a&gt;🧠 技术基础：容器 vs 镜像&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;镜像（Image）&lt;/th&gt;
&lt;th&gt;容器（Container）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;类比&lt;/td&gt;
&lt;td&gt;模板、配方&lt;/td&gt;
&lt;td&gt;实际的运行实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;特性&lt;/td&gt;
&lt;td&gt;只读&lt;/td&gt;
&lt;td&gt;可读写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;用来创建容器&lt;/td&gt;
&lt;td&gt;实际运行中的程序环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;状态&lt;/td&gt;
&lt;td&gt;不运行&lt;/td&gt;
&lt;td&gt;可运行、停止、销毁&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://xu-hardy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>写给懒猫微服玩家的容器小书 Docker篇（二）：《镜像旅馆的秘密》</title>
    <link href="https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E3%80%8A%E9%95%9C%E5%83%8F%E6%97%85%E9%A6%86%E7%9A%84%E7%A7%98%E5%AF%86%E3%80%8B/"/>
    <id>https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E3%80%8A%E9%95%9C%E5%83%8F%E6%97%85%E9%A6%86%E7%9A%84%E7%A7%98%E5%AF%86%E3%80%8B/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。</p></blockquote><h1 id="《镜像旅馆的秘密》讲的是-Docker-镜像的原理、分层结构、生命周期、Docker-Hub-上传与下载、常见镜像命令详解"><a href="#《镜像旅馆的秘密》讲的是-Docker-镜像的原理、分层结构、生命周期、Docker-Hub-上传与下载、常见镜像命令详解" class="headerlink" title="《镜像旅馆的秘密》讲的是 Docker 镜像的原理、分层结构、生命周期、Docker Hub 上传与下载、常见镜像命令详解"></a>《镜像旅馆的秘密》讲的是 Docker 镜像的原理、分层结构、生命周期、Docker Hub 上传与下载、常见镜像命令详解</h1><h3 id="🏰-开篇：进入镜像旅馆"><a href="#🏰-开篇：进入镜像旅馆" class="headerlink" title="🏰 开篇：进入镜像旅馆"></a>🏰 开篇：进入镜像旅馆</h3><p>自从小李用 Docker 成功打包并运行了自己的 Flask 项目，他的开发效率飞快提高。</p><p>某天，老周带他来到一座巨大的数字建筑——<strong>Docker 镜像旅馆</strong>。</p><p>“这是你所有镜像的家，”老周说，“也是全球程序员共享旅程资源的中转站。”</p><p>镜像旅馆里，层层叠叠地存放着成千上万个镜像，就像一栋模块化的高楼大厦。</p><hr><h3 id="🧱-镜像的本质：一层一层搭起来的文件系统"><a href="#🧱-镜像的本质：一层一层搭起来的文件系统" class="headerlink" title="🧱 镜像的本质：一层一层搭起来的文件系统"></a>🧱 镜像的本质：一层一层搭起来的文件系统</h3><p>老周告诉小李：</p><blockquote><p>“镜像（Image）其实是一个<strong>只读的分层文件系统</strong>。你写的每一条 Dockerfile 指令，都会构成一层 Layer。”</p></blockquote><p>比如这个简单的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>对应的镜像层如下：</p><ol><li><code>FROM</code> → 拉了一个基础镜像层（Python 3.11）</li><li><code>WORKDIR</code> → 添加一个设置工作目录的 Layer</li><li><code>COPY</code> → 拷贝代码文件的 Layer</li><li><code>RUN</code> → 安装依赖的新 Layer</li><li><code>CMD</code> → 容器入口（不是 Layer，但存配置）</li></ol><blockquote><p>💡 小知识：Docker 会尽量缓存和复用前面的 Layer，节省时间和存储。</p></blockquote><hr><h3 id="🧪-镜像命令全攻略"><a href="#🧪-镜像命令全攻略" class="headerlink" title="🧪 镜像命令全攻略"></a>🧪 镜像命令全攻略</h3><p>小李打开终端，开始探索这些镜像的日常操作。</p><h4 id="1-查看本地镜像："><a href="#1-查看本地镜像：" class="headerlink" title="1. 查看本地镜像："></a>1. 查看本地镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY     TAG        IMAGE ID       CREATED          SIZE</span><br><span class="line">my-flask-app   latest     123abc456def   2 minutes ago    125MB</span><br><span class="line">python         3.11-slim  789xyz654hij   3 days ago       40MB</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>REPOSITORY</code>：镜像名</li><li><code>TAG</code>：标签（版本号）</li><li><code>IMAGE ID</code>：镜像唯一标识符</li><li><code>SIZE</code>：镜像大小</li></ul><h4 id="2-查看镜像历史构建过程（看每层）："><a href="#2-查看镜像历史构建过程（看每层）：" class="headerlink" title="2. 查看镜像历史构建过程（看每层）："></a>2. 查看镜像历史构建过程（看每层）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> my-flask-app</span><br></pre></td></tr></table></figure><h4 id="3-删除镜像："><a href="#3-删除镜像：" class="headerlink" title="3. 删除镜像："></a>3. 删除镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi my-flask-app</span><br></pre></td></tr></table></figure><p>（⚠️ 若有容器在运行该镜像，需先停止并删除容器）</p><hr><h3 id="🗂-镜像仓库：Docker-Hub"><a href="#🗂-镜像仓库：Docker-Hub" class="headerlink" title="🗂 镜像仓库：Docker Hub"></a>🗂 镜像仓库：Docker Hub</h3><p>老周指了指旅馆大堂里的一个巨大电梯：</p><blockquote><p>“这是 Docker Hub，全球最大的镜像共享仓库。”</p></blockquote><p>在这里，小李能下载成千上万的开源镜像，也能上传自己的。</p><h4 id="登录-Docker-Hub："><a href="#登录-Docker-Hub：" class="headerlink" title="登录 Docker Hub："></a>登录 Docker Hub：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p>（需要先注册账号）</p><h4 id="下载镜像："><a href="#下载镜像：" class="headerlink" title="下载镜像："></a>下载镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>这会从 Docker Hub 拉取最新版本的 <code>nginx</code> 镜像</p><h4 id="指定版本拉取："><a href="#指定版本拉取：" class="headerlink" title="指定版本拉取："></a>指定版本拉取：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:6.2</span><br></pre></td></tr></table></figure><blockquote><p>如果 docker run&#x2F;pull 有问题，那么可以通过<code>lzc-cli appstore copy-image your-images</code>来使用懒猫的镜像仓库。</p></blockquote><p>（相当于拉取 <code>redis</code> 仓库中 tag 为 <code>6.2</code> 的镜像）</p><h4 id="上传镜像（先打标签）："><a href="#上传镜像（先打标签）：" class="headerlink" title="上传镜像（先打标签）："></a>上传镜像（先打标签）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag my-flask-app yourdockerhubname/my-flask-app:1.0</span><br><span class="line">docker push yourdockerhubname/my-flask-app:1.0</span><br></pre></td></tr></table></figure><hr><h3 id="📦-镜像-Tag-与版本控制"><a href="#📦-镜像-Tag-与版本控制" class="headerlink" title="📦 镜像 Tag 与版本控制"></a>📦 镜像 Tag 与版本控制</h3><p>老周问：“小李，你知道为什么镜像都有个 <code>:latest</code> 吗？”</p><p>小李说：“这是默认版本号吧？”</p><p>“对，但我们不能依赖它。<strong>开发、测试、生产应使用明确版本号，比如 1.0、20240321 等</strong>。”</p><p>Docker 镜像是通过 <code>tag</code> 来区分版本的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp:1.0 .</span><br><span class="line">docker build -t myapp:latest .</span><br></pre></td></tr></table></figure><p>你可以为同一个镜像打多个标签，对应不同场景使用。</p><hr><h3 id="🔍-镜像体积优化技巧"><a href="#🔍-镜像体积优化技巧" class="headerlink" title="🔍 镜像体积优化技巧"></a>🔍 镜像体积优化技巧</h3><p>小李注意到镜像越来越大了，占了很多硬盘空间。</p><p>老周给了他几点建议：</p><ol><li><p>使用轻量级基础镜像：</p><ul><li>比如 <code>python:3.11-slim</code> 代替 <code>python:3.11</code></li></ul></li><li><p>合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN</span><br></pre></td></tr></table></figure><p>命令，减少层数：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y git &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure></li><li><p>删除临时文件：</p><ul><li>安装后清理缓存，避免垃圾文件残留</li></ul></li><li><p>多阶段构建（进阶）：</p><ul><li>构建和运行使用不同的镜像阶段</li></ul></li></ol><hr><h3 id="📂-镜像保存与迁移"><a href="#📂-镜像保存与迁移" class="headerlink" title="📂 镜像保存与迁移"></a>📂 镜像保存与迁移</h3><p>后来小李想把自己的镜像传给另一位没有 Docker Hub 的同事。</p><p>他用到了镜像导出与导入：</p><h4 id="导出镜像为-tar-文件："><a href="#导出镜像为-tar-文件：" class="headerlink" title="导出镜像为 .tar 文件："></a>导出镜像为 <code>.tar</code> 文件：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my-flask-app &gt; myapp.tar</span><br></pre></td></tr></table></figure><h4 id="导入镜像："><a href="#导入镜像：" class="headerlink" title="导入镜像："></a>导入镜像：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; myapp.tar</span><br></pre></td></tr></table></figure><p>镜像打包成离线文件，便于携带与备份。</p><hr><h3 id="🔍-深入-Layer-实战：查看镜像内容"><a href="#🔍-深入-Layer-实战：查看镜像内容" class="headerlink" title="🔍 深入 Layer 实战：查看镜像内容"></a>🔍 深入 Layer 实战：查看镜像内容</h3><p>小李很好奇，镜像到底长什么样？</p><p>老周教他运行容器并进到里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> my-flask-app /bin/bash</span><br></pre></td></tr></table></figure><p>这样他就能直接进入容器的 Linux 环境，像在服务器上一样查看文件结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /</span><br><span class="line"><span class="built_in">cd</span> /app</span><br><span class="line"><span class="built_in">cat</span> requirements.txt</span><br></pre></td></tr></table></figure><p>他终于明白，每个镜像就像是一个“静态快照”，而容器才是“它的动态运行副本”。</p><hr><h3 id="📊-镜像生命周期总结表"><a href="#📊-镜像生命周期总结表" class="headerlink" title="📊 镜像生命周期总结表"></a>📊 镜像生命周期总结表</h3><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>查看本地镜像</td><td><code>docker images</code></td></tr><tr><td>构建新镜像</td><td><code>docker build -t name .</code></td></tr><tr><td>删除镜像</td><td><code>docker rmi 镜像名</code></td></tr><tr><td>下载镜像</td><td><code>docker pull 镜像名[:tag]</code></td></tr><tr><td>上传镜像</td><td><code>docker push 镜像名[:tag]</code></td></tr><tr><td>镜像打包导出</td><td><code>docker save &gt; xxx.tar</code></td></tr><tr><td>镜像导入还原</td><td><code>docker load &lt; xxx.tar</code></td></tr><tr><td>镜像历史层查看</td><td><code>docker history 镜像名</code></td></tr></tbody></table><hr><h3 id="🎬-尾声：镜像旅馆的门票"><a href="#🎬-尾声：镜像旅馆的门票" class="headerlink" title="🎬 尾声：镜像旅馆的门票"></a>🎬 尾声：镜像旅馆的门票</h3><p>小李现在拥有了多个镜像，搭配不同的版本、依赖、语言，像积木一样可以快速组合各种环境。</p><p>“这就像 Minecraft 的世界地图，每张都是一个镜像。”小李说。</p><p>老周点点头：“没错，镜像只是开始，真正的冒险——是容器运行起来后的世界。”</p><hr><h2 id="🧭-第二章小结"><a href="#🧭-第二章小结" class="headerlink" title="🧭 第二章小结"></a>🧭 第二章小结</h2><ul><li>镜像是构建环境的基础模板，支持版本控制、缓存加速、快速构建</li><li>可以上传到 Docker Hub 或导出 <code>.tar</code> 进行离线传输</li><li>管理命令要熟练掌握：<code>build</code>、<code>pull</code>、<code>push</code>、<code>rmi</code>、<code>tag</code>、<code>history</code></li><li>优化镜像大小要用 slim 基础镜像、合并命令、清理缓存</li></ul><h2 id="✨-增补内容：镜像的高级技能与实战应用"><a href="#✨-增补内容：镜像的高级技能与实战应用" class="headerlink" title="✨ 增补内容：镜像的高级技能与实战应用"></a>✨ 增补内容：镜像的高级技能与实战应用</h2><hr><h3 id="🧪-多阶段构建：精致分工，极限瘦身"><a href="#🧪-多阶段构建：精致分工，极限瘦身" class="headerlink" title="🧪 多阶段构建：精致分工，极限瘦身"></a>🧪 多阶段构建：精致分工，极限瘦身</h3><p>有一次，小李需要构建一个使用 <code>npm</code> 打包前端、Python 启动后端的项目。打包工具很多、依赖也重，他担心镜像太大。</p><p>老周说：“你要学会<strong>多阶段构建（multi-stage build）</strong>，把构建阶段和运行阶段分开。”</p><blockquote><p>多阶段构建的目标是：<strong>编译用谁都行，最终镜像要最小。</strong></p></blockquote><h4 id="示例：Node-构建-nginx-托管"><a href="#示例：Node-构建-nginx-托管" class="headerlink" title="示例：Node 构建 + nginx 托管"></a>示例：Node 构建 + nginx 托管</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：使用 node 构建前端</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install &amp;&amp; npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：用 nginx 托管打包后的静态文件</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><ul><li>第一阶段装依赖、打包代码</li><li>第二阶段只取编译结果，<strong>不用带上 node&#x2F;npm 等工具</strong></li></ul><p>小李一测试，镜像体积从 300MB 降到 25MB，部署速度快了 10 倍！</p><hr><h3 id="🧩-使用-dockerignore：镜像防垃圾机制"><a href="#🧩-使用-dockerignore：镜像防垃圾机制" class="headerlink" title="🧩 使用 .dockerignore：镜像防垃圾机制"></a>🧩 使用 <code>.dockerignore</code>：镜像防垃圾机制</h3><p>构建时，小李发现镜像中夹杂了 <code>.git</code>、<code>node_modules</code>、<code>__pycache__</code>……</p><p>老周摇头道：“你忘了 <code>.dockerignore</code> 文件。”</p><p>就像 <code>.gitignore</code> 一样，<code>.dockerignore</code> 告诉 Docker 哪些文件在构建镜像时要排除。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__pycache__/</span><br><span class="line">.git/</span><br><span class="line">node_modules/</span><br><span class="line">.env</span><br><span class="line">*.log</span><br></pre></td></tr></table></figure><p>这个文件放在 Dockerfile 同目录下，<strong>能显著加快构建速度和减小镜像大小</strong>。</p><hr><h3 id="📦-自建私有镜像仓库（Registry）"><a href="#📦-自建私有镜像仓库（Registry）" class="headerlink" title="📦 自建私有镜像仓库（Registry）"></a>📦 自建私有镜像仓库（Registry）</h3><p>当公司禁止使用 Docker Hub 时，小李开始尝试搭建自己的镜像库。</p><p>老周带他部署了一个本地私有镜像仓库（基于 Docker 官方镜像）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry:2</span><br></pre></td></tr></table></figure><p>现在他可以：</p><ul><li><p>推送到私库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag myapp localhost:5000/myapp</span><br><span class="line">docker push localhost:5000/myapp</span><br></pre></td></tr></table></figure></li><li><p>拉取镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull localhost:5000/myapp</span><br></pre></td></tr></table></figure></li></ul><p>适合公司内部使用，搭配 Nexus、Harbor 可实现更完善的权限、审计、镜像管理等功能。（比如懒猫的 copy-image）</p><h3 id="🧠-镜像调试技巧：如何从镜像中探查问题？"><a href="#🧠-镜像调试技巧：如何从镜像中探查问题？" class="headerlink" title="🧠 镜像调试技巧：如何从镜像中探查问题？"></a>🧠 镜像调试技巧：如何从镜像中探查问题？</h3><p>如果小李的镜像出错了，他可以通过两种方式“探测”镜像内部：</p><h4 id="方法-1：运行一个交互式-shell-容器"><a href="#方法-1：运行一个交互式-shell-容器" class="headerlink" title="方法 1：运行一个交互式 shell 容器"></a>方法 1：运行一个交互式 shell 容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it myapp /bin/bash</span><br></pre></td></tr></table></figure><p>（如果 bash 不存在，可以用 <code>/bin/sh</code>）</p><h4 id="方法-2：打开已有容器的终端"><a href="#方法-2：打开已有容器的终端" class="headerlink" title="方法 2：打开已有容器的终端"></a>方法 2：打开已有容器的终端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it container_id /bin/bash</span><br></pre></td></tr></table></figure><p>通过 <code>ls</code>、<code>cat</code>、<code>which</code>、<code>env</code> 命令，可以检查：</p><ul><li>文件有没有 COPY 进去？</li><li><code>pip install</code> 是否安装成功？</li><li>环境变量是否丢失？</li></ul><hr><h3 id="🔐-镜像安全：不要把密码打包进镜像！"><a href="#🔐-镜像安全：不要把密码打包进镜像！" class="headerlink" title="🔐 镜像安全：不要把密码打包进镜像！"></a>🔐 镜像安全：不要把密码打包进镜像！</h3><p>小李曾在 Dockerfile 里写了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DB_PASSWORD=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>老周当场拍桌：“你这是把钥匙写死进容器了！”</p><p>最佳做法：</p><ul><li>在容器运行时注入环境变量（例如使用 <code>.env</code> 文件 + <code>--env</code> 参数）</li><li>使用 <code>docker secret</code> 或 KMS 管理</li><li>使用 BuildKit 的 <code>--secret</code> 机制加密构建时参数（高级用法）</li></ul><hr><h3 id="🧾-镜像标签管理规范建议"><a href="#🧾-镜像标签管理规范建议" class="headerlink" title="🧾 镜像标签管理规范建议"></a>🧾 镜像标签管理规范建议</h3><p>小李准备上线，他开始给镜像打各种 tag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myapp:1.0.0 .</span><br><span class="line">docker tag myapp:1.0.0 myapp:latest</span><br></pre></td></tr></table></figure><p>老周说：</p><blockquote><p>“tag 是镜像的版本名，不要用 <code>latest</code> 作为生产环境唯一标识。”</p></blockquote><p>推荐命名规范：</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td><code>myapp:1.0.0</code></td><td>语义化版本控制</td></tr><tr><td><code>myapp:20240324</code></td><td>构建时间戳</td></tr><tr><td><code>myapp:prod</code></td><td>环境标识</td></tr><tr><td><code>myapp:feature-login</code></td><td>功能分支测试</td></tr></tbody></table><hr><h3 id="🔁-镜像缓存失效调试技巧"><a href="#🔁-镜像缓存失效调试技巧" class="headerlink" title="🔁 镜像缓存失效调试技巧"></a>🔁 镜像缓存失效调试技巧</h3><p>有时候构建镜像时，小李发现修改了某个文件，Docker 却好像没更新。</p><p>老周点拨他：“那是缓存搞的鬼。”</p><h4 id="方法一：强制跳过缓存"><a href="#方法一：强制跳过缓存" class="headerlink" title="方法一：强制跳过缓存"></a>方法一：强制跳过缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t myapp .</span><br></pre></td></tr></table></figure><h4 id="方法二：注意-COPY-顺序影响缓存命中"><a href="#方法二：注意-COPY-顺序影响缓存命中" class="headerlink" title="方法二：注意 COPY 顺序影响缓存命中"></a>方法二：注意 COPY 顺序影响缓存命中</h4><p>Docker 会从上到下按顺序缓存。如果把变化频繁的文件 COPY 太早，就会导致缓存失效：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .      <span class="comment"># OK，变动少，适合先复制</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .                     <span class="comment"># 后复制代码，避免频繁无效重建</span></span></span><br></pre></td></tr></table></figure><blockquote><p>✨ 技巧：越是稳定的文件，越早 COPY，利于缓存复用。</p></blockquote><hr><h2 id="📘-第二章-·-补充总结更新版"><a href="#📘-第二章-·-补充总结更新版" class="headerlink" title="📘 第二章 · 补充总结更新版"></a>📘 第二章 · 补充总结更新版</h2><table><thead><tr><th>技术点</th><th>命令 &#x2F; 说明</th></tr></thead><tbody><tr><td>多阶段构建</td><td><code>FROM ... AS builder</code> + <code>COPY --from=builder</code></td></tr><tr><td>忽略文件</td><td><code>.dockerignore</code> 文件</td></tr><tr><td>镜像上传私库</td><td><code>docker push localhost:5000/myapp</code></td></tr><tr><td>开启 BuildKit</td><td><code>DOCKER_BUILDKIT=1 docker build ...</code></td></tr><tr><td>进入镜像内调试</td><td><code>docker run -it 镜像 /bin/bash</code></td></tr><tr><td>镜像版本管理建议</td><td>避免乱用 <code>latest</code>，使用语义化 tag</td></tr><tr><td>跳过缓存构建</td><td><code>docker build --no-cache ...</code></td></tr></tbody></table><hr><p>小李站在镜像旅馆的屋顶，看着一层层高楼像乐高积木一样堆叠而起。</p><p>他感到激动——他已经不再为“部署”苦恼，而是拥有了一个随时可打包、可还原的开发宇宙。</p><p>老周说：“你的旅程才刚刚开始，容器的世界比镜像更复杂。”</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;《镜像旅馆的秘密》讲的是-Docker-镜像的原理、分层结构、生命周期、Docker-Hub-上传与下载、常见镜像命令详解&quot;&gt;&lt;a href=&quot;#《镜像旅馆的秘密》讲的是-Docker-镜像的原理、分层结构、生命周期、Docker-Hub-上传与下载、常见镜像命令详解&quot; class=&quot;headerlink&quot; title=&quot;《镜像旅馆的秘密》讲的是 Docker 镜像的原理、分层结构、生命周期、Docker Hub 上传与下载、常见镜像命令详解&quot;&gt;&lt;/a&gt;《镜像旅馆的秘密》讲的是 Docker 镜像的原理、分层结构、生命周期、Docker Hub 上传与下载、常见镜像命令详解&lt;/h1&gt;&lt;h3 id=&quot;🏰-开篇：进入镜像旅馆&quot;&gt;&lt;a href=&quot;#🏰-开篇：进入镜像旅馆&quot; class=&quot;headerlink&quot; title=&quot;🏰 开篇：进入镜像旅馆&quot;&gt;&lt;/a&gt;🏰 开篇：进入镜像旅馆&lt;/h3&gt;&lt;p&gt;自从小李用 Docker 成功打包并运行了自己的 Flask 项目，他的开发效率飞快提高。&lt;/p&gt;
&lt;p&gt;某天，老周带他来到一座巨大的数字建筑——&lt;strong&gt;Docker 镜像旅馆&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;“这是你所有镜像的家，”老周说，“也是全球程序员共享旅程资源的中转站。”&lt;/p&gt;
&lt;p&gt;镜像旅馆里，层层叠叠地存放着成千上万个镜像，就像一栋模块化的高楼大厦。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;🧱-镜像的本质：一层一层搭起来的文件系统&quot;&gt;&lt;a href=&quot;#🧱-镜像的本质：一层一层搭起来的文件系统&quot; class=&quot;headerlink&quot; title=&quot;🧱 镜像的本质：一层一层搭起来的文件系统&quot;&gt;&lt;/a&gt;🧱 镜像的本质：一层一层搭起来的文件系统&lt;/h3&gt;&lt;p&gt;老周告诉小李：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“镜像（Image）其实是一个&lt;strong&gt;只读的分层文件系统&lt;/strong&gt;。你写的每一条 Dockerfile 指令，都会构成一层 Layer。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如这个简单的 Dockerfile：&lt;/p&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; python:&lt;span class=&quot;number&quot;&gt;3.11&lt;/span&gt;-slim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt; /app&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt; . /app&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt; pip install -r requirements.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&amp;quot;python&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;main.py&amp;quot;&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://xu-hardy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>写给懒猫微服玩家的容器小书 Docker篇（四）：《数据之岛与持久化卷》</title>
    <link href="https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E3%80%8A%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%B2%9B%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96%E5%8D%B7%E3%80%8B/"/>
    <id>https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6-docker%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E3%80%8A%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%B2%9B%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96%E5%8D%B7%E3%80%8B/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。</p></blockquote><h1 id="《数据之岛与持久化卷》讲的是-Docker-Volume-持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等"><a href="#《数据之岛与持久化卷》讲的是-Docker-Volume-持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等" class="headerlink" title="《数据之岛与持久化卷》讲的是 Docker Volume 持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等"></a>《数据之岛与持久化卷》讲的是 Docker Volume 持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等</h1><h3 id="🏝️-开篇：数据会随浪消失"><a href="#🏝️-开篇：数据会随浪消失" class="headerlink" title="🏝️ 开篇：数据会随浪消失"></a>🏝️ 开篇：数据会随浪消失</h3><p>有一天，小李运行了一个容器，里面的 Flask 项目能正常写入用户信息到 SQLite 数据库。可当容器一停止，再启动——所有数据消失了！</p><p>老周说：“你的数据，被潮水带走了。”</p><blockquote><p>“Docker 容器默认的文件系统是<strong>临时的</strong>，只要容器删除，数据也就没了。想让数据真正存活，就要登上‘<strong>数据之岛</strong>’。”</p></blockquote><hr><h2 id="🧠-基础概念：数据卷（Volume）"><a href="#🧠-基础概念：数据卷（Volume）" class="headerlink" title="🧠 基础概念：数据卷（Volume）"></a>🧠 基础概念：数据卷（Volume）</h2><p>Docker 提供了三种数据持久化方案：</p><table><thead><tr><th>方案</th><th>用法</th><th>场景</th></tr></thead><tbody><tr><td>Volume</td><td>Docker 管理的专属数据区</td><td>最推荐、安全、可多容器共享</td></tr><tr><td>Bind Mount</td><td>映射宿主机目录</td><td>更灵活，适合本地调试</td></tr><tr><td>tmpfs</td><td>临时存储在内存</td><td>适合敏感数据，重启即丢弃</td></tr></tbody></table><blockquote><p>本章重点讲解：<strong>Volume（数据卷）</strong> 与 <strong>Bind Mount（绑定挂载）</strong></p></blockquote><hr><span id="more"></span><h2 id="📦-第一节：使用-Volume-保存数据"><a href="#📦-第一节：使用-Volume-保存数据" class="headerlink" title="📦 第一节：使用 Volume 保存数据"></a>📦 第一节：使用 Volume 保存数据</h2><p>小李重新部署了 MySQL 容器，他决定为数据提供一个“保命空间”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create mysql-data</span><br></pre></td></tr></table></figure><p>然后运行 MySQL 时挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -v mysql-data:/var/lib/mysql \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p><code>-v 卷名:容器内目录</code>：将卷挂载到容器内数据库文件存储位置。</p></blockquote><p>容器即使删除，数据卷依然保留！</p><h3 id="查看所有卷："><a href="#查看所有卷：" class="headerlink" title="查看所有卷："></a>查看所有卷：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="查看卷详细信息："><a href="#查看卷详细信息：" class="headerlink" title="查看卷详细信息："></a>查看卷详细信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mysql-data</span><br></pre></td></tr></table></figure><p>输出中可以看到 <code>Mountpoint</code>，即数据在宿主机上的物理位置。</p><hr><h2 id="🧪-第二节：自动创建匿名-具名卷"><a href="#🧪-第二节：自动创建匿名-具名卷" class="headerlink" title="🧪 第二节：自动创建匿名&#x2F;具名卷"></a>🧪 第二节：自动创建匿名&#x2F;具名卷</h2><p>小李写了个简单的服务：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /app/data</span></span><br></pre></td></tr></table></figure><p>每次 <code>docker run</code> 时，Docker 会<strong>自动生成匿名卷</strong>挂载到 <code>/app/data</code>。</p><p>但这类匿名卷难以追踪、管理，老周建议：</p><blockquote><p>“生产环境请用<strong>具名卷</strong>，并在运行时用 <code>-v</code> 显式指定。”</p></blockquote><hr><h2 id="🔗-第三节：绑定挂载宿主机目录（本地调试神器）"><a href="#🔗-第三节：绑定挂载宿主机目录（本地调试神器）" class="headerlink" title="🔗 第三节：绑定挂载宿主机目录（本地调试神器）"></a>🔗 第三节：绑定挂载宿主机目录（本地调试神器）</h2><p>开发中，小李想把宿主机的项目代码直接挂进容器，不必每次重建镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name dev-nginx \</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  -v /Users/xiaoli/site:/usr/share/nginx/html \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><blockquote><p>本地 <code>/Users/xiaoli/site</code> 的代码实时反映在容器内网站目录，修改立刻生效！</p></blockquote><h3 id="使用-Bind-Mount-的场景："><a href="#使用-Bind-Mount-的场景：" class="headerlink" title="使用 Bind Mount 的场景："></a>使用 Bind Mount 的场景：</h3><ul><li>本地开发热更新</li><li>日志文件落盘</li><li>配置文件映射</li><li>IDE + 容器联调</li></ul><hr><h2 id="🤝-第四节：多个容器共享数据卷"><a href="#🤝-第四节：多个容器共享数据卷" class="headerlink" title="🤝 第四节：多个容器共享数据卷"></a>🤝 第四节：多个容器共享数据卷</h2><p>老周给小李展示了另一个高级玩法：</p><blockquote><p>“多个容器可以挂载同一个卷，<strong>共享数据</strong>，就像一块公共磁盘。”</p></blockquote><p>小李准备两个容器：</p><ul><li>一个容器写入日志</li><li>一个容器实时读取日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入容器</span></span><br><span class="line">docker run -d --name logger \</span><br><span class="line">  -v shared-logs:/logs \</span><br><span class="line">  busybox sh -c <span class="string">&quot;while true; do date &gt;&gt; /logs/t.log; sleep 2; done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取容器</span></span><br><span class="line">docker run -it --name reader \</span><br><span class="line">  -v shared-logs:/logs \</span><br><span class="line">  busybox <span class="built_in">tail</span> -f /logs/t.log</span><br></pre></td></tr></table></figure><p>这两个容器在不联网的情况下，通过挂载卷实现了<strong>数据同步</strong>，让小李直呼神奇。</p><hr><h2 id="🔄-第五节：备份与恢复数据卷"><a href="#🔄-第五节：备份与恢复数据卷" class="headerlink" title="🔄 第五节：备份与恢复数据卷"></a>🔄 第五节：备份与恢复数据卷</h2><p>老周说：</p><blockquote><p>“你现在的数据安全了，但还不够。万一服务器挂了怎么办？你得学会备份。”</p></blockquote><h3 id="备份数据卷为-tar："><a href="#备份数据卷为-tar：" class="headerlink" title="备份数据卷为 .tar："></a>备份数据卷为 <code>.tar</code>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> \</span><br><span class="line">  -v mysql-data:/data \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>):/backup \</span><br><span class="line">  busybox \</span><br><span class="line">  tar czf /backup/mysql-backup.tar.gz -C /data .</span><br></pre></td></tr></table></figure><blockquote><p>⛴️ 第一个挂载是数据卷，第二个挂载是宿主机当前目录，输出备份包。</p></blockquote><h3 id="恢复数据卷："><a href="#恢复数据卷：" class="headerlink" title="恢复数据卷："></a>恢复数据卷：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> \</span><br><span class="line">  -v mysql-data:/data \</span><br><span class="line">  -v $(<span class="built_in">pwd</span>):/backup \</span><br><span class="line">  busybox \</span><br><span class="line">  tar xzf /backup/mysql-backup.tar.gz -C /data</span><br></pre></td></tr></table></figure><p>只需备份 <code>.tar.gz</code> 文件即可，适合迁移数据、升级、容灾。</p><hr><h2 id="🧹-第六节：清理无用卷（慎用）"><a href="#🧹-第六节：清理无用卷（慎用）" class="headerlink" title="🧹 第六节：清理无用卷（慎用）"></a>🧹 第六节：清理无用卷（慎用）</h2><p>随着实验多了，小李电脑堆满了无主卷。</p><p>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> 卷名</span><br></pre></td></tr></table></figure><p>清除所有未被挂载的孤立卷（慎用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><blockquote><p>清理命令要慎重，别误删生产卷！</p></blockquote><hr><h2 id="📋-Volume-挂载选项速查表"><a href="#📋-Volume-挂载选项速查表" class="headerlink" title="📋 Volume 挂载选项速查表"></a>📋 Volume 挂载选项速查表</h2><table><thead><tr><th>类型</th><th>命令</th><th>特点</th></tr></thead><tbody><tr><td>匿名卷</td><td><code>-v /path</code></td><td>难追踪，系统自动命名</td></tr><tr><td>具名卷</td><td><code>-v myvol:/path</code></td><td>推荐用法，可管理</td></tr><tr><td>Bind 挂载</td><td><code>-v /host:/container</code></td><td>与宿主机文件交互，适合本地调试</td></tr><tr><td>tmpfs</td><td><code>--tmpfs /path</code></td><td>内存存储，重启即消失</td></tr><tr><td>权限控制</td><td><code>-v myvol:/path:ro</code></td><td>只读挂载</td></tr><tr><td>SELinux&#x2F;AppArmor</td><td><code>:z</code>、<code>:Z</code>（高级安全挂载）</td><td>安全增强场景</td></tr></tbody></table><hr><h2 id="🧠-小李的应用持久化策略建议"><a href="#🧠-小李的应用持久化策略建议" class="headerlink" title="🧠 小李的应用持久化策略建议"></a>🧠 小李的应用持久化策略建议</h2><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>数据库</td><td>必须挂载 Volume 保持数据持久</td></tr><tr><td>日志</td><td>推荐落盘到宿主机或集中采集</td></tr><tr><td>配置文件</td><td>可用 Bind Mount 从本地同步配置</td></tr><tr><td>静态资源</td><td>静态目录挂载 + CDN</td></tr><tr><td>临时缓存</td><td>tmpfs 或容器内路径，无需持久化</td></tr></tbody></table><hr><h2 id="🎬-尾声：构建自己的数据之岛"><a href="#🎬-尾声：构建自己的数据之岛" class="headerlink" title="🎬 尾声：构建自己的数据之岛"></a>🎬 尾声：构建自己的数据之岛</h2><p>小李站在一个小岛码头，身后是一个个挂载卷，他的应用和数据终于<strong>脱离容器生命周期的束缚</strong>。</p><p>老周说：</p><blockquote><p>“真正的服务，要能容器随时销毁，数据却永存。”</p></blockquote><p>小李点头，轻轻拍了拍他那卷 MySQL 的备份包，知道自己已经拥有了构建“数据之岛”的能力。</p><hr><p><strong>继续拓展高级内容</strong>，围绕：</p><ol><li>🧪 数据卷在 CI&#x2F;CD 中的作用和实战应用</li><li>☸️ 数据卷在 Kubernetes 中的延伸 —— PVC（PersistentVolumeClaim）挂载</li></ol><p>以小李的旅程为主线，继续带你掌握更强大的容器化数据策略。</p><hr><h2 id="🔧-拓展一：数据卷在-CI-CD-中的角色与实践"><a href="#🔧-拓展一：数据卷在-CI-CD-中的角色与实践" class="headerlink" title="🔧 拓展一：数据卷在 CI&#x2F;CD 中的角色与实践"></a>🔧 拓展一：数据卷在 CI&#x2F;CD 中的角色与实践</h2><p>在一次项目发布中，小李加入了公司的 DevOps 流水线。他发现 GitLab CI 跑测试时，每次都重新构建环境，速度太慢，还会出现缓存丢失的问题。</p><p>老周告诉他：</p><blockquote><p>“在 CI&#x2F;CD 环境中，<strong>合理使用数据卷</strong>可以极大加快构建速度、保留缓存和数据状态。”</p></blockquote><hr><h3 id="✅-使用场景-1：缓存-pip-npm-依赖，加速构建"><a href="#✅-使用场景-1：缓存-pip-npm-依赖，加速构建" class="headerlink" title="✅ 使用场景 1：缓存 pip&#x2F;npm 依赖，加速构建"></a>✅ 使用场景 1：缓存 pip&#x2F;npm 依赖，加速构建</h3><p>小李把 <code>pip install</code> 改成挂载缓存目录：</p><h4 id="GitLab-Runner-示例："><a href="#GitLab-Runner-示例：" class="headerlink" title="GitLab Runner 示例："></a>GitLab Runner 示例：</h4><p><code>.gitlab-ci.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">pip-cache</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.cache/pip</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">run</span> <span class="string">--rm</span></span><br><span class="line">      <span class="string">-v</span> <span class="string">$CI_PROJECT_DIR:/app</span></span><br><span class="line">      <span class="string">-v</span> <span class="string">$CI_PROJECT_DIR/.cache/pip:/root/.cache/pip</span></span><br><span class="line">      <span class="string">my-builder-image</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">      cd /app &amp;&amp;</span></span><br><span class="line"><span class="string">      pip install -r requirements.txt &amp;&amp;</span></span><br><span class="line"><span class="string">      pytest</span></span><br><span class="line"><span class="string">      &quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>🔁 依赖安装过程可被缓存，构建速度提升 50%！</p></blockquote><hr><h3 id="✅-使用场景-2：测试数据隔离"><a href="#✅-使用场景-2：测试数据隔离" class="headerlink" title="✅ 使用场景 2：测试数据隔离"></a>✅ 使用场景 2：测试数据隔离</h3><p>小李部署端到端自动化测试容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> \</span><br><span class="line">  -v test-volume:/app/test-results \</span><br><span class="line">  e2e-runner:latest</span><br></pre></td></tr></table></figure><p>测试结果可从宿主机挂载目录或卷中提取，用于后续报告生成或持久存档。</p><hr><h3 id="✅-使用场景-3：构建产物跨阶段传递"><a href="#✅-使用场景-3：构建产物跨阶段传递" class="headerlink" title="✅ 使用场景 3：构建产物跨阶段传递"></a>✅ 使用场景 3：构建产物跨阶段传递</h3><p>CI&#x2F;CD 有多阶段：构建 → 测试 → 部署<br>小李通过挂载共享卷，将编译好的前端包从构建容器传给部署容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name builder -v build-volume:/output frontend-builder</span><br><span class="line">docker run --<span class="built_in">rm</span> -v build-volume:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure><hr><h2 id="☸️-拓展二：Kubernetes-中的数据卷演进-——-PVC-实战"><a href="#☸️-拓展二：Kubernetes-中的数据卷演进-——-PVC-实战" class="headerlink" title="☸️ 拓展二：Kubernetes 中的数据卷演进 —— PVC 实战"></a>☸️ 拓展二：Kubernetes 中的数据卷演进 —— PVC 实战</h2><p>进入云原生世界，小李不再直接使用 <code>docker run</code>，而是通过 Kubernetes 来编排容器。</p><p>在 K8s 中，数据卷概念变得更专业：</p><ul><li>Volume（临时存储，随 Pod 生命周期）</li><li>PersistentVolume（PV：管理员创建的存储资源）</li><li>PersistentVolumeClaim（PVC：用户申请的存储）</li><li>StorageClass（存储策略模板）</li></ul><hr><h3 id="🔐-场景一：部署-Stateful-服务（如-MySQL）"><a href="#🔐-场景一：部署-Stateful-服务（如-MySQL）" class="headerlink" title="🔐 场景一：部署 Stateful 服务（如 MySQL）"></a>🔐 场景一：部署 Stateful 服务（如 MySQL）</h3><p>小李写了以下 YAML：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">standard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">mysql-pvc</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 PVC 是 “我要一个 5Gi 的盘”，PV 是“管理员给你一个”，Pod 中挂上它即可持久保存数据。</p></blockquote><hr><h3 id="🧠-小知识点：K8s-中-Volume-的对比"><a href="#🧠-小知识点：K8s-中-Volume-的对比" class="headerlink" title="🧠 小知识点：K8s 中 Volume 的对比"></a>🧠 小知识点：K8s 中 Volume 的对比</h3><table><thead><tr><th>类型</th><th>生命周期</th><th>是否持久</th><th>典型用途</th></tr></thead><tbody><tr><td>emptyDir</td><td>Pod 生命周期</td><td>❌</td><td>临时缓存、构建产物传递</td></tr><tr><td>hostPath</td><td>节点目录挂载</td><td>⚠️ 有风险</td><td>本地开发测试</td></tr><tr><td>PVC（推荐）</td><td>与集群存储绑定</td><td>✅</td><td>数据库存储、日志、持久缓存</td></tr></tbody></table><hr><h3 id="📦-StorageClass：自动动态分配-PVC"><a href="#📦-StorageClass：自动动态分配-PVC" class="headerlink" title="📦 StorageClass：自动动态分配 PVC"></a>📦 StorageClass：自动动态分配 PVC</h3><p>在云环境（如 EKS、GKE）中，PVC 可以自动创建对应的 PV（EBS、Ceph、NFS 等），只要指定 StorageClass 即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storageClassName:</span> <span class="string">gp2</span></span><br></pre></td></tr></table></figure><p>这种方式可以实现<strong>跨节点迁移不丢数据</strong>、<strong>按需付费扩容</strong>、<strong>快照备份等高级功能</strong>。</p><hr><h2 id="✅-拓展总结：Docker-到-CI-CD，再到-Kubernetes-的数据策略演进"><a href="#✅-拓展总结：Docker-到-CI-CD，再到-Kubernetes-的数据策略演进" class="headerlink" title="✅ 拓展总结：Docker 到 CI&#x2F;CD，再到 Kubernetes 的数据策略演进"></a>✅ 拓展总结：Docker 到 CI&#x2F;CD，再到 Kubernetes 的数据策略演进</h2><table><thead><tr><th>场景</th><th>技术</th><th>推荐做法</th></tr></thead><tbody><tr><td>本地开发</td><td>Bind Mount</td><td>映射目录，实时更新</td></tr><tr><td>本地持久化</td><td>Volume</td><td>隔离性好，便于管理</td></tr><tr><td>CI&#x2F;CD 中间数据</td><td>卷 &#x2F; 缓存目录</td><td>挂载 <code>.cache</code>、<code>build</code> 等路径</td></tr><tr><td>K8s 中数据存储</td><td>PVC + StorageClass</td><td>可扩展、可备份、可跨节点持久化</td></tr></tbody></table><hr><h2 id="🎬-尾声：从数据孤岛到分布式星图"><a href="#🎬-尾声：从数据孤岛到分布式星图" class="headerlink" title="🎬 尾声：从数据孤岛到分布式星图"></a>🎬 尾声：从数据孤岛到分布式星图</h2><p>在 DevOps 流水线中，小李用数据卷构建了无缝衔接的构建流程；</p><p>在 Kubernetes 集群中，他用 PVC 实现了跨集群节点的 MySQL 数据持久化部署；</p><p>他站在云端存储的星图前，知道自己已经掌握了从 Docker 到 DevOps 再到 Kubernetes 的数据生命周期。</p><p>老周拍拍他：</p><blockquote><p>“你已经造好了船，也撑起了帆。下一步，是用 Compose 编排你的舰队。”</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;《数据之岛与持久化卷》讲的是-Docker-Volume-持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等&quot;&gt;&lt;a href=&quot;#《数据之岛与持久化卷》讲的是-Docker-Volume-持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等&quot; class=&quot;headerlink&quot; title=&quot;《数据之岛与持久化卷》讲的是 Docker Volume 持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等&quot;&gt;&lt;/a&gt;《数据之岛与持久化卷》讲的是 Docker Volume 持久化数据方案、挂载宿主机目录、多个容器共享数据、自动创建卷、数据备份与恢复等&lt;/h1&gt;&lt;h3 id=&quot;🏝️-开篇：数据会随浪消失&quot;&gt;&lt;a href=&quot;#🏝️-开篇：数据会随浪消失&quot; class=&quot;headerlink&quot; title=&quot;🏝️ 开篇：数据会随浪消失&quot;&gt;&lt;/a&gt;🏝️ 开篇：数据会随浪消失&lt;/h3&gt;&lt;p&gt;有一天，小李运行了一个容器，里面的 Flask 项目能正常写入用户信息到 SQLite 数据库。可当容器一停止，再启动——所有数据消失了！&lt;/p&gt;
&lt;p&gt;老周说：“你的数据，被潮水带走了。”&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Docker 容器默认的文件系统是&lt;strong&gt;临时的&lt;/strong&gt;，只要容器删除，数据也就没了。想让数据真正存活，就要登上‘&lt;strong&gt;数据之岛&lt;/strong&gt;’。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🧠-基础概念：数据卷（Volume）&quot;&gt;&lt;a href=&quot;#🧠-基础概念：数据卷（Volume）&quot; class=&quot;headerlink&quot; title=&quot;🧠 基础概念：数据卷（Volume）&quot;&gt;&lt;/a&gt;🧠 基础概念：数据卷（Volume）&lt;/h2&gt;&lt;p&gt;Docker 提供了三种数据持久化方案：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Volume&lt;/td&gt;
&lt;td&gt;Docker 管理的专属数据区&lt;/td&gt;
&lt;td&gt;最推荐、安全、可多容器共享&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bind Mount&lt;/td&gt;
&lt;td&gt;映射宿主机目录&lt;/td&gt;
&lt;td&gt;更灵活，适合本地调试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tmpfs&lt;/td&gt;
&lt;td&gt;临时存储在内存&lt;/td&gt;
&lt;td&gt;适合敏感数据，重启即丢弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;本章重点讲解：&lt;strong&gt;Volume（数据卷）&lt;/strong&gt; 与 &lt;strong&gt;Bind Mount（绑定挂载）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://xu-hardy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>写给懒猫微服玩家的容器小书Docker篇（五）：《多容器交响曲：Docker Compose 上场》</title>
    <link href="https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6docker%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E3%80%8A%E5%A4%9A%E5%AE%B9%E5%99%A8%E4%BA%A4%E5%93%8D%E6%9B%B2%EF%BC%9Adocker-compose-%E4%B8%8A%E5%9C%BA%E3%80%8B/"/>
    <id>https://xu-hardy.github.io/%E5%86%99%E7%BB%99%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%8E%A9%E5%AE%B6%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B0%8F%E4%B9%A6docker%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E3%80%8A%E5%A4%9A%E5%AE%B9%E5%99%A8%E4%BA%A4%E5%93%8D%E6%9B%B2%EF%BC%9Adocker-compose-%E4%B8%8A%E5%9C%BA%E3%80%8B/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。</p></blockquote><h1 id="《多容器交响曲：Docker-Compose-上场》讲的是使用-Docker-Compose-统一编排多容器服务，理解-YAML-配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose-vs-K8s-初探等"><a href="#《多容器交响曲：Docker-Compose-上场》讲的是使用-Docker-Compose-统一编排多容器服务，理解-YAML-配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose-vs-K8s-初探等" class="headerlink" title="《多容器交响曲：Docker Compose 上场》讲的是使用 Docker Compose 统一编排多容器服务，理解 YAML 配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose vs K8s 初探等"></a>《多容器交响曲：Docker Compose 上场》讲的是使用 Docker Compose 统一编排多容器服务，理解 YAML 配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose vs K8s 初探等</h1><hr><h3 id="🎼-开篇：服务之间的管弦乐团"><a href="#🎼-开篇：服务之间的管弦乐团" class="headerlink" title="🎼 开篇：服务之间的管弦乐团"></a>🎼 开篇：服务之间的管弦乐团</h3><p>随着项目日益复杂，小李的服务已经不再是一个容器就能承载的了。</p><p>前端、后端、数据库、缓存、日志系统……像一个交响乐团，需要统一调度、和谐配合。</p><p>老周递给他一个新的工具：“<strong>Docker Compose</strong>——它是你的指挥棒。”</p><hr><h2 id="🎻-第一节：什么是-Docker-Compose？"><a href="#🎻-第一节：什么是-Docker-Compose？" class="headerlink" title="🎻 第一节：什么是 Docker Compose？"></a>🎻 第一节：什么是 Docker Compose？</h2><p>老周解释：</p><blockquote><p>“Docker Compose 是 Docker 的多容器编排工具，用一份 <code>docker-compose.yml</code> 文件，就能同时启动、停止、构建多个服务。”</p></blockquote><p>Compose 帮你解决：</p><ul><li>多个服务启动顺序</li><li>多容器共享网络</li><li>统一管理环境变量</li><li>配置简洁、开发者友好</li><li>跨平台部署一致</li></ul><hr><span id="more"></span><h2 id="📄-第二节：写出你的第一个-docker-compose-yml"><a href="#📄-第二节：写出你的第一个-docker-compose-yml" class="headerlink" title="📄 第二节：写出你的第一个 docker-compose.yml"></a>📄 第二节：写出你的第一个 <code>docker-compose.yml</code></h2><p>小李的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myapp/</span><br><span class="line">├── backend/      # Flask 应用</span><br><span class="line">│   ├── app.py</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">├── frontend/     # 静态页面</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">└── docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="docker-compose-yml-示例："><a href="#docker-compose-yml-示例：" class="headerlink" title="docker-compose.yml 示例："></a><code>docker-compose.yml</code> 示例：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./backend:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=db</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:80&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=mydb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dbdata:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">dbdata:</span></span><br></pre></td></tr></table></figure><blockquote><p>🔧 每个 <code>service</code> 就是一个容器定义，Compose 会为它们创建默认网络，自动 DNS 互通。</p></blockquote><hr><h2 id="🧪-第三节：Compose-命令实战速查"><a href="#🧪-第三节：Compose-命令实战速查" class="headerlink" title="🧪 第三节：Compose 命令实战速查"></a>🧪 第三节：Compose 命令实战速查</h2><p>小李在项目目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>后台启动所有服务！</p><p>其他常用命令：</p><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>构建镜像</td><td><code>docker-compose build</code></td></tr><tr><td>后台启动</td><td><code>docker-compose up -d</code></td></tr><tr><td>前台启动 + 日志输出</td><td><code>docker-compose up</code></td></tr><tr><td>停止服务</td><td><code>docker-compose down</code></td></tr><tr><td>查看容器日志</td><td><code>docker-compose logs [服务名]</code></td></tr><tr><td>重启某个服务</td><td><code>docker-compose restart 服务名</code></td></tr><tr><td>进入某个容器</td><td><code>docker-compose exec 服务名 bash</code></td></tr></tbody></table><hr><h2 id="📦-第四节：Compose-的网络与数据共享机制"><a href="#📦-第四节：Compose-的网络与数据共享机制" class="headerlink" title="📦 第四节：Compose 的网络与数据共享机制"></a>📦 第四节：Compose 的网络与数据共享机制</h2><p>老周介绍：</p><blockquote><p>“Compose 默认创建一个网络，<strong>所有服务能通过服务名互相访问</strong>。”</p></blockquote><p>在上面的例子中：</p><ul><li><code>backend</code> 容器可以用 <code>db:3306</code> 连接 MySQL</li><li><code>frontend</code> 可通过 <code>backend:5000</code> 访问后端 API</li></ul><blockquote><p>小李不再需要手动 <code>docker network create</code> 和 <code>--network</code> 参数，Compose 一切自动打通。</p></blockquote><h3 id="Volume-的挂载："><a href="#Volume-的挂载：" class="headerlink" title="Volume 的挂载："></a>Volume 的挂载：</h3><p>Compose 中的 volume 显式声明（如 <code>dbdata:</code>）会自动创建、管理。</p><p>支持：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./data:/data</span> <span class="comment"># Bind mount</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">myvolume:/data</span> <span class="comment"># Named volume</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/custom/path:/data:ro</span> <span class="comment"># 带权限控制</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌐-第五节：使用-env-管理配置变量"><a href="#🌐-第五节：使用-env-管理配置变量" class="headerlink" title="🌐 第五节：使用 .env 管理配置变量"></a>🌐 第五节：使用 <code>.env</code> 管理配置变量</h2><p>Compose 支持使用 <code>.env</code> 文件集中管理变量：</p><p><code>.env</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_PASSWORD=123456</span><br><span class="line">DB_NAME=mydb</span><br></pre></td></tr></table></figure><p>Compose 文件中使用方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=$&#123;DB_PASSWORD&#125;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=$&#123;DB_NAME&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>🚀 配合 CI&#x2F;CD 时 <code>.env</code> 可由流水线动态生成，便于多环境切换（dev&#x2F;stage&#x2F;prod）。</p></blockquote><hr><h2 id="🧬-第六节：高级配置技巧"><a href="#🧬-第六节：高级配置技巧" class="headerlink" title="🧬 第六节：高级配置技巧"></a>🧬 第六节：高级配置技巧</h2><h3 id="1-统一重启策略："><a href="#1-统一重启策略：" class="headerlink" title="1. 统一重启策略："></a>1. 统一重启策略：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p>确保服务宕机时能自动重启。</p><hr><h3 id="2-多阶段构建支持："><a href="#2-多阶段构建支持：" class="headerlink" title="2. 多阶段构建支持："></a>2. 多阶段构建支持：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">./backend</span></span><br><span class="line">  <span class="attr">dockerfile:</span> <span class="string">Dockerfile.prod</span></span><br></pre></td></tr></table></figure><p>可指定构建路径、Dockerfile 文件、构建参数等。</p><hr><h3 id="3-Healthcheck-健康检查："><a href="#3-Healthcheck-健康检查：" class="headerlink" title="3. Healthcheck 健康检查："></a>3. Healthcheck 健康检查：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:5000/health&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h2 id="🆚-第七节：Docker-Compose-vs-Kubernetes-简析"><a href="#🆚-第七节：Docker-Compose-vs-Kubernetes-简析" class="headerlink" title="🆚 第七节：Docker Compose vs Kubernetes 简析"></a>🆚 第七节：Docker Compose vs Kubernetes 简析</h2><table><thead><tr><th>特性</th><th>Compose</th><th>Kubernetes</th></tr></thead><tbody><tr><td>启动容器</td><td>简单</td><td>标准化</td></tr><tr><td>配置语言</td><td>YAML</td><td>YAML</td></tr><tr><td>网络</td><td>自动共享</td><td>需显式配置</td></tr><tr><td>存储</td><td>Volume</td><td>PVC + SC</td></tr><tr><td>服务发现</td><td>服务名互通</td><td>DNS&#x2F;ClusterIP</td></tr><tr><td>用途</td><td>本地开发 &#x2F; CI</td><td>集群部署 &#x2F; 云原生</td></tr><tr><td>高可用 &#x2F; 伸缩</td><td>❌</td><td>✅ 内建</td></tr><tr><td>社区生态</td><td>中小项目广泛使用</td><td>大型平台标准方案</td></tr></tbody></table><blockquote><p>小李理解了：Compose 是“轻量乐队指挥”，K8s 是“交响级 AI 指挥系统”。</p></blockquote><hr><h2 id="🔁-第八节：Compose-CI-CD-集成发布"><a href="#🔁-第八节：Compose-CI-CD-集成发布" class="headerlink" title="🔁 第八节：Compose + CI&#x2F;CD 集成发布"></a>🔁 第八节：Compose + CI&#x2F;CD 集成发布</h2><p>小李将 Compose 整合进 GitLab CI 流程：</p><p><code>.gitlab-ci.yml</code> 示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker:dind</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><p>CI 构建完镜像后，直接用 Compose 部署，既省事又稳定。</p><hr><h2 id="🧠-小李-Compose-使用技巧总结"><a href="#🧠-小李-Compose-使用技巧总结" class="headerlink" title="🧠 小李 Compose 使用技巧总结"></a>🧠 小李 Compose 使用技巧总结</h2><table><thead><tr><th>目标</th><th>技巧</th></tr></thead><tbody><tr><td>服务隔离</td><td>每个项目单独一个 Compose 文件</td></tr><tr><td>共享网络</td><td>不用写 <code>network</code>，服务名即 DNS</td></tr><tr><td>跨环境配置</td><td>使用 <code>.env</code> 动态切换变量</td></tr><tr><td>状态排查</td><td><code>docker-compose logs</code> &#x2F; <code>ps</code> &#x2F; <code>exec</code></td></tr><tr><td>多环境文件</td><td>使用 <code>docker-compose.override.yml</code></td></tr><tr><td>CI&#x2F;CD 联动</td><td>编排命令嵌入流水线任务中</td></tr></tbody></table><hr><h2 id="🎬-尾声：指挥容器交响曲的时刻"><a href="#🎬-尾声：指挥容器交响曲的时刻" class="headerlink" title="🎬 尾声：指挥容器交响曲的时刻"></a>🎬 尾声：指挥容器交响曲的时刻</h2><p>当小李敲下 <code>docker-compose up</code> 的回车键，前端、后端、数据库同时启动，日志齐鸣，服务稳定运行。</p><blockquote><p>“这就是我梦想的微服务协奏曲啊。”</p></blockquote><p>老周拍了拍他肩膀：</p><blockquote><p>“你已经能用 Compose 驾驭服务之海，下一步，是把它们部署上云、扩展弹性、自动滚动升级。”</p></blockquote><p>小李点头，望向远方的集群编排系统——Kubernetes，眼中闪着新的渴望。</p><p>好！那我们就在<strong>第五章《多容器交响曲》</strong>中，继续深入补充这四大实战技能：</p><hr><h2 id="🧩-补充一：Compose-的多环境部署实践（开发、测试、生产）"><a href="#🧩-补充一：Compose-的多环境部署实践（开发、测试、生产）" class="headerlink" title="🧩 补充一：Compose 的多环境部署实践（开发、测试、生产）"></a>🧩 补充一：Compose 的多环境部署实践（开发、测试、生产）</h2><p>小李希望同一套服务，在开发、测试、生产环境下分别使用不同的配置，比如：</p><ul><li>数据库密码不同</li><li>是否挂载本地代码</li><li>是否启用调试模式</li></ul><p>老周教他使用 Compose 的<strong>多文件配置机制</strong>：</p><hr><h3 id="✅-方案一：使用-docker-compose-override-yml"><a href="#✅-方案一：使用-docker-compose-override-yml" class="headerlink" title="✅ 方案一：使用 docker-compose.override.yml"></a>✅ 方案一：使用 <code>docker-compose.override.yml</code></h3><p>Docker Compose 默认会<strong>自动加载 <code>docker-compose.override.yml</code></strong> 并与主文件合并。</p><h4 id="文件结构："><a href="#文件结构：" class="headerlink" title="文件结构："></a>文件结构：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose.yml</span><br><span class="line">docker-compose.override.yml</span><br><span class="line">.env.dev</span><br><span class="line">.env.prod</span><br></pre></td></tr></table></figure><h4 id="主配置（docker-compose-yml）："><a href="#主配置（docker-compose-yml）：" class="headerlink" title="主配置（docker-compose.yml）："></a>主配置（docker-compose.yml）：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENV_MODE=$&#123;MODE&#125;</span></span><br></pre></td></tr></table></figure><h4 id="开发环境覆盖文件（docker-compose-override-yml）："><a href="#开发环境覆盖文件（docker-compose-override-yml）：" class="headerlink" title="开发环境覆盖文件（docker-compose.override.yml）："></a>开发环境覆盖文件（docker-compose.override.yml）：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./src:/app/src</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEBUG=true</span></span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODE=development docker-compose up</span><br></pre></td></tr></table></figure><hr><h3 id="✅-方案二：按环境拆分多个-Compose-文件"><a href="#✅-方案二：按环境拆分多个-Compose-文件" class="headerlink" title="✅ 方案二：按环境拆分多个 Compose 文件"></a>✅ 方案二：按环境拆分多个 Compose 文件</h3><p>适合 CI&#x2F;CD 或部署多个 stage。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ul><li><code>docker-compose.dev.yml</code></li><li><code>docker-compose.prod.yml</code></li></ul><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d</span><br></pre></td></tr></table></figure><p>多个 <code>-f</code> 会按顺序合并，后面覆盖前面。</p><blockquote><p>📦 建议主文件写“公共配置”，子文件按环境细化。</p></blockquote><hr><h2 id="🎯-补充二：优化服务依赖启动顺序"><a href="#🎯-补充二：优化服务依赖启动顺序" class="headerlink" title="🎯 补充二：优化服务依赖启动顺序"></a>🎯 补充二：优化服务依赖启动顺序</h2><p>小李发现，即使写了 <code>depends_on</code>，后端有时候也连不上数据库。</p><p>老周摇头说：</p><blockquote><p>“<code>depends_on</code> 只是控制启动<strong>顺序</strong>，<strong>不是等服务就绪</strong>。数据库可能还没监听端口就已被标记为 ‘up’。”</p></blockquote><hr><h3 id="✅-正确姿势：服务内设置“等待就绪”"><a href="#✅-正确姿势：服务内设置“等待就绪”" class="headerlink" title="✅ 正确姿势：服务内设置“等待就绪”"></a>✅ 正确姿势：服务内设置“等待就绪”</h3><p>比如 Flask 等数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">until</span> nc -z db 3306; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Waiting for db...&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure><p>或者使用工具包如 <a href="https://github.com/vishnubob/wait-for-it"><code>wait-for-it.sh</code></a>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> wait-for-it.sh /wait-for-it.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/wait-for-it.sh&quot;</span>, <span class="string">&quot;db:3306&quot;</span>, <span class="string">&quot;--&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>🩺 推荐结合容器健康检查，判断服务是否真正 ready。</p></blockquote><hr><h2 id="🛠-补充三：Docker-Compose-V1-➜-V2-迁移技巧"><a href="#🛠-补充三：Docker-Compose-V1-➜-V2-迁移技巧" class="headerlink" title="🛠 补充三：Docker Compose V1 ➜ V2 迁移技巧"></a>🛠 补充三：Docker Compose V1 ➜ V2 迁移技巧</h2><p>小李的 CI 工具用的是 Compose v1，项目准备升级。</p><p>老周提醒：</p><blockquote><p>“Docker Compose v2 使用的是 <code>docker compose</code>（空格），而非 <code>docker-compose</code>（短横线）。”</p></blockquote><hr><h3 id="✅-主要变化："><a href="#✅-主要变化：" class="headerlink" title="✅ 主要变化："></a>✅ 主要变化：</h3><table><thead><tr><th>项目</th><th>v1 (<code>docker-compose</code>)</th><th>v2 (<code>docker compose</code>)</th></tr></thead><tbody><tr><td>命令格式</td><td><code>docker-compose up</code></td><td><code>docker compose up</code></td></tr><tr><td>安装方式</td><td>独立二进制</td><td>集成于 Docker CLI</td></tr><tr><td>文件格式</td><td><code>v2</code>, <code>v3</code></td><td>推荐统一 <code>v3.9</code></td></tr></tbody></table><hr><h3 id="✅-迁移建议："><a href="#✅-迁移建议：" class="headerlink" title="✅ 迁移建议："></a>✅ 迁移建议：</h3><ul><li>删除旧的 <code>docker-compose</code> 二进制</li><li>使用 <code>docker compose</code> CLI</li><li>更新脚本、CI 工具调用方式</li><li>移除 legacy 字段（如 <code>links</code>）</li><li>检查 <code>.env</code> 是否兼容（v2 更严格）</li></ul><hr><h2 id="☸️-补充四：Compose-与-Helm-的映射关系对照"><a href="#☸️-补充四：Compose-与-Helm-的映射关系对照" class="headerlink" title="☸️ 补充四：Compose 与 Helm 的映射关系对照"></a>☸️ 补充四：Compose 与 Helm 的映射关系对照</h2><p>当小李进入 Kubernetes 世界，他问老周：</p><blockquote><p>“Compose 文件和 K8s 的 YAML 有啥对应关系？”</p></blockquote><p>老周说：“很好理解，Compose 是开发者的 K8s 简化版本。”</p><hr><h3 id="对照表："><a href="#对照表：" class="headerlink" title="对照表："></a>对照表：</h3><table><thead><tr><th>Compose</th><th>Kubernetes</th></tr></thead><tbody><tr><td><code>services:</code></td><td><code>Deployment + Pod</code></td></tr><tr><td><code>volumes:</code></td><td><code>PersistentVolumeClaim</code></td></tr><tr><td><code>ports:</code></td><td><code>Service</code>（NodePort &#x2F; ClusterIP）</td></tr><tr><td><code>depends_on:</code></td><td><code>initContainers</code> 或 readinessProbe</td></tr><tr><td><code>.env</code></td><td>ConfigMap &#x2F; Secret</td></tr><tr><td><code>docker-compose.yml</code></td><td>Helm Chart (values.yaml + templates)</td></tr></tbody></table><hr><h3 id="示例：Compose-转-Helm-构思"><a href="#示例：Compose-转-Helm-构思" class="headerlink" title="示例：Compose 转 Helm 构思"></a>示例：Compose 转 Helm 构思</h3><h4 id="Compose-配置："><a href="#Compose-配置：" class="headerlink" title="Compose 配置："></a>Compose 配置：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEBUG=true</span></span><br></pre></td></tr></table></figure><h4 id="Helm-values-yaml："><a href="#Helm-values-yaml：" class="headerlink" title="Helm values.yaml："></a>Helm <code>values.yaml</code>：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h4 id="Helm-deployment-yaml（模板）："><a href="#Helm-deployment-yaml（模板）：" class="headerlink" title="Helm deployment.yaml（模板）："></a>Helm <code>deployment.yaml</code>（模板）：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.image.repository</span> &#125;&#125;<span class="string">:&#123;&#123;</span> <span class="string">.Values.image.tag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">.Values.env</span> &#125;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.name</span> &#125;&#125;</span><br><span class="line">        <span class="attr">value:</span> &#123;&#123; <span class="string">.value</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ 小李意识到，Helm 是“模板化 + 分层管理”的 Compose 超集，是云原生部署的标准组件管理器。</p></blockquote><hr><h2 id="🎬-尾声：Compose-是微服务上云的跳板"><a href="#🎬-尾声：Compose-是微服务上云的跳板" class="headerlink" title="🎬 尾声：Compose 是微服务上云的跳板"></a>🎬 尾声：Compose 是微服务上云的跳板</h2><p>小李已经用 Docker Compose 实现了：</p><ul><li>开发环境热更新</li><li>测试环境集成数据库</li><li>生产环境独立配置</li><li>CI&#x2F;CD 自动部署服务</li><li>为 Kubernetes 迁移打下基础</li></ul><p>他明白了：</p><blockquote><p>“Compose 就像舞台排练，Kubernetes 才是真正的大型音乐厅。但有了排练，登台才不会慌。”</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直想写一本容器小书，真好懒猫基本都做了容器化，所以把这部分分享出来。不同的是，懒猫微服中使用 pg-docker 来替代 docker 命令，使用 dockge 来执行 docker-compose。以下讲解以标准 docker 为主，这样子既学会了 docker 知识，也能够在懒猫微服上启动 Docker 服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;《多容器交响曲：Docker-Compose-上场》讲的是使用-Docker-Compose-统一编排多容器服务，理解-YAML-配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose-vs-K8s-初探等&quot;&gt;&lt;a href=&quot;#《多容器交响曲：Docker-Compose-上场》讲的是使用-Docker-Compose-统一编排多容器服务，理解-YAML-配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose-vs-K8s-初探等&quot; class=&quot;headerlink&quot; title=&quot;《多容器交响曲：Docker Compose 上场》讲的是使用 Docker Compose 统一编排多容器服务，理解 YAML 配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose vs K8s 初探等&quot;&gt;&lt;/a&gt;《多容器交响曲：Docker Compose 上场》讲的是使用 Docker Compose 统一编排多容器服务，理解 YAML 配置结构、服务依赖、网络、挂载、构建策略、变量管理、Compose vs K8s 初探等&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;🎼-开篇：服务之间的管弦乐团&quot;&gt;&lt;a href=&quot;#🎼-开篇：服务之间的管弦乐团&quot; class=&quot;headerlink&quot; title=&quot;🎼 开篇：服务之间的管弦乐团&quot;&gt;&lt;/a&gt;🎼 开篇：服务之间的管弦乐团&lt;/h3&gt;&lt;p&gt;随着项目日益复杂，小李的服务已经不再是一个容器就能承载的了。&lt;/p&gt;
&lt;p&gt;前端、后端、数据库、缓存、日志系统……像一个交响乐团，需要统一调度、和谐配合。&lt;/p&gt;
&lt;p&gt;老周递给他一个新的工具：“&lt;strong&gt;Docker Compose&lt;/strong&gt;——它是你的指挥棒。”&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎻-第一节：什么是-Docker-Compose？&quot;&gt;&lt;a href=&quot;#🎻-第一节：什么是-Docker-Compose？&quot; class=&quot;headerlink&quot; title=&quot;🎻 第一节：什么是 Docker Compose？&quot;&gt;&lt;/a&gt;🎻 第一节：什么是 Docker Compose？&lt;/h2&gt;&lt;p&gt;老周解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Docker Compose 是 Docker 的多容器编排工具，用一份 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件，就能同时启动、停止、构建多个服务。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Compose 帮你解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个服务启动顺序&lt;/li&gt;
&lt;li&gt;多容器共享网络&lt;/li&gt;
&lt;li&gt;统一管理环境变量&lt;/li&gt;
&lt;li&gt;配置简洁、开发者友好&lt;/li&gt;
&lt;li&gt;跨平台部署一致&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="Docker" scheme="https://xu-hardy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服入门篇（零）：开箱初探，硬件亮相</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89%EF%BC%9A%E5%BC%80%E7%AE%B1%E5%88%9D%E6%8E%A2%EF%BC%8C%E7%A1%AC%E4%BB%B6%E4%BA%AE%E7%9B%B8/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%88%E9%9B%B6%EF%BC%89%EF%BC%9A%E5%BC%80%E7%AE%B1%E5%88%9D%E6%8E%A2%EF%BC%8C%E7%A1%AC%E4%BB%B6%E4%BA%AE%E7%9B%B8/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>用了一个半月的懒猫微服，来写一个伪开箱。机甲风格外壳也得值个几百块，这个外壳还支持拆机之后全身水洗。在桌面上确实颜值很高，在各个小主机都是塑料外壳的时代，属于用心良苦了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250619161920055.png" alt="image-20250619161920055"></p><p>这张图是创始人在用户群里发的实拍图：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/6c54b4ac4c8d437375149b66ca7d6aee.jpg" alt="6c54b4ac4c8d437375149b66ca7d6aee"></p><p>据群友们聊天说，这台机器已经经过了多个版本迭代，最后定型为现在这个样子。以后不要再用鞋盒了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/6356f1ef9911435c101dc8d9c4eec591.png" alt="6356f1ef9911435c101dc8d9c4eec591"></p><hr><span id="more"></span><h3 id="系统与配置"><a href="#系统与配置" class="headerlink" title="系统与配置"></a>系统与配置</h3><p>通过 <code>neofetch</code> 可以看到，这台机器预装的是 Debian 12，实际系统也做了不少魔改优化。核心配置如下：</p><ul><li><strong>CPU</strong>：Intel Core i5-1155G7 @ 4.5GHz（4 核心 8 线程），相当于现在主流的 N305 强了很多。</li><li><strong>内存</strong>：笔记本内存 DDR4，最大可扩展至 32GB，3200MHZ （买的时候可以谈从 16G 升级到 32G）</li><li><strong>显卡</strong>：Intel Iris Xe Graphics，英特尔最强核显，核显频率最高 1.35GHz，支持 4K 高清输出与 H.265 视频硬解</li><li><strong>存储</strong>：<ul><li>系统盘：512GB PCIe 4.0 NVMe，用于运行系统组件和保存根目录文件。</li><li>数据盘：两个 2.5 寸 SATA 盘位，可以组 RAID0 或者 RAID1。SSD 或者 HDD 不限。</li></ul></li><li><strong>主板</strong>：看上是自己做的，叫做 YENTEK LC2580，启动热键是 F11，进入 BIOS 的按键是 <code>&lt;DEL&gt;</code> 。 没有锁 BIOS，也支持刷成其他的系统。</li></ul><p>运行 <code>dmidecode</code> 可见内存状态如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dmidecode -t memory | grep -e <span class="string">&quot;Size&quot;</span> -e <span class="string">&quot;Form Factor&quot;</span> -e <span class="string">&quot;Locator&quot;</span></span><br><span class="line">        Size: No Module Installed</span><br><span class="line">        Form Factor: Unknown</span><br><span class="line">        Locator: Controller1-ChannelA-DIMM0</span><br><span class="line">        Bank Locator: BANK 0</span><br><span class="line">        Size: 32 GB</span><br><span class="line">        Form Factor: SODIMM</span><br><span class="line">        Locator: Controller0-ChannelA-DIMM0</span><br><span class="line">        Bank Locator: BANK 0</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><hr><h3 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h3><p>网络配置方面也比较主流：</p><ul><li><strong>有线</strong>：2.5G 单网口，可惜我的路由器还是千兆不能完全发挥其能力</li><li><strong>无线</strong>：Intel AX210，支持 WiFi 6 可以跑满千兆。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) lzcbox-029c588e ~ <span class="comment"># dmesg | grep -i ethernet</span></span><br><span class="line">[    2.946824] Intel(R) 2.5G Ethernet Linux Driver</span><br><span class="line">[    9.157839] Bluetooth: BNEP (Ethernet Emulation) ver 1.3</span><br><span class="line">(base) lzcbox-029c588e ~ <span class="comment"># lspci | grep -i network</span></span><br><span class="line">04:00.0 Network controller: Intel Corporation Wi-Fi 6 AX210/AX211/AX411 160MHz (rev 1a)</span><br></pre></td></tr></table></figure><p>于 WIFI6 来说协商速率一般是 2402Mbps，所以就算达到协商速率的一般的话，也就是差不多千兆，加上很多家用路由也仅仅是千兆，我为了 POE 供电所以牺牲了部分内网带宽，所以没有跑满。如果你有 2.5G 的机器和交换机，那么一定可以跑的很舒服，基本就到机械硬盘的上限了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250619213746613.png" alt="image-20250619213746613"></p><hr><h3 id="CPU-性跑分"><a href="#CPU-性跑分" class="headerlink" title="CPU 性跑分"></a>CPU 性跑分</h3><p>跑了几次 geekbench6，能够看到单核心的性能有 1700+，由于测速的同时还在运行很多系统应用，所以实际的数值比这个还要大一些。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250619215814429.png" alt="image-20250619215814429"></p><p>后面用了 EndeavourOS KDE 的随身碟，能够看到单核心分数还能再提升。这个 CPU 跑 docker，K8S 甚至虚拟机都没啥问题了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250619215631160.png" alt="image-20250619215631160"></p><hr><h3 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h3><p>机器背部接口一览，我这边插了一张采集卡，非常实用：</p><p>接口方面也非常丰富：</p><ul><li><strong>USB</strong>：USB 3.0 x3</li><li><strong>Type-C</strong>：USB 3.2 Type-C x2，支持反冲保护</li><li><strong>视频输出</strong>：HDMI 2.1 x1，支持 4K 输出、多声道音频</li><li><strong>音频接口</strong>：3.5mm 耳机口，支持高阻抗耳机</li><li><strong>电源接口</strong>：DC 5525</li></ul><blockquote><p>整机搭载一枚 17mm 涡轮静音风扇，结合滚珠轴承与自研调速算法，实际体验确实安静，确实没有 3.5 寸硬盘那种炒豆子的声音了。</p></blockquote><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/15b358f335c93c896b98292e49ee0bf6.jpg" alt="15b358f335c93c896b98292e49ee0bf6"></p><p>可以看到 Deepin 的 团队出来做产品的能力还是挺强的，从主板到 OS 的深度定制，技术功底可见一斑。</p><p>下面是群友的发的效果图，实物质感确实很棒，欢迎找我下单体验！</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/cd96e69cd34841430873db544aae96a4.png" alt="cd96e69cd34841430873db544aae96a4"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用了一个半月的懒猫微服，来写一个伪开箱。机甲风格外壳也得值个几百块，这个外壳还支持拆机之后全身水洗。在桌面上确实颜值很高，在各个小主机都是塑料外壳的时代，属于用心良苦了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250619161920055.png&quot; alt=&quot;image-20250619161920055&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张图是创始人在用户群里发的实拍图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/6c54b4ac4c8d437375149b66ca7d6aee.jpg&quot; alt=&quot;6c54b4ac4c8d437375149b66ca7d6aee&quot;&gt;&lt;/p&gt;
&lt;p&gt;据群友们聊天说，这台机器已经经过了多个版本迭代，最后定型为现在这个样子。以后不要再用鞋盒了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/6356f1ef9911435c101dc8d9c4eec591.png&quot; alt=&quot;6356f1ef9911435c101dc8d9c4eec591&quot;&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="硬件与外设" scheme="https://xu-hardy.github.io/tags/%E7%A1%AC%E4%BB%B6%E4%B8%8E%E5%A4%96%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（一）： 从开启SSH到免密登录，一步步教你搞定远程管理</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A-%E4%BB%8E%E5%BC%80%E5%90%AFssh%E5%88%B0%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E6%90%9E%E5%AE%9A%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A-%E4%BB%8E%E5%BC%80%E5%90%AFssh%E5%88%B0%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%EF%BC%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E6%90%9E%E5%AE%9A%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>对于很多资深的 NAS 玩家来说，拿到一台机器首先要配置远程登录和环境依赖。懒猫上其实可以实现云计算讲的 Iass - Pass -Sass 这三个层级，不过对于资深玩家而言，肯定是要从 Infra 这个级别入手的。</p><p>官方文档如下：<br><a href="https://developer.lazycat.cloud/ssh.html">https://developer.lazycat.cloud/ssh.html</a></p><p>安装懒猫开发者工具，然后再右上角能够看到 sshd 服务的状态。<br>然后点击开启，之后我们才可以使用 ssh 登录，在写这篇文章测试的时候，我关闭了这个按钮，再去 ssh 直接就报错了。</p><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/823b1afe-fb70-4866-8303-aa051e9b65bc.png" alt="image.png" title="image.png"></p><p>默认是 root 身份登录，密码在开发者工具里启动的时候设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;your-service-name&gt;.heiyu.space</span><br></pre></td></tr></table></figure><p>如果觉得密码麻烦，也可以导入密钥，更加安全：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_ed25519 root@xxxxx.heiyu.space</span><br></pre></td></tr></table></figure><span id="more"></span><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/xu/.ssh/id_ed25519.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@micro.heiyu.space&#x27;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added:        1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with: &quot;ssh -i /.ssh/id_ed25519 &#x27;root@xxxx.heiyu.space&#x27;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果觉得 root 用户不安全的话，可以新建一个日常用户，然后加到 docker 组里面，也能正常使用 docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> useradd -m -s /bin/bash user1</span><br><span class="line"></span><br><span class="line">usermod -aG docker user1</span><br><span class="line"></span><br><span class="line">usermod -aG <span class="built_in">sudo</span> user1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/e40ad428-93be-487e-880c-d37c76f27fc1.png" alt="image.png" title="image.png"></p><p>如果遇到到 root 组会有无法使用 sudo 的问题，请独立安装，sudo 是单独的软件包,需要安装才有.并不是所有 Linux 都有 sudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install <span class="built_in">sudo</span></span><br></pre></td></tr></table></figure><p>注意：要开着懒猫微服 APP ，否则无法使用 heiyu.space 提供的穿透服务。</p><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/a303adbb-d3f5-4fa2-9a6d-6d3b25abbe34.png" alt="image.png" title="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于很多资深的 NAS 玩家来说，拿到一台机器首先要配置远程登录和环境依赖。懒猫上其实可以实现云计算讲的 Iass - Pass -Sass 这三个层级，不过对于资深玩家而言，肯定是要从 Infra 这个级别入手的。&lt;/p&gt;
&lt;p&gt;官方文档如下：&lt;br&gt;&lt;a href=&quot;https://developer.lazycat.cloud/ssh.html&quot;&gt;https://developer.lazycat.cloud/ssh.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装懒猫开发者工具，然后再右上角能够看到 sshd 服务的状态。&lt;br&gt;然后点击开启，之后我们才可以使用 ssh 登录，在写这篇文章测试的时候，我关闭了这个按钮，再去 ssh 直接就报错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/823b1afe-fb70-4866-8303-aa051e9b65bc.png&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;默认是 root 身份登录，密码在开发者工具里启动的时候设置：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh root@&amp;lt;your-service-name&amp;gt;.heiyu.space&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果觉得密码麻烦，也可以导入密钥，更加安全：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-copy-id -i ~/.ssh/id_ed25519 root@xxxxx.heiyu.space&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十）：通过 nmtui 设置静态 IP，接入旁路由实现科学上网</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87-nmtui-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip%EF%BC%8C%E6%8E%A5%E5%85%A5%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E9%80%9A%E8%BF%87-nmtui-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip%EF%BC%8C%E6%8E%A5%E5%85%A5%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中，我主要使用的是 <strong>MacBook</strong> 作为主力机。但有些软件、驱动或容器服务必须在 <strong>X86 架构环境下测试</strong>，这时懒猫微服就是一个很好的辅助平台。然而在一些网络场景下，为了访问特定服务，还需要将这台设备接入旁路由中。</p><p>不然我访问 Dockerhub 是这样的，经常会超时，只能用不是很全的镜像站。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530113416141.png" alt="image-20250530113416141"></p><p>群晖等设备提供的图形化网络面板，懒猫微服这类轻量系统没有 GUI，只能使用命令行工具。NetworkManager 提供了一个非常好用的文本界面工具：<code>nmtui</code>。</p><h2 id="什么是-nmtui"><a href="#什么是-nmtui" class="headerlink" title="什么是 nmtui"></a>什么是 <code>nmtui</code></h2><p><code>nmtui</code> 是 NetworkManager 的 TUI（Text-based User Interface）组件，界面类似简化版 GUI，操作简单，功能却很强大。通过它，我们可以方便地完成以下配置：</p><ul><li>选择并连接网络设备（有线或无线）</li><li>设置 <strong>手动 IP 地址</strong></li><li>指定 <strong>网关</strong>、<strong>DNS 服务器</strong></li><li>管理 <strong>路由策略</strong></li><li>开启或关闭 DHCP 自动获取功能<span id="more"></span>命令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><hr><h2 id="设置静态-IP-接入旁路由"><a href="#设置静态-IP-接入旁路由" class="headerlink" title="设置静态 IP 接入旁路由"></a>设置静态 IP 接入旁路由</h2><p>打开 <code>nmtui</code> 后，进入“Edit a connection”，编辑你连接的网卡（如 <code>enp2s0</code>），手动设置 IP 地址、网关和 DNS。如下图所示，我将所有网络解析都指向了旁路由（比如是 OpenWrt 或其他带翻墙能力的设备）：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530113654399.png" alt="nmtui IPv4 设置"></p><p>确保设置完成后，运行以下命令重新应用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device reapply enp2s0</span><br></pre></td></tr></table></figure><p>如果配置无误，网络将立即切换到静态 IP 并走旁路由的网关。</p><hr><h2 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h2><p>这样子终端就能下载 Docker image 了，其实到这一步已经完成了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530113410246.png" alt="Google 搜索页面"></p><p>接下来，可以通过懒猫微服中安装的浏览器测试网络是否生效。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530113238801.png" alt="YouTube 套娃"></p><p>继续打开 YouTube 首页，也能顺利访问并加载视频页面：</p><p>你没看错，这是 <strong>浏览器里的浏览器</strong>，实现了一个“浏览器套娃”的效果。😂</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530112240064.png" alt="image-20250530112240064"></p><p>最终，我播放了银临的《牵丝戏》，人美歌也好听～</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530112250228.png" alt="银临《牵丝戏》"></p><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/59ab31d4-adf8-4c8e-9775-1b37710f570a.png" alt="77dea8a6a38817c503c379dd946fc9e4.png" title="77dea8a6a38817c503c379dd946fc9e4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常开发中，我主要使用的是 &lt;strong&gt;MacBook&lt;/strong&gt; 作为主力机。但有些软件、驱动或容器服务必须在 &lt;strong&gt;X86 架构环境下测试&lt;/strong&gt;，这时懒猫微服就是一个很好的辅助平台。然而在一些网络场景下，为了访问特定服务，还需要将这台设备接入旁路由中。&lt;/p&gt;
&lt;p&gt;不然我访问 Dockerhub 是这样的，经常会超时，只能用不是很全的镜像站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530113416141.png&quot; alt=&quot;image-20250530113416141&quot;&gt;&lt;/p&gt;
&lt;p&gt;群晖等设备提供的图形化网络面板，懒猫微服这类轻量系统没有 GUI，只能使用命令行工具。NetworkManager 提供了一个非常好用的文本界面工具：&lt;code&gt;nmtui&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是-nmtui&quot;&gt;&lt;a href=&quot;#什么是-nmtui&quot; class=&quot;headerlink&quot; title=&quot;什么是 nmtui&quot;&gt;&lt;/a&gt;什么是 &lt;code&gt;nmtui&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nmtui&lt;/code&gt; 是 NetworkManager 的 TUI（Text-based User Interface）组件，界面类似简化版 GUI，操作简单，功能却很强大。通过它，我们可以方便地完成以下配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择并连接网络设备（有线或无线）&lt;/li&gt;
&lt;li&gt;设置 &lt;strong&gt;手动 IP 地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指定 &lt;strong&gt;网关&lt;/strong&gt;、&lt;strong&gt;DNS 服务器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;管理 &lt;strong&gt;路由策略&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;开启或关闭 DHCP 自动获取功能</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="代理" scheme="https://xu-hardy.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十一）：一键换源指南：用 chsrc 开启丝滑体验</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%80%E9%94%AE%E6%8D%A2%E6%BA%90%E6%8C%87%E5%8D%97%EF%BC%9A%E7%94%A8-chsrc-%E5%BC%80%E5%90%AF%E4%B8%9D%E6%BB%91%E4%BD%93%E9%AA%8C/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%80%E9%94%AE%E6%8D%A2%E6%BA%90%E6%8C%87%E5%8D%97%EF%BC%9A%E7%94%A8-chsrc-%E5%BC%80%E5%90%AF%E4%B8%9D%E6%BB%91%E4%BD%93%E9%AA%8C/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>最近懒猫微服的系统固件进行了更新，默认的软件源重新指向了国际源。估计是为了方便海外用户，但对于国内开发者来说，访问速度顿时大打折扣，软件安装和更新频繁卡在连接阶段，着实是一个问题。</p><p>正巧群友推荐了一个神器 —— <a href="https://gitee.com/RubyMetric/chsrc"><code>chsrc</code></a>。这个工具支持一键切换系统、Python、conda 等多个主流组件的源，简洁高效，非常适合懒猫微服这样的轻量环境使用。</p><h2 id="下载并安装-chsrc"><a href="#下载并安装-chsrc" class="headerlink" title="下载并安装 chsrc"></a>下载并安装 chsrc</h2><p>chsrc 项目在 Gitee 上提供了预编译的可执行文件，适用于不同架构的 Linux 设备。我当前使用的是 x86_64 架构，因此只需运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-x64-linux -o chsrc</span><br><span class="line"><span class="built_in">chmod</span> +x ./chsrc</span><br></pre></td></tr></table></figure><p>下载后，为了方便使用，我们通常会把它加入环境变量。但懒猫微服的一个特殊机制是：<strong>除了 <code>/root</code> 目录，其他目录在每次重启后都会被重置</strong>。这意味着如果你将 chsrc 放在 <code>/home</code> 或 <code>/usr/local/bin</code> 之类的目录，它在下次重启后可能就不见了。</p><span id="more"></span><p>所以我将 chsrc 的二进制文件移动到了 <code>/root/app</code> 下（可以新建这个目录），并在 <code>~/.bashrc</code> 中手动追加了环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/root/app:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>这样每次打开 shell 时，系统就会自动把 chsrc 所在路径加入 <code>$PATH</code>，确保我们可以直接使用 <code>chsrc</code> 命令。</p><h2 id="一键更换-Debian-软件源"><a href="#一键更换-Debian-软件源" class="headerlink" title="一键更换 Debian 软件源"></a>一键更换 Debian 软件源</h2><p>懒猫微服是基于 Debian 的发行版，因此可以直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsrc <span class="built_in">set</span> debian</span><br></pre></td></tr></table></figure><p>运行后，工具会先检测系统当前源格式（支持新版 <code>deb822</code>），然后测速多个国内镜像源（如清华、中科大、阿里等），自动选择最快的源进行替换，整个过程完全自动化，再也不用去网上搜帖子找各种源了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530201828165.png" alt="换源截图"></p><h2 id="更换-Python-镜像源"><a href="#更换-Python-镜像源" class="headerlink" title="更换 Python 镜像源"></a>更换 Python 镜像源</h2><p>除了操作系统本身的源之外，也能更换 Python，node 这样的源。</p><p>我制作了一个 Miniconda 的一键安装脚本，用来替代系统自带的 Python3.11，用 conda 虚拟环境管理起来很方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 下载最新 Miniconda 安装脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;📥 正在下载 Miniconda 安装器...&quot;</span></span><br><span class="line">MINICONDA=Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">wget https://repo.anaconda.com/miniconda/<span class="variable">$MINICONDA</span> -O /tmp/<span class="variable">$MINICONDA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 静默安装到 ~/miniconda3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;⚙️ 正在静默安装到 ~/miniconda3...&quot;</span></span><br><span class="line">bash /tmp/<span class="variable">$MINICONDA</span> -b -p <span class="variable">$HOME</span>/miniconda3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加到 PATH（写入 .bashrc）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;🔧 正在将 Miniconda 添加到 PATH...&quot;</span></span><br><span class="line">CONDA_INIT=<span class="string">&#x27;export PATH=&quot;$HOME/miniconda3/bin:$PATH&quot;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ! grep -q <span class="string">&quot;<span class="variable">$CONDA_INIT</span>&quot;</span> ~/.bashrc; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CONDA_INIT</span>&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 初始化 conda（非交互式）</span></span><br><span class="line"><span class="variable">$HOME</span>/miniconda3/bin/conda init bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 提示用户刷新 shell</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ 安装完成！请运行以下命令以立即生效：&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  source ~/.bashrc&quot;</span></span><br></pre></td></tr></table></figure><p>这个脚本的好处是全程自动化，不需要你动手点选目录，也不必一步步设置环境变量，适合懒猫开发者在新设备或系统还原后快速恢复工作环境。</p><p>安装好 Miniconda 之后，就可以利用 <code>chsrc</code> 来更换 pip 源了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsrc <span class="built_in">set</span> python</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/449f7b0d2e26f4247caf0ce47b4c1622.png" alt="chsrc 设置 Python 源"></p><p>此命令会将 pip 的默认源改为清华源或豆瓣源等国内镜像，提高模块下载速度，彻底告别“卡在安装 xx 模块”的窘境。</p><p>最后一步，把 conda 的源也换成国内的。直接执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsrc <span class="built_in">set</span> conda</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250530204151317.png" alt="换源成功"></p><p>然后需要手动更新 <code>.condarc</code> 配置文件。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次我体验了 <code>chsrc</code> 在懒猫微服上的完整使用链路，感受可以总结为三句话：</p><ul><li><strong>能跑就行？不，要跑得快。</strong></li><li><strong>别用默认源，懒人换源有奇效。</strong></li><li><strong>系统、Python、Conda，一条龙解决卡顿。</strong></li></ul><p>如果你也在用懒猫微服、或者在其他 Debian 系的轻量服务器上摸索开发环境，强烈推荐你试试这个工具和脚本组合。毕竟，“懒得配置”不应该成为“卡在配置”的理由。</p><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/e5fc8b99-2220-4a5a-8327-38da7b93456f.png" alt="image.png" title="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近懒猫微服的系统固件进行了更新，默认的软件源重新指向了国际源。估计是为了方便海外用户，但对于国内开发者来说，访问速度顿时大打折扣，软件安装和更新频繁卡在连接阶段，着实是一个问题。&lt;/p&gt;
&lt;p&gt;正巧群友推荐了一个神器 —— &lt;a href=&quot;https://gitee.com/RubyMetric/chsrc&quot;&gt;&lt;code&gt;chsrc&lt;/code&gt;&lt;/a&gt;。这个工具支持一键切换系统、Python、conda 等多个主流组件的源，简洁高效，非常适合懒猫微服这样的轻量环境使用。&lt;/p&gt;
&lt;h2 id=&quot;下载并安装-chsrc&quot;&gt;&lt;a href=&quot;#下载并安装-chsrc&quot; class=&quot;headerlink&quot; title=&quot;下载并安装 chsrc&quot;&gt;&lt;/a&gt;下载并安装 chsrc&lt;/h2&gt;&lt;p&gt;chsrc 项目在 Gitee 上提供了预编译的可执行文件，适用于不同架构的 Linux 设备。我当前使用的是 x86_64 架构，因此只需运行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-x64-linux -o chsrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;chmod&lt;/span&gt; +x ./chsrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;下载后，为了方便使用，我们通常会把它加入环境变量。但懒猫微服的一个特殊机制是：&lt;strong&gt;除了 &lt;code&gt;/root&lt;/code&gt; 目录，其他目录在每次重启后都会被重置&lt;/strong&gt;。这意味着如果你将 chsrc 放在 &lt;code&gt;/home&lt;/code&gt; 或 &lt;code&gt;/usr/local/bin&lt;/code&gt; 之类的目录，它在下次重启后可能就不见了。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十二）：用 iVentoy 打造你的 PXE 服务器</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8-iventoy-%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84-pxe-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%94%A8-iventoy-%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84-pxe-%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>很多介绍 Linux 的书籍都会在结尾推荐 PXE 装机方式，尤其是经典的 TFTP + Kickstart 自动部署方案。但在普通家庭或轻量办公环境中，这种方式显得有些繁琐。在 U 盘装机的环境中，我一般使用的 <strong>Ventoy</strong>多合一 。不过 Ventoy 团队又推出了一个支持 PXE 的装机版本，名为 <strong>iVentoy</strong>，和 WDS 类似，不过更加省心，这个应用已经上架懒猫微服的应用商店，非常适合内网多机装系统的场景。终于不用再琢磨 WDS 了。还有就是之前不小心用店家带的 U 盘把主机的所有数据都格式化了，这种手残也一去不复返了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601202019460.png" alt="iVentoy商店界面"></p><h3 id="什么是-PXE-无盘装机？"><a href="#什么是-PXE-无盘装机？" class="headerlink" title="什么是 PXE 无盘装机？"></a>什么是 PXE 无盘装机？</h3><p>PXE，全称 <strong>Preboot eXecution Environment</strong>，是一种允许电脑在没有本地操作系统、光盘或 U 盘的情况下，通过网络从服务器下载引导程序并完成系统安装的机制。</p><span id="more"></span><p><strong>PXE 装机简化流程如下：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 开机 → BIOS/UEFI 设置为从网卡启动（PXE Boot）</span><br><span class="line">       ↓</span><br><span class="line">2. 客户端通过网卡发出 DHCP 请求 → 获取 IP 和引导文件地址</span><br><span class="line">       ↓</span><br><span class="line">3. 通过 TFTP 下载启动文件（如 pxelinux.0 或 iPXE）</span><br><span class="line">       ↓</span><br><span class="line">4. 加载内核（vmlinuz）和安装器（initrd.img）</span><br><span class="line">       ↓</span><br><span class="line">5. 进入图形界面或执行自动化系统安装</span><br></pre></td></tr></table></figure><hr><h4 id="PXE-装机适用场景"><a href="#PXE-装机适用场景" class="headerlink" title="PXE 装机适用场景"></a>PXE 装机适用场景</h4><ul><li>大量办公电脑或服务器的系统部署</li><li>设备没有 USB 接口或启动盘时</li><li>多系统测试、系统重装、快速恢复环境</li><li>各类 PE 工具、Linux Live 系统启动</li></ul><hr><h3 id="懒猫微服-上-iVentoy-装机体验"><a href="#懒猫微服-上-iVentoy-装机体验" class="headerlink" title="懒猫微服 上 iVentoy 装机体验"></a>懒猫微服 上 iVentoy 装机体验</h3><p>以下是我在懒猫微服环境中使用 iVentoy 的全过程：</p><h4 id="1-上传系统镜像"><a href="#1-上传系统镜像" class="headerlink" title="1. 上传系统镜像"></a>1. 上传系统镜像</h4><p>进入懒猫的应用数据目录：<br><code>应用数据 - Iventoy - ISO</code><br>将你准备好的 Windows &#x2F; Linux ISO 文件上传到此路径。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601203151865.png" alt="上传 ISO 镜像"></p><h4 id="2-启动-iVentoy，配置网络"><a href="#2-启动-iVentoy，配置网络" class="headerlink" title="2. 启动 iVentoy，配置网络"></a>2. 启动 iVentoy，配置网络</h4><p>确保机器在内网下有一个 <strong>有效的 IPv4 地址</strong>，然后启动 iVentoy。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601202427884.png" alt="iVentoy 主界面"></p><h4 id="3-BIOS-设置启用-PXE"><a href="#3-BIOS-设置启用-PXE" class="headerlink" title="3. BIOS 设置启用 PXE"></a>3. BIOS 设置启用 PXE</h4><p>进入待装机设备的 BIOS，确保启用 <strong>PXE Boot &#x2F; 网络启动功能</strong>。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601202741281.png" alt="开启 PXE 支持"></p><h4 id="4-插网线，选择-PXE-启动"><a href="#4-插网线，选择-PXE-启动" class="headerlink" title="4. 插网线，选择 PXE 启动"></a>4. 插网线，选择 PXE 启动</h4><p>启动设备，确保插入网线（无线网卡 PXE 启动通常不被支持），从网卡启动。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601202303737.png" alt="从网络启动"></p><h4 id="5-自动进入-iVentoy-引导菜单"><a href="#5-自动进入-iVentoy-引导菜单" class="headerlink" title="5. 自动进入 iVentoy 引导菜单"></a>5. 自动进入 iVentoy 引导菜单</h4><p>如果网络配置无误，设备会自动弹出引导菜单，可以看到之前上传的 ISO 镜像。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/78714275c7adc030420ccf77b479955b.jpg" alt="iVentoy 引导界面"></p><p>选择一个系统镜像，回车进入即可，相当于将 ISO 当成 LiveCD 使用。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/4488415be27c9e56412883cc35e95ce7.jpg" alt="选择 ISO 启动"></p><h3 id="6-成功进入桌面系统"><a href="#6-成功进入桌面系统" class="headerlink" title="6. 成功进入桌面系统"></a>6. 成功进入桌面系统</h3><p>以 Pop!_OS 为例，系统已经顺利启动，无需任何 U 盘！</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/8a1dc12c14c27fdc02a39db103994f5a.jpg" alt="成功进入系统桌面"></p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个办法还是适合炫技，把电脑接上网线，然后不用 U 盘，凭空装好系统，不过还是没有 U 盘那么丝滑，有时候不能打满千兆带宽。不过假如手头 U 盘不够用，或者要在多个系统反复装机测试就很方便了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多介绍 Linux 的书籍都会在结尾推荐 PXE 装机方式，尤其是经典的 TFTP + Kickstart 自动部署方案。但在普通家庭或轻量办公环境中，这种方式显得有些繁琐。在 U 盘装机的环境中，我一般使用的 &lt;strong&gt;Ventoy&lt;/strong&gt;多合一 。不过 Ventoy 团队又推出了一个支持 PXE 的装机版本，名为 &lt;strong&gt;iVentoy&lt;/strong&gt;，和 WDS 类似，不过更加省心，这个应用已经上架懒猫微服的应用商店，非常适合内网多机装系统的场景。终于不用再琢磨 WDS 了。还有就是之前不小心用店家带的 U 盘把主机的所有数据都格式化了，这种手残也一去不复返了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250601202019460.png&quot; alt=&quot;iVentoy商店界面&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-PXE-无盘装机？&quot;&gt;&lt;a href=&quot;#什么是-PXE-无盘装机？&quot; class=&quot;headerlink&quot; title=&quot;什么是 PXE 无盘装机？&quot;&gt;&lt;/a&gt;什么是 PXE 无盘装机？&lt;/h3&gt;&lt;p&gt;PXE，全称 &lt;strong&gt;Preboot eXecution Environment&lt;/strong&gt;，是一种允许电脑在没有本地操作系统、光盘或 U 盘的情况下，通过网络从服务器下载引导程序并完成系统安装的机制。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十三）：懒猫穿透不只图形化，纯命令行服务器也可以</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%87%92%E7%8C%AB%E7%A9%BF%E9%80%8F%E4%B8%8D%E5%8F%AA%E5%9B%BE%E5%BD%A2%E5%8C%96%EF%BC%8C%E7%BA%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8F%AF%E4%BB%A5/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E6%87%92%E7%8C%AB%E7%A9%BF%E9%80%8F%E4%B8%8D%E5%8F%AA%E5%9B%BE%E5%BD%A2%E5%8C%96%EF%BC%8C%E7%BA%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8F%AF%E4%BB%A5/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>需要解析 <code>heiyu.space</code> 这个域名就得安装客户端，突然发现懒猫微服的客户端都是图形化界面。对于服务器环境，特别是没有图形界面的服务器，我们需要纯命令行解决方案。</p><p>随着公网 IPv4 地址即将枯竭，许多云厂商的学生机也不再提供公网 IP，这迫使开发者寻找异地组网方案。虽然 Tailscale 是一个可选方案，但作为懒猫微服用户，我更希望利用懒猫自带的组网功能实现这一需求。</p><p>在 VIP 群咨询后，获得了服务端组网工具：<br><a href="https://gitee.com/lazycatcloud/hclient-cli">https://gitee.com/lazycatcloud/hclient-cli</a></p><p>和花生壳的 CLI 类似，但是比花生壳省心多了。（这里不再过多吐槽花生壳系列了）</p><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="1-下载与初始运行"><a href="#1-下载与初始运行" class="headerlink" title="1. 下载与初始运行"></a>1. 下载与初始运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./hclient-cli-<span class="variable">$arch</span> <span class="comment"># 首次启动需要添加可执行权限</span></span><br><span class="line">./hclient-cli-<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>初始运行会提示：<br><strong>当前为非 tun 模式,仅支持通过 http 代理访问微服或其他设备资源</strong></p><p>然后就会提示<strong>当前为非 tun 模式,仅支持通过 http 代理访问微服或其他设备资源</strong>，也就是说现在是单项的组网，这肯定不是我的要求，然后 GPT O3 给了我一个答案。</p><h4 id="2-启用-TUN-模式"><a href="#2-启用-TUN-模式" class="headerlink" title="2. 启用 TUN 模式"></a>2. 启用 TUN 模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./hclient-cli-<span class="variable">$arch</span> -tun <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>再启动之后，就没有那个 TUN 模式的提示了。如下</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250602191812289.png" alt="hclient-cli启动界面"></p><h4 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h4><p>然后需要使用命令添加，bname 是机器的名字，uid 和 password 是用户名和密码，这样就保证了全球唯一性质，执行完第一步的时候已有的客户端会弹出验证码，执行完第二步就会消失。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/1187b6cb50dd4eab5c211f927f5bbbd6.png" alt="1187b6cb50dd4eab5c211f927f5bbbd6"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加微服</span></span><br><span class="line">curl -X POST <span class="string">&#x27;http://127.0.0.1:7777/add_box?bname=%s&amp;uid=%s&amp;password=%s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置TFA Code（两步验证码）</span></span><br><span class="line">curl -X POST <span class="string">&#x27;http://127.0.0.1:7777/add_tfa?bname=%s&amp;tfa=%s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列举微服</span></span><br><span class="line">curl <span class="string">&#x27;http://127.0.0.1:7777/box_list&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除微服</span></span><br><span class="line">curl -X DELETE <span class="string">&#x27;http://127.0.0.1:7777/del_box?bname=%s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前客户端信息</span></span><br><span class="line">curl <span class="string">&#x27;http://127.0.0.1:7777/client_info&#x27;</span></span><br></pre></td></tr></table></figure><p>在<strong>懒猫微服设备监控</strong>中可以看到加入的设备。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250602191830359.png" alt="设备监控界面"></p><h3 id="2-访问验证"><a href="#2-访问验证" class="headerlink" title="2. 访问验证"></a>2. 访问验证</h3><p>一开始去访问我写的面食比例计算机，发现了重定向了，才想到懒猫默认给所有的应用加了一个认证。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;https://micro.heiyu.space/sys/login?redirect=https%3A%2F%2Fflour-calc.name.heiyu.space%2F&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>Temporary Redirect&lt;/a</span><br><span class="line">&gt;.</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250602202752227.png" alt="认证界面"></p><h3 id="3-双向访问测试"><a href="#3-双向访问测试" class="headerlink" title="3. 双向访问测试"></a>3. 双向访问测试</h3><p>商店里的 elasticsearch 放行了所有路由，这样我们在终端和 SDK 就不再需要走那个 web 的验证了，不然只能在请求头里面硬塞 cookie，但是如果是多层认证就非常的难搞。从图片中可以看到，我们从云服务器可以成功访问到家里的懒猫微服了。这个代表从云服务回到家里时没有问题的。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/ab21f6aafea87f704df434047a587c37.png" alt="云服务器访问家庭网络"></p><h3 id="4-SSH-访问测试"><a href="#4-SSH-访问测试" class="headerlink" title="4. SSH 访问测试"></a>4. SSH 访问测试</h3><p>其实更多的时候我们的异地组网是为了能够在没有公网 IP 的情况下访问节点，查一下监控设备中的域名，然后 ssh 访问进去，发现基本没什么问题。所以就能够双向访问了，这样我们组网的目的就达到了。<br><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/e5316a84db1f258801b864c5bd18eef2.png" alt="SSH连接成功"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过懒猫微服的 CLI 工具，我们成功实现了：</p><ol><li>无图形界面服务器的穿透接入</li><li>双向网络访问</li></ol><p><img src="https://lzc-playground-1301583638.cos.ap-chengdu.myqcloud.com/guidelines/459/06da8512-7447-496c-a5f1-669059d134cf.png" alt="77dea8a6a38817c503c379dd946fc9e4.png" title="77dea8a6a38817c503c379dd946fc9e4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要解析 &lt;code&gt;heiyu.space&lt;/code&gt; 这个域名就得安装客户端，突然发现懒猫微服的客户端都是图形化界面。对于服务器环境，特别是没有图形界面的服务器，我们需要纯命令行解决方案。&lt;/p&gt;
&lt;p&gt;随着公网 IPv4 地址即将枯竭，许多云厂商的学生机也不再提供公网 IP，这迫使开发者寻找异地组网方案。虽然 Tailscale 是一个可选方案，但作为懒猫微服用户，我更希望利用懒猫自带的组网功能实现这一需求。&lt;/p&gt;
&lt;p&gt;在 VIP 群咨询后，获得了服务端组网工具：&lt;br&gt;&lt;a href=&quot;https://gitee.com/lazycatcloud/hclient-cli&quot;&gt;https://gitee.com/lazycatcloud/hclient-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;和花生壳的 CLI 类似，但是比花生壳省心多了。（这里不再过多吐槽花生壳系列了）&lt;/p&gt;
&lt;h3 id=&quot;安装与配置&quot;&gt;&lt;a href=&quot;#安装与配置&quot; class=&quot;headerlink&quot; title=&quot;安装与配置&quot;&gt;&lt;/a&gt;安装与配置&lt;/h3&gt;&lt;h4 id=&quot;1-下载与初始运行&quot;&gt;&lt;a href=&quot;#1-下载与初始运行&quot; class=&quot;headerlink&quot; title=&quot;1. 下载与初始运行&quot;&gt;&lt;/a&gt;1. 下载与初始运行&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;chmod&lt;/span&gt; +x ./hclient-cli-&lt;span class=&quot;variable&quot;&gt;$arch&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 首次启动需要添加可执行权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./hclient-cli-&lt;span class=&quot;variable&quot;&gt;$arch&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十四）：不登录客户端，如何用 Samba 挂载懒猫微服网盘？</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E4%B8%8D%E7%99%BB%E5%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8-samba-%E6%8C%82%E8%BD%BD%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%BD%91%E7%9B%98%EF%BC%9F/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E4%B8%8D%E7%99%BB%E5%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8-samba-%E6%8C%82%E8%BD%BD%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E7%BD%91%E7%9B%98%EF%BC%9F/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>懒猫微服网盘自带自动挂载 Samba 功能，但如果<strong>不登录客户端</strong>，也可以手动通过微服的私有地址来挂载，实现访问和高速传输。</p><p>由于懒猫网盘采用<strong>多租户架构</strong>，每位用户的数据是隔离的。因此，访问路径通常为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb://&lt;ip&gt;/&lt;用户名&gt;</span><br></pre></td></tr></table></figure><h2 id="🧩-步骤一：开启内网访问服务"><a href="#🧩-步骤一：开启内网访问服务" class="headerlink" title="🧩 步骤一：开启内网访问服务"></a>🧩 步骤一：开启内网访问服务</h2><p>在开始挂载前，<strong>请确保你已在懒猫微服后台开启了“内网访问服务”</strong>，否则 SMB 连接会被拒绝。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621230834943.png" alt="image-20250621230834943"></p><hr><span id="more"></span><h2 id="💡-回忆一波上机考试的方式"><a href="#💡-回忆一波上机考试的方式" class="headerlink" title="💡 回忆一波上机考试的方式"></a>💡 回忆一波上机考试的方式</h2><p>以前在上机考试时，老师会将题目放在服务器共享目录中，我们用 <code>Win + R</code> 输入 <code>\\IP地址</code> 来下载资料，当时还觉得这操作很高端。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621224004995.png" alt="image-20250621224004995"></p><p><strong>解释：</strong><br>这是通过 <code>Win + R</code> 快捷键打开“运行”窗口，输入 <code>\\&lt;IP&gt;</code> 快速访问局域网 SMB 共享目录。通常用于临时打开文件夹，不做映射。</p><hr><h2 id="🐧-macOS-Linux-挂载方式（CLI）"><a href="#🐧-macOS-Linux-挂载方式（CLI）" class="headerlink" title="🐧 macOS&#x2F;Linux 挂载方式（CLI）"></a>🐧 macOS&#x2F;Linux 挂载方式（CLI）</h2><p>在 Linux 或 macOS 上，可以直接用以下地址挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb://&lt;ip&gt;/Download</span><br></pre></td></tr></table></figure><p>或者通过 <code>mount.cifs</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -t cifs //192.168.1.100/your-username /mnt/share -o user=your-username,password=your-password</span><br></pre></td></tr></table></figure><hr><h2 id="🪟-Windows-上手动挂载-SMB-网盘"><a href="#🪟-Windows-上手动挂载-SMB-网盘" class="headerlink" title="🪟 Windows 上手动挂载 SMB 网盘"></a>🪟 Windows 上手动挂载 SMB 网盘</h2><p>在 Windows 中，需要通过图形界面手动挂载为本地磁盘，操作如下：</p><h3 id="第一步：右键“此电脑”-→-映射网络驱动器"><a href="#第一步：右键“此电脑”-→-映射网络驱动器" class="headerlink" title="第一步：右键“此电脑” → 映射网络驱动器"></a>第一步：右键“此电脑” → <strong>映射网络驱动器</strong></h3><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621224142450.png" alt="image-20250621224142450"></p><p><strong>解释：</strong><br>在这里你可以：</p><ul><li>选择盘符（建议使用末尾的 <code>Z:</code>, <code>Y:</code>, <code>X:</code> 等）；</li><li>输入共享路径（例如 <code>\\192.168.1.100\your-username</code>）；</li><li>可勾选“使用其他凭据连接”等选项。</li></ul><hr><h3 id="第二步：确认挂载路径并验证身份"><a href="#第二步：确认挂载路径并验证身份" class="headerlink" title="第二步：确认挂载路径并验证身份"></a>第二步：确认挂载路径并验证身份</h3><p>系统将提示输入用户名和密码：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621224120769.png" alt="image-20250621224120769"></p><hr><h3 id="第三步：挂载成功，查看-Z-盘内容"><a href="#第三步：挂载成功，查看-Z-盘内容" class="headerlink" title="第三步：挂载成功，查看 Z 盘内容"></a>第三步：挂载成功，查看 Z 盘内容</h3><p>成功后，可以在“此电脑”中看到挂载好的 SMB 网络盘：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621230132415.png" alt="image-20250621230132415"></p><p>你可以像操作本地硬盘一样打开、拖拽、复制文件。</p><hr><h3 id="打开挂载目录后的界面如下："><a href="#打开挂载目录后的界面如下：" class="headerlink" title="打开挂载目录后的界面如下："></a>打开挂载目录后的界面如下：</h3><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621230747150.png" alt="image-20250621230747150"></p><hr><h2 id="🚀-实测传输速度：约-500MB-s"><a href="#🚀-实测传输速度：约-500MB-s" class="headerlink" title="🚀 实测传输速度：约 500MB&#x2F;s"></a>🚀 实测传输速度：约 500MB&#x2F;s</h2><p>我测试了一下，将文件从 SMB 网盘拖入 PVE 虚拟机，传输速度稳定在 <strong>500MB&#x2F;s</strong>，表现不错。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/bed30da7272c40a1203b34b834269b13.png" alt="bed30da7272c40a1203b34b834269b13"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒猫微服网盘自带自动挂载 Samba 功能，但如果&lt;strong&gt;不登录客户端&lt;/strong&gt;，也可以手动通过微服的私有地址来挂载，实现访问和高速传输。&lt;/p&gt;
&lt;p&gt;由于懒猫网盘采用&lt;strong&gt;多租户架构&lt;/strong&gt;，每位用户的数据是隔离的。因此，访问路径通常为：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;smb://&amp;lt;ip&amp;gt;/&amp;lt;用户名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;🧩-步骤一：开启内网访问服务&quot;&gt;&lt;a href=&quot;#🧩-步骤一：开启内网访问服务&quot; class=&quot;headerlink&quot; title=&quot;🧩 步骤一：开启内网访问服务&quot;&gt;&lt;/a&gt;🧩 步骤一：开启内网访问服务&lt;/h2&gt;&lt;p&gt;在开始挂载前，&lt;strong&gt;请确保你已在懒猫微服后台开启了“内网访问服务”&lt;/strong&gt;，否则 SMB 连接会被拒绝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250621230834943.png&quot; alt=&quot;image-20250621230834943&quot;&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="NAS" scheme="https://xu-hardy.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十五）：大疆Pocket3 素材导入懒猫网盘</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%A4%A7%E7%96%86pocket3-%E7%B4%A0%E6%9D%90%E5%AF%BC%E5%85%A5%E6%87%92%E7%8C%AB%E7%BD%91%E7%9B%98/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E5%A4%A7%E7%96%86pocket3-%E7%B4%A0%E6%9D%90%E5%AF%BC%E5%85%A5%E6%87%92%E7%8C%AB%E7%BD%91%E7%9B%98/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>日常使用 Pocket3 拍摄视频，就是共享比较麻烦，不然就得每个手机安装一个 app，然后再导出。突发奇想可以把素材传到懒猫网盘中，这样就解决了这个痛点。</p><p>大疆的机器每次连接都要走这个流程，不得不说真的很麻烦。这个 Wi-Fi 的记忆功能比较鸡肋。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624122938093.png" alt="image-20250624122938093"></p><p>连接之后需要右上角先把视频下载到手机本地，然后点击分享。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123556578.png" alt="image-20250624123556578"></p><p>这里可以选各种软件，比如 airdrop，微信，邮件。我这里选懒猫微服，点击之后就会跳转到懒猫网盘。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123606895.png" alt="image-20250624123606895"></p><p>第一次传输我发现速度慢的离谱。询问了售后才发现 ios 会默认在 wifi 网络不好时走流量的。</p><p>因为大疆的 pocket3 传输需要连接相机的 Wi-Fi。所以手机是整个一断网额的状态。这流量也不快。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123055526.png" alt="image-20250624123055526"></p><p>偷偷跑流量是手机和运行商的传统了，那么在蜂窝网络里给他关掉。关掉无线局域网助理。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123117094.png" alt="image-20250624123117094"></p><p>关了之后，再重复上边的操作，就发现懒猫网盘打不开了，嗯 这就是预期的行为了，不会偷偷的用网了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123004993.png" alt="image-20250624123004993"></p><p>于是询问大疆额售后能不能让机器连接家里的网，得到的回答是不行。只能手动切换 Wi-Fi。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123022647.png" alt="image-20250624123022647"></p><p>换了网之后再传输，这个速度就舒服多了，虽然没跑满千兆，但是也能够看了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123032634.png" alt="image-20250624123032634"></p><p>然后把上一步的视频文件夹共享出来，以后把素材都发到这个文件夹里。再共享给其他的懒猫用户，就很方便了。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624123207647.png" alt="image-20250624123207647"></p><blockquote><p>两个很想吐槽的地方</p><ol><li>大疆 pocket3 不能直接连家里 Wi-Fi，传文件到网盘必须换网</li><li>Apple 的 lighting 原生不支持 OTG，需要买转接头。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常使用 Pocket3 拍摄视频，就是共享比较麻烦，不然就得每个手机安装一个 app，然后再导出。突发奇想可以把素材传到懒猫网盘中，这样就解决了这个痛点。&lt;/p&gt;
&lt;p&gt;大疆的机器每次连接都要走这个流程，不得不说真的很麻烦。这个 Wi-Fi 的记忆功能比较鸡肋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624122938093.png&quot; alt=&quot;image-20250624122938093&quot;&gt;&lt;/p&gt;
&lt;p&gt;连接之后需要右上角先把视频下载到手机本地，然后点击分享。&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十六）：把懒猫微服当作 24 × 7 在线开发机</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%BD%93%E4%BD%9C-24-%C3%97-7-%E5%9C%A8%E7%BA%BF%E5%BC%80%E5%8F%91%E6%9C%BA/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E6%8A%8A%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%BD%93%E4%BD%9C-24-%C3%97-7-%E5%9C%A8%E7%BA%BF%E5%BC%80%E5%8F%91%E6%9C%BA/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>最近和极限科技沟通，将 <strong>INFINI Console</strong> 上架到懒猫微服。可以当作随时可用、不关机的 <strong>远程开发机</strong>。比如连接自己部署的 ES，中间件，数据库什么的。</p><h2 id="1-应用商店一键安装-INFINI-Console"><a href="#1-应用商店一键安装-INFINI-Console" class="headerlink" title="1. 应用商店一键安装 INFINI Console"></a>1. 应用商店一键安装 INFINI Console</h2><p>从懒猫微服应用商店搜索 <strong>Console</strong>，点击“安装”即可：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/a8de38c1a8d6cb8bf34ae697256ad230.png" alt="应用商店界面"></p><h2 id="2-初始化与登录"><a href="#2-初始化与登录" class="headerlink" title="2. 初始化与登录"></a>2. 初始化与登录</h2><p>初始化之后登录：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/Snipaste_2025-06-24_13-16-34.png" alt="登录页面"></p><span id="more"></span><p>首次登录后台，左侧侧边栏包含 <strong>Dashboard、Agents、Settings</strong> 等模块：</p><ul><li>Dashboard 默认展示 CPU &#x2F; 内存 &#x2F; 磁盘实时曲线。</li><li>顶栏可切换“明暗主题”并显示当前工作区 ID。</li><li>右下角有“检查更新”按钮，提示有新版时可一键升级。</li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/Snipaste_2025-06-24_13-16-57.png" alt="控制台主界面"></p><h2 id="3-用-Dockge-安装-Easysearch"><a href="#3-用-Dockge-安装-Easysearch" class="headerlink" title="3. 用 Dockge 安装 Easysearch"></a>3. 用 Dockge 安装 Easysearch</h2><p>ES 的话，我是直接用 Dockge 安装的，如果你需要啥中间价，数据库都可以用这个安装。</p><p>前提需要用 lzc-cli appstore copy-image 来获取国内的镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将官方镜像复制到懒猫内网仓库</span></span><br><span class="line">lzc-cli appstore copy-image infinilabs/easysearch:1.13.0-2159</span><br></pre></td></tr></table></figure><p>然后把 <code>docker run</code> 或 <code>docker-compose.yml</code> 中的镜像地址替换成上一步生成的私有 registry 地址即可。全部容器由 <strong>Dockge</strong> 图形化管理：<br>（截图信息要点）</p><ul><li>Dockge 左侧列出所有 Stack，右侧显示 Easysearch 服务状态为 <code>Running</code>。</li><li>端口 9200 已自动映射，重启、查看日志，都能一键完成。</li></ul><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250624164746305.png" alt="Dockge 管理界面"></p><h2 id="4-为什么说它适合做开发机？"><a href="#4-为什么说它适合做开发机？" class="headerlink" title="4. 为什么说它适合做开发机？"></a>4. 为什么说它适合做开发机？</h2><table><thead><tr><th>需求</th><th>懒猫微服能力</th><th>体验亮点</th></tr></thead><tbody><tr><td><strong>24 × 7 在线</strong></td><td>独立云主机，自动重启、监控告警</td><td>关掉本地电脑，服务仍在运行</td></tr><tr><td><strong>x86 架构</strong></td><td>后端统一使用 x86 节点</td><td>对 <strong>Mac M 系列（ARM）用户</strong>，可避免本地编译兼容性问题</td></tr><tr><td><strong>多端远程开发</strong></td><td>内置 Web Shell、端口映射、域名分配</td><td>VS Code Remote &#x2F; JetBrains Gateway 秒连接</td></tr><tr><td><strong>镜像同步</strong></td><td><code>lzc-cli appstore copy-image</code></td><td>国内网络下拉镜像不超时</td></tr><tr><td><strong>中间件生态</strong></td><td>Dockge + Compose</td><td>RabbitMQ、Redis、Postgres 都能一键启动</td></tr><tr><td><strong>环境变量管理</strong></td><td>UI + <code>.env</code> 托管</td><td>私密信息集中维护，避免泄漏</td></tr></tbody></table><p>总结下来，把懒猫微服当作一个可远程访问的轻量开发机还是挺合适的：</p><ol><li>不用担心公网 IP 和端口映射</li><li>应用商店部署方便快捷</li><li>支持命令行部署、私有镜像同步</li><li>用 Dockge 管理一套中间件生态完全没问题</li></ol><p>适合：<br>👉 想要随时随地调试项目的开发者<br>👉 不想在本地装一堆环境的轻量用户<br>👉 有多端共享、协作需求的远程开发场景</p><p>整套流程走下来，你只需一台浏览器，就能获得 <strong>24 × 7 不关机的云端开发环境</strong>。如果你也是 Mac M-芯片用户、经常出差或需要多端协作，不妨试试用懒猫微服托管自己的 DevBox。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近和极限科技沟通，将 &lt;strong&gt;INFINI Console&lt;/strong&gt; 上架到懒猫微服。可以当作随时可用、不关机的 &lt;strong&gt;远程开发机&lt;/strong&gt;。比如连接自己部署的 ES，中间件，数据库什么的。&lt;/p&gt;
&lt;h2 id=&quot;1-应用商店一键安装-INFINI-Console&quot;&gt;&lt;a href=&quot;#1-应用商店一键安装-INFINI-Console&quot; class=&quot;headerlink&quot; title=&quot;1. 应用商店一键安装 INFINI Console&quot;&gt;&lt;/a&gt;1. 应用商店一键安装 INFINI Console&lt;/h2&gt;&lt;p&gt;从懒猫微服应用商店搜索 &lt;strong&gt;Console&lt;/strong&gt;，点击“安装”即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/a8de38c1a8d6cb8bf34ae697256ad230.png&quot; alt=&quot;应用商店界面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-初始化与登录&quot;&gt;&lt;a href=&quot;#2-初始化与登录&quot; class=&quot;headerlink&quot; title=&quot;2. 初始化与登录&quot;&gt;&lt;/a&gt;2. 初始化与登录&lt;/h2&gt;&lt;p&gt;初始化之后登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/Snipaste_2025-06-24_13-16-34.png&quot; alt=&quot;登录页面&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>懒猫微服实战入门（十七）：把 Steam 游戏存到懒猫网盘</title>
    <link href="https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%8A%8A-steam-%E6%B8%B8%E6%88%8F%E5%AD%98%E5%88%B0%E6%87%92%E7%8C%AB%E7%BD%91%E7%9B%98/"/>
    <id>https://xu-hardy.github.io/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9A%E6%8A%8A-steam-%E6%B8%B8%E6%88%8F%E5%AD%98%E5%88%B0%E6%87%92%E7%8C%AB%E7%BD%91%E7%9B%98/</id>
    <published>2025-07-01T16:00:00.000Z</published>
    <updated>2025-06-30T12:13:48.962Z</updated>
    
    <content type="html"><![CDATA[<p>懒猫微服的网盘基本可以替代一些公有的网盘，还有一个好处是可以自动挂载，只要打开懒猫微服的客户端，然后自动把网盘就能自动挂载到 Finder，十分方便。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250627201448767.png" alt="image-20250627201448767"></p><p>网盘的挂载是支持了 WebDAV 和 Sambda。这是常见的两种远程访问的协议。</p><p><strong>WebDAV（Web Distributed Authoring and Versioning）</strong>主要用于 <strong>HTTP&#x2F;HTTPS 协议</strong> 的文件共享，适合 <strong>远程访问、云存储</strong>。基于 HTTP&#x2F;HTTPS<strong>，可在浏览器中直接访问（如 <code>http://server/webdav</code>）。</strong></p><p>SMB（Server Message Block）&#x2F; Samba 主要用于 <strong>局域网文件共享</strong>（如 Windows 共享文件夹、NAS、企业内网存储）。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250627211645046.png" alt="image-20250627211645046"></p><span id="more"></span><p>通过 mount 命令可以看到，懒猫微服客户端默认使用的是 SMB 协议挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//xu-automount@file.micro.heiyu.space/xu-automount on /Users/xu/lazycat_automount/micro (smbfs, nodev, nosuid, mounted by xu)</span><br><span class="line">//xu-automount@file.micro.heiyu.space/xu on /Volumes/xu (smbfs, nodev, nosuid, mounted by xu)</span><br></pre></td></tr></table></figure><p>默认有两个文件夹，其实都是指向网盘根目录的软连接。两者内容完全一样。</p><blockquote><p>&lt;用户名&gt;-automount：这个应该不是自动挂载到文件管理器的目录</p><p>&lt;用户名&gt;: 这个是网盘多租户的目录</p></blockquote><p>所以在 Steam 里我们直接添加驱动器就好：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/a1a7bbcb4236bc63c91151d9dc3a53b6.png" alt="a1a7bbcb4236bc63c91151d9dc3a53b6"></p><p>然后可以选择这两个文件目录，就像前面介绍的，这两个选择哪个都行：</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/ff20f0dc7b36ba7e27ad18ce45b2c378.png" alt="ff20f0dc7b36ba7e27ad18ce45b2c378"></p><p>然后这个时候会弹出来这个提示。我们选择允许。这样 Steam 才能有写入懒猫网盘的权限。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/b90bea03eed9f716a64f52ae16a2526f.png" alt="b90bea03eed9f716a64f52ae16a2526f"></p><p>然后选择下载之后，我们发现网盘里多了一个 SteamLibrary 的目录。所有的游戏都存在这里。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/7733bdd613320011b0de6ad55032cc19.png" alt="7733bdd613320011b0de6ad55032cc19"></p><p>如果你比较习惯网盘的页面，也可以在网盘里找到 SteamLibrary 的目录</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250627202118461.png" alt="image-20250627202118461"></p><p>如果哪天不再需要写入懒猫网盘，用这个办法删除。网上吐槽挺多的。</p><p><img src="https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/788d94c0cb77ec7c66aa3de73f414462.png" alt="788d94c0cb77ec7c66aa3de73f414462"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒猫微服的网盘基本可以替代一些公有的网盘，还有一个好处是可以自动挂载，只要打开懒猫微服的客户端，然后自动把网盘就能自动挂载到 Finder，十分方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250627201448767.png&quot; alt=&quot;image-20250627201448767&quot;&gt;&lt;/p&gt;
&lt;p&gt;网盘的挂载是支持了 WebDAV 和 Sambda。这是常见的两种远程访问的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebDAV（Web Distributed Authoring and Versioning）&lt;/strong&gt;主要用于 &lt;strong&gt;HTTP&amp;#x2F;HTTPS 协议&lt;/strong&gt; 的文件共享，适合 &lt;strong&gt;远程访问、云存储&lt;/strong&gt;。基于 HTTP&amp;#x2F;HTTPS&lt;strong&gt;，可在浏览器中直接访问（如 &lt;code&gt;http://server/webdav&lt;/code&gt;）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SMB（Server Message Block）&amp;#x2F; Samba 主要用于 &lt;strong&gt;局域网文件共享&lt;/strong&gt;（如 Windows 共享文件夹、NAS、企业内网存储）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cloudsmithy/picgo-imh/master/image-20250627211645046.png&quot; alt=&quot;image-20250627211645046&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/categories/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
    
    <category term="懒猫微服" scheme="https://xu-hardy.github.io/tags/%E6%87%92%E7%8C%AB%E5%BE%AE%E6%9C%8D/"/>
    
  </entry>
  
</feed>
